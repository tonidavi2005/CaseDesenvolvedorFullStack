

/*! jQuery v1.12.4 | (c) jQuery Foundation | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=a.document,e=c.slice,f=c.concat,g=c.push,h=c.indexOf,i={},j=i.toString,k=i.hasOwnProperty,l={},m="1.12.4",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return e.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:e.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a){return n.each(this,a)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(e.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:g,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray||function(a){return"array"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){var b=a&&a.toString();return!n.isArray(a)&&b-parseFloat(b)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!k.call(a,"constructor")&&!k.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(!l.ownFirst)for(b in a)return k.call(a,b);for(b in a);return void 0===b||k.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?i[j.call(a)]||"object":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(s(a)){for(c=a.length;c>d;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):g.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(h)return h.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,g=0,h=[];if(s(a))for(d=a.length;d>g;g++)e=b(a[g],g,c),null!=e&&h.push(e);else for(g in a)e=b(a[g],g,c),null!=e&&h.push(e);return f.apply([],h)},guid:1,proxy:function(a,b){var c,d,f;return"string"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=e.call(arguments,2),d=function(){return a.apply(b||this,c.concat(e.call(arguments)))},d.guid=a.guid=a.guid||n.guid++,d):void 0},now:function(){return+new Date},support:l}),"function"==typeof Symbol&&(n.fn[Symbol.iterator]=c[Symbol.iterator]),n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){i["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=!!a&&"length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ga(),z=ga(),A=ga(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+M+"))|)"+L+"*\\]",O=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+N+")*)|.*)\\)|)",P=new RegExp(L+"+","g"),Q=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),R=new RegExp("^"+L+"*,"+L+"*"),S=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),T=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),U=new RegExp(O),V=new RegExp("^"+M+"$"),W={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M+"|[*])"),ATTR:new RegExp("^"+N),PSEUDO:new RegExp("^"+O),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},X=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,$=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,_=/[+~]/,aa=/'|\\/g,ba=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),ca=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},da=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(ea){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fa(a,b,d,e){var f,h,j,k,l,o,r,s,w=b&&b.ownerDocument,x=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==x&&9!==x&&11!==x)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==x&&(o=$.exec(a)))if(f=o[1]){if(9===x){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(w&&(j=w.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(o[2])return H.apply(d,b.getElementsByTagName(a)),d;if((f=o[3])&&c.getElementsByClassName&&b.getElementsByClassName)return H.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==x)w=b,s=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(aa,"\\$&"):b.setAttribute("id",k=u),r=g(a),h=r.length,l=V.test(k)?"#"+k:"[id='"+k+"']";while(h--)r[h]=l+" "+qa(r[h]);s=r.join(","),w=_.test(a)&&oa(b.parentNode)||b}if(s)try{return H.apply(d,w.querySelectorAll(s)),d}catch(y){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(Q,"$1"),b,d,e)}function ga(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ha(a){return a[u]=!0,a}function ia(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ja(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function ka(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function la(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function na(a){return ha(function(b){return b=+b,ha(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function oa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=fa.support={},f=fa.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fa.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ia(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ia(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Z.test(n.getElementsByClassName),c.getById=ia(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return"undefined"!=typeof b.getElementsByClassName&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=Z.test(n.querySelectorAll))&&(ia(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ia(function(a){var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Z.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ia(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",O)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Z.test(o.compareDocumentPosition),t=b||Z.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return ka(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?ka(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},fa.matches=function(a,b){return fa(a,null,null,b)},fa.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(T,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fa(b,n,null,[a]).length>0},fa.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fa.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fa.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fa.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fa.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fa.selectors={cacheLength:50,createPseudo:ha,match:W,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ba,ca),a[3]=(a[3]||a[4]||a[5]||"").replace(ba,ca),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fa.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fa.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return W.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&U.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ba,ca).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fa.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(P," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fa.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ha(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ha(function(a){var b=[],c=[],d=h(a.replace(Q,"$1"));return d[u]?ha(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ha(function(a){return function(b){return fa(a,b).length>0}}),contains:ha(function(a){return a=a.replace(ba,ca),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ha(function(a){return V.test(a||"")||fa.error("unsupported lang: "+a),a=a.replace(ba,ca).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Y.test(a.nodeName)},input:function(a){return X.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:na(function(){return[0]}),last:na(function(a,b){return[b-1]}),eq:na(function(a,b,c){return[0>c?c+b:c]}),even:na(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:na(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:na(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:na(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=la(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=ma(b);function pa(){}pa.prototype=d.filters=d.pseudos,d.setFilters=new pa,g=fa.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=R.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=S.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(Q," ")}),h=h.slice(c.length));for(g in d.filter)!(e=W[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fa.error(a):z(a,i).slice(0)};function qa(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function ra(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j,k=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(j=b[u]||(b[u]={}),i=j[b.uniqueID]||(j[b.uniqueID]={}),(h=i[d])&&h[0]===w&&h[1]===f)return k[2]=h[2];if(i[d]=k,k[2]=a(b,c,g))return!0}}}function sa(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ta(a,b,c){for(var d=0,e=b.length;e>d;d++)fa(a,b[d],c);return c}function ua(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function va(a,b,c,d,e,f){return d&&!d[u]&&(d=va(d)),e&&!e[u]&&(e=va(e,f)),ha(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ta(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ua(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ua(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ua(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function wa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ra(function(a){return a===b},h,!0),l=ra(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[ra(sa(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return va(i>1&&sa(m),i>1&&qa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(Q,"$1"),c,e>i&&wa(a.slice(i,e)),f>e&&wa(a=a.slice(e)),f>e&&qa(a))}m.push(c)}return sa(m)}function xa(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=F.call(i));u=ua(u)}H.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&fa.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ha(f):f}return h=fa.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xa(e,d)),f.selector=a}return f},i=fa.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ba,ca),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=W.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ba,ca),_.test(j[0].type)&&oa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qa(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,!b||_.test(a)&&oa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ia(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ia(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ja("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ia(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ja("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ia(function(a){return null==a.getAttribute("disabled")})||ja(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fa}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.uniqueSort=n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},v=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},w=n.expr.match.needsContext,x=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,y=/^.[^:#\[\.,]*$/;function z(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(y.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return n.inArray(a,b)>-1!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;e>b;b++)if(n.contains(d[b],this))return!0}));for(b=0;e>b;b++)n.find(a,d[b],c);return c=this.pushStack(e>1?n.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(z(this,a||[],!1))},not:function(a){return this.pushStack(z(this,a||[],!0))},is:function(a){return!!z(this,"string"==typeof a&&w.test(a)?n(a):a||[],!1).length}});var A,B=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=n.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||A,"string"==typeof a){if(e="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:B.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),x.test(e[1])&&n.isPlainObject(b))for(e in b)n.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}if(f=d.getElementById(e[2]),f&&f.parentNode){if(f.id!==e[2])return A.find(a);this.length=1,this[0]=f}return this.context=d,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof c.ready?c.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};C.prototype=n.fn,A=n(d);var D=/^(?:parents|prev(?:Until|All))/,E={children:!0,contents:!0,next:!0,prev:!0};n.fn.extend({has:function(a){var b,c=n(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(n.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=w.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?n.inArray(this[0],n(a)):n.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.uniqueSort(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function F(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return u(a,"parentNode")},parentsUntil:function(a,b,c){return u(a,"parentNode",c)},next:function(a){return F(a,"nextSibling")},prev:function(a){return F(a,"previousSibling")},nextAll:function(a){return u(a,"nextSibling")},prevAll:function(a){return u(a,"previousSibling")},nextUntil:function(a,b,c){return u(a,"nextSibling",c)},prevUntil:function(a,b,c){return u(a,"previousSibling",c)},siblings:function(a){return v((a.parentNode||{}).firstChild,a)},children:function(a){return v(a.firstChild)},contents:function(a){return n.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(E[a]||(e=n.uniqueSort(e)),D.test(a)&&(e=e.reverse())),this.pushStack(e)}});var G=/\S+/g;function H(a){var b={};return n.each(a.match(G)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?H(a):n.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){n.each(b,function(b,c){n.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==n.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return n.each(arguments,function(a,b){var c;while((c=n.inArray(b,f,c))>-1)f.splice(c,1),h>=c&&h--}),this},has:function(a){return a?n.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=!0,c||j.disable(),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().progress(c.notify).done(c.resolve).fail(c.reject):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=e.call(arguments),d=c.length,f=1!==d||a&&n.isFunction(a.promise)?d:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(d){b[a]=this,c[a]=arguments.length>1?e.call(arguments):d,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(d>1)for(i=new Array(d),j=new Array(d),k=new Array(d);d>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().progress(h(b,j,i)).done(h(b,k,c)).fail(g.reject):--f;return f||g.resolveWith(k,c),g.promise()}});var I;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(I.resolveWith(d,[n]),n.fn.triggerHandler&&(n(d).triggerHandler("ready"),n(d).off("ready"))))}});function J(){d.addEventListener?(d.removeEventListener("DOMContentLoaded",K),a.removeEventListener("load",K)):(d.detachEvent("onreadystatechange",K),a.detachEvent("onload",K))}function K(){(d.addEventListener||"load"===a.event.type||"complete"===d.readyState)&&(J(),n.ready())}n.ready.promise=function(b){if(!I)if(I=n.Deferred(),"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll)a.setTimeout(n.ready);else if(d.addEventListener)d.addEventListener("DOMContentLoaded",K),a.addEventListener("load",K);else{d.attachEvent("onreadystatechange",K),a.attachEvent("onload",K);var c=!1;try{c=null==a.frameElement&&d.documentElement}catch(e){}c&&c.doScroll&&!function f(){if(!n.isReady){try{c.doScroll("left")}catch(b){return a.setTimeout(f,50)}J(),n.ready()}}()}return I.promise(b)},n.ready.promise();var L;for(L in n(l))break;l.ownFirst="0"===L,l.inlineBlockNeedsLayout=!1,n(function(){var a,b,c,e;c=d.getElementsByTagName("body")[0],c&&c.style&&(b=d.createElement("div"),e=d.createElement("div"),e.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(e).appendChild(b),"undefined"!=typeof b.style.zoom&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",l.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(e))}),function(){var a=d.createElement("div");l.deleteExpando=!0;try{delete a.test}catch(b){l.deleteExpando=!1}a=null}();var M=function(a){var b=n.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b},N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(O,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}n.data(a,b,c)}else c=void 0;
}return c}function Q(a){var b;for(b in a)if(("data"!==b||!n.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;return!0}function R(a,b,d,e){if(M(a)){var f,g,h=n.expando,i=a.nodeType,j=i?n.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||n.guid++:h),j[k]||(j[k]=i?{}:{toJSON:n.noop}),"object"!=typeof b&&"function"!=typeof b||(e?j[k]=n.extend(j[k],b):j[k].data=n.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[n.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[n.camelCase(b)])):f=g,f}}function S(a,b,c){if(M(a)){var d,e,f=a.nodeType,g=f?n.cache:a,h=f?a[n.expando]:n.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){n.isArray(b)?b=b.concat(n.map(b,n.camelCase)):b in d?b=[b]:(b=n.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!Q(d):!n.isEmptyObject(d))return}(c||(delete g[h].data,Q(g[h])))&&(f?n.cleanData([a],!0):l.deleteExpando||g!=g.window?delete g[h]:g[h]=void 0)}}}n.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?n.cache[a[n.expando]]:a[n.expando],!!a&&!Q(a)},data:function(a,b,c){return R(a,b,c)},removeData:function(a,b){return S(a,b)},_data:function(a,b,c){return R(a,b,c,!0)},_removeData:function(a,b){return S(a,b,!0)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=n.data(f),1===f.nodeType&&!n._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));n._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){n.data(this,a)}):arguments.length>1?this.each(function(){n.data(this,a,b)}):f?P(f,a,n.data(f,a)):void 0},removeData:function(a){return this.each(function(){n.removeData(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=n._data(a,b),c&&(!d||n.isArray(c)?d=n._data(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return n._data(a,c)||n._data(a,c,{empty:n.Callbacks("once memory").add(function(){n._removeData(a,b+"queue"),n._removeData(a,c)})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=n._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}}),function(){var a;l.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,e;return c=d.getElementsByTagName("body")[0],c&&c.style?(b=d.createElement("div"),e=d.createElement("div"),e.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(e).appendChild(b),"undefined"!=typeof b.style.zoom&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(d.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(e),a):void 0}}();var T=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,U=new RegExp("^(?:([+-])=|)("+T+")([a-z%]*)$","i"),V=["Top","Right","Bottom","Left"],W=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)};function X(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return n.css(a,b,"")},i=h(),j=c&&c[3]||(n.cssNumber[b]?"":"px"),k=(n.cssNumber[b]||"px"!==j&&+i)&&U.exec(n.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,n.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var Y=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)Y(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},Z=/^(?:checkbox|radio)$/i,$=/<([\w:-]+)/,_=/^$|\/(?:java|ecma)script/i,aa=/^\s+/,ba="abbr|article|aside|audio|bdi|canvas|data|datalist|details|dialog|figcaption|figure|footer|header|hgroup|main|mark|meter|nav|output|picture|progress|section|summary|template|time|video";function ca(a){var b=ba.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}!function(){var a=d.createElement("div"),b=d.createDocumentFragment(),c=d.createElement("input");a.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",l.leadingWhitespace=3===a.firstChild.nodeType,l.tbody=!a.getElementsByTagName("tbody").length,l.htmlSerialize=!!a.getElementsByTagName("link").length,l.html5Clone="<:nav></:nav>"!==d.createElement("nav").cloneNode(!0).outerHTML,c.type="checkbox",c.checked=!0,b.appendChild(c),l.appendChecked=c.checked,a.innerHTML="<textarea>x</textarea>",l.noCloneChecked=!!a.cloneNode(!0).lastChild.defaultValue,b.appendChild(a),c=d.createElement("input"),c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),a.appendChild(c),l.checkClone=a.cloneNode(!0).cloneNode(!0).lastChild.checked,l.noCloneEvent=!!a.addEventListener,a[n.expando]=1,l.attributes=!a.getAttribute(n.expando)}();var da={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:l.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]};da.optgroup=da.option,da.tbody=da.tfoot=da.colgroup=da.caption=da.thead,da.th=da.td;function ea(a,b){var c,d,e=0,f="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||n.nodeName(d,b)?f.push(d):n.merge(f,ea(d,b));return void 0===b||b&&n.nodeName(a,b)?n.merge([a],f):f}function fa(a,b){for(var c,d=0;null!=(c=a[d]);d++)n._data(c,"globalEval",!b||n._data(b[d],"globalEval"))}var ga=/<|&#?\w+;/,ha=/<tbody/i;function ia(a){Z.test(a.type)&&(a.defaultChecked=a.checked)}function ja(a,b,c,d,e){for(var f,g,h,i,j,k,m,o=a.length,p=ca(b),q=[],r=0;o>r;r++)if(g=a[r],g||0===g)if("object"===n.type(g))n.merge(q,g.nodeType?[g]:g);else if(ga.test(g)){i=i||p.appendChild(b.createElement("div")),j=($.exec(g)||["",""])[1].toLowerCase(),m=da[j]||da._default,i.innerHTML=m[1]+n.htmlPrefilter(g)+m[2],f=m[0];while(f--)i=i.lastChild;if(!l.leadingWhitespace&&aa.test(g)&&q.push(b.createTextNode(aa.exec(g)[0])),!l.tbody){g="table"!==j||ha.test(g)?"<table>"!==m[1]||ha.test(g)?0:i:i.firstChild,f=g&&g.childNodes.length;while(f--)n.nodeName(k=g.childNodes[f],"tbody")&&!k.childNodes.length&&g.removeChild(k)}n.merge(q,i.childNodes),i.textContent="";while(i.firstChild)i.removeChild(i.firstChild);i=p.lastChild}else q.push(b.createTextNode(g));i&&p.removeChild(i),l.appendChecked||n.grep(ea(q,"input"),ia),r=0;while(g=q[r++])if(d&&n.inArray(g,d)>-1)e&&e.push(g);else if(h=n.contains(g.ownerDocument,g),i=ea(p.appendChild(g),"script"),h&&fa(i),c){f=0;while(g=i[f++])_.test(g.type||"")&&c.push(g)}return i=null,p}!function(){var b,c,e=d.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(l[b]=c in a)||(e.setAttribute(c,"t"),l[b]=e.attributes[c].expando===!1);e=null}();var ka=/^(?:input|select|textarea)$/i,la=/^key/,ma=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,na=/^(?:focusinfocus|focusoutblur)$/,oa=/^([^.]*)(?:\.(.+)|)/;function pa(){return!0}function qa(){return!1}function ra(){try{return d.activeElement}catch(a){}}function sa(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)sa(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=qa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return n().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=n.guid++)),a.each(function(){n.event.add(this,b,e,d,c)})}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=n.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return"undefined"==typeof n||a&&n.event.triggered===a.type?void 0:n.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(G)||[""],h=b.length;while(h--)f=oa.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=n.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=n.event.special[o]||{},l=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},i),(m=g[o])||(m=g[o]=[],m.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,l):m.push(l),n.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n.hasData(a)&&n._data(a);if(r&&(k=r.events)){b=(b||"").match(G)||[""],j=b.length;while(j--)if(h=oa.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=m.length;while(f--)g=m[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(m.splice(f,1),g.selector&&m.delegateCount--,l.remove&&l.remove.call(a,g));i&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(k)&&(delete r.handle,n._removeData(a,"events"))}},trigger:function(b,c,e,f){var g,h,i,j,l,m,o,p=[e||d],q=k.call(b,"type")?b.type:b,r=k.call(b,"namespace")?b.namespace.split("."):[];if(i=m=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!na.test(q+n.event.triggered)&&(q.indexOf(".")>-1&&(r=q.split("."),q=r.shift(),r.sort()),h=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=r.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:n.makeArray(c,[b]),l=n.event.special[q]||{},f||!l.trigger||l.trigger.apply(e,c)!==!1)){if(!f&&!l.noBubble&&!n.isWindow(e)){for(j=l.delegateType||q,na.test(j+q)||(i=i.parentNode);i;i=i.parentNode)p.push(i),m=i;m===(e.ownerDocument||d)&&p.push(m.defaultView||m.parentWindow||a)}o=0;while((i=p[o++])&&!b.isPropagationStopped())b.type=o>1?j:l.bindType||q,g=(n._data(i,"events")||{})[b.type]&&n._data(i,"handle"),g&&g.apply(i,c),g=h&&i[h],g&&g.apply&&M(i)&&(b.result=g.apply(i,c),b.result===!1&&b.preventDefault());if(b.type=q,!f&&!b.isDefaultPrevented()&&(!l._default||l._default.apply(p.pop(),c)===!1)&&M(e)&&h&&e[q]&&!n.isWindow(e)){m=e[h],m&&(e[h]=null),n.event.triggered=q;try{e[q]()}catch(s){}n.event.triggered=void 0,m&&(e[h]=m)}return b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,d,f,g,h=[],i=e.call(arguments),j=(n._data(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())a.rnamespace&&!a.rnamespace.test(g.namespace)||(a.handleObj=g,a.data=g.data,d=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==d&&(a.result=d)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&("click"!==a.type||isNaN(a.button)||a.button<1))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>-1:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[n.expando])return a;var b,c,e,f=a.type,g=a,h=this.fixHooks[f];h||(this.fixHooks[f]=h=ma.test(f)?this.mouseHooks:la.test(f)?this.keyHooks:{}),e=h.props?this.props.concat(h.props):this.props,a=new n.Event(g),b=e.length;while(b--)c=e[b],a[c]=g[c];return a.target||(a.target=g.srcElement||d),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,h.filter?h.filter(a,g):a},props:"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,e,f,g=b.button,h=b.fromElement;return null==a.pageX&&null!=b.clientX&&(e=a.target.ownerDocument||d,f=e.documentElement,c=e.body,a.pageX=b.clientX+(f&&f.scrollLeft||c&&c.scrollLeft||0)-(f&&f.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(f&&f.scrollTop||c&&c.scrollTop||0)-(f&&f.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&h&&(a.relatedTarget=h===a.target?b.toElement:h),a.which||void 0===g||(a.which=1&g?1:2&g?3:4&g?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ra()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ra()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return n.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c){var d=n.extend(new n.Event,c,{type:a,isSimulated:!0});n.event.trigger(d,null,b),d.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=d.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)}:function(a,b,c){var d="on"+b;a.detachEvent&&("undefined"==typeof a[d]&&(a[d]=null),a.detachEvent(d,c))},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?pa:qa):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={constructor:n.Event,isDefaultPrevented:qa,isPropagationStopped:qa,isImmediatePropagationStopped:qa,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=pa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=pa,a&&!this.isSimulated&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=pa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||n.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),l.submit||(n.event.special.submit={setup:function(){return n.nodeName(this,"form")?!1:void n.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=n.nodeName(b,"input")||n.nodeName(b,"button")?n.prop(b,"form"):void 0;c&&!n._data(c,"submit")&&(n.event.add(c,"submit._submit",function(a){a._submitBubble=!0}),n._data(c,"submit",!0))})},postDispatch:function(a){a._submitBubble&&(delete a._submitBubble,this.parentNode&&!a.isTrigger&&n.event.simulate("submit",this.parentNode,a))},teardown:function(){return n.nodeName(this,"form")?!1:void n.event.remove(this,"._submit")}}),l.change||(n.event.special.change={setup:function(){return ka.test(this.nodeName)?("checkbox"!==this.type&&"radio"!==this.type||(n.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._justChanged=!0)}),n.event.add(this,"click._change",function(a){this._justChanged&&!a.isTrigger&&(this._justChanged=!1),n.event.simulate("change",this,a)})),!1):void n.event.add(this,"beforeactivate._change",function(a){var b=a.target;ka.test(b.nodeName)&&!n._data(b,"change")&&(n.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||n.event.simulate("change",this.parentNode,a)}),n._data(b,"change",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return n.event.remove(this,"._change"),!ka.test(this.nodeName)}}),l.focusin||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a))};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=n._data(d,b);e||d.addEventListener(a,c,!0),n._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=n._data(d,b)-1;e?n._data(d,b,e):(d.removeEventListener(a,c,!0),n._removeData(d,b))}}}),n.fn.extend({on:function(a,b,c,d){return sa(this,a,b,c,d)},one:function(a,b,c,d){return sa(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=qa),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var ta=/ jQuery\d+="(?:null|\d+)"/g,ua=new RegExp("<(?:"+ba+")[\\s/>]","i"),va=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,wa=/<script|<style|<link/i,xa=/checked\s*(?:[^=]|=\s*.checked.)/i,ya=/^true\/(.*)/,za=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,Aa=ca(d),Ba=Aa.appendChild(d.createElement("div"));function Ca(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function Da(a){return a.type=(null!==n.find.attr(a,"type"))+"/"+a.type,a}function Ea(a){var b=ya.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Fa(a,b){if(1===b.nodeType&&n.hasData(a)){var c,d,e,f=n._data(a),g=n._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)n.event.add(b,c,h[c][d])}g.data&&(g.data=n.extend({},g.data))}}function Ga(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!l.noCloneEvent&&b[n.expando]){e=n._data(b);for(d in e.events)n.removeEvent(b,d,e.handle);b.removeAttribute(n.expando)}"script"===c&&b.text!==a.text?(Da(b).text=a.text,Ea(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),l.html5Clone&&a.innerHTML&&!n.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&Z.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}}function Ha(a,b,c,d){b=f.apply([],b);var e,g,h,i,j,k,m=0,o=a.length,p=o-1,q=b[0],r=n.isFunction(q);if(r||o>1&&"string"==typeof q&&!l.checkClone&&xa.test(q))return a.each(function(e){var f=a.eq(e);r&&(b[0]=q.call(this,e,f.html())),Ha(f,b,c,d)});if(o&&(k=ja(b,a[0].ownerDocument,!1,a,d),e=k.firstChild,1===k.childNodes.length&&(k=e),e||d)){for(i=n.map(ea(k,"script"),Da),h=i.length;o>m;m++)g=k,m!==p&&(g=n.clone(g,!0,!0),h&&n.merge(i,ea(g,"script"))),c.call(a[m],g,m);if(h)for(j=i[i.length-1].ownerDocument,n.map(i,Ea),m=0;h>m;m++)g=i[m],_.test(g.type||"")&&!n._data(g,"globalEval")&&n.contains(j,g)&&(g.src?n._evalUrl&&n._evalUrl(g.src):n.globalEval((g.text||g.textContent||g.innerHTML||"").replace(za,"")));k=e=null}return a}function Ia(a,b,c){for(var d,e=b?n.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||n.cleanData(ea(d)),d.parentNode&&(c&&n.contains(d.ownerDocument,d)&&fa(ea(d,"script")),d.parentNode.removeChild(d));return a}n.extend({htmlPrefilter:function(a){return a.replace(va,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h,i=n.contains(a.ownerDocument,a);if(l.html5Clone||n.isXMLDoc(a)||!ua.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(Ba.innerHTML=a.outerHTML,Ba.removeChild(f=Ba.firstChild)),!(l.noCloneEvent&&l.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(d=ea(f),h=ea(a),g=0;null!=(e=h[g]);++g)d[g]&&Ga(e,d[g]);if(b)if(c)for(h=h||ea(a),d=d||ea(f),g=0;null!=(e=h[g]);g++)Fa(e,d[g]);else Fa(a,f);return d=ea(f,"script"),d.length>0&&fa(d,!i&&ea(a,"script")),d=h=e=null,f},cleanData:function(a,b){for(var d,e,f,g,h=0,i=n.expando,j=n.cache,k=l.attributes,m=n.event.special;null!=(d=a[h]);h++)if((b||M(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)m[e]?n.event.remove(d,e):n.removeEvent(d,e,g.handle);j[f]&&(delete j[f],k||"undefined"==typeof d.removeAttribute?d[i]=void 0:d.removeAttribute(i),c.push(f))}}}),n.fn.extend({domManip:Ha,detach:function(a){return Ia(this,a,!0)},remove:function(a){return Ia(this,a)},text:function(a){return Y(this,function(a){return void 0===a?n.text(this):this.empty().append((this[0]&&this[0].ownerDocument||d).createTextNode(a))},null,a,arguments.length)},append:function(){return Ha(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ca(this,a);b.appendChild(a)}})},prepend:function(){return Ha(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ca(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ha(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ha(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&n.cleanData(ea(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&n.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return Y(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(ta,""):void 0;if("string"==typeof a&&!wa.test(a)&&(l.htmlSerialize||!ua.test(a))&&(l.leadingWhitespace||!aa.test(a))&&!da[($.exec(a)||["",""])[1].toLowerCase()]){a=n.htmlPrefilter(a);try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(ea(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ha(this,arguments,function(b){var c=this.parentNode;n.inArray(this,a)<0&&(n.cleanData(ea(this)),c&&c.replaceChild(b,this))},a)}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=0,e=[],f=n(a),h=f.length-1;h>=d;d++)c=d===h?this:this.clone(!0),n(f[d])[b](c),g.apply(e,c.get());return this.pushStack(e)}});var Ja,Ka={HTML:"block",BODY:"block"};function La(a,b){var c=n(b.createElement(a)).appendTo(b.body),d=n.css(c[0],"display");return c.detach(),d}function Ma(a){var b=d,c=Ka[a];return c||(c=La(a,b),"none"!==c&&c||(Ja=(Ja||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ja[0].contentWindow||Ja[0].contentDocument).document,b.write(),b.close(),c=La(a,b),Ja.detach()),Ka[a]=c),c}var Na=/^margin/,Oa=new RegExp("^("+T+")(?!px)[a-z%]+$","i"),Pa=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e},Qa=d.documentElement;!function(){var b,c,e,f,g,h,i=d.createElement("div"),j=d.createElement("div");if(j.style){j.style.cssText="float:left;opacity:.5",l.opacity="0.5"===j.style.opacity,l.cssFloat=!!j.style.cssFloat,j.style.backgroundClip="content-box",j.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===j.style.backgroundClip,i=d.createElement("div"),i.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",j.innerHTML="",i.appendChild(j),l.boxSizing=""===j.style.boxSizing||""===j.style.MozBoxSizing||""===j.style.WebkitBoxSizing,n.extend(l,{reliableHiddenOffsets:function(){return null==b&&k(),f},boxSizingReliable:function(){return null==b&&k(),e},pixelMarginRight:function(){return null==b&&k(),c},pixelPosition:function(){return null==b&&k(),b},reliableMarginRight:function(){return null==b&&k(),g},reliableMarginLeft:function(){return null==b&&k(),h}});function k(){var k,l,m=d.documentElement;m.appendChild(i),j.style.cssText="-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",b=e=h=!1,c=g=!0,a.getComputedStyle&&(l=a.getComputedStyle(j),b="1%"!==(l||{}).top,h="2px"===(l||{}).marginLeft,e="4px"===(l||{width:"4px"}).width,j.style.marginRight="50%",c="4px"===(l||{marginRight:"4px"}).marginRight,k=j.appendChild(d.createElement("div")),k.style.cssText=j.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",k.style.marginRight=k.style.width="0",j.style.width="1px",g=!parseFloat((a.getComputedStyle(k)||{}).marginRight),j.removeChild(k)),j.style.display="none",f=0===j.getClientRects().length,f&&(j.style.display="",j.innerHTML="<table><tr><td></td><td>t</td></tr></table>",j.childNodes[0].style.borderCollapse="separate",k=j.getElementsByTagName("td"),k[0].style.cssText="margin:0;border:0;padding:0;display:none",f=0===k[0].offsetHeight,f&&(k[0].style.display="",k[1].style.display="none",f=0===k[0].offsetHeight)),m.removeChild(i)}}}();var Ra,Sa,Ta=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ra=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)},Sa=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ra(a),g=c?c.getPropertyValue(b)||c[b]:void 0,""!==g&&void 0!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),c&&!l.pixelMarginRight()&&Oa.test(g)&&Na.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f),void 0===g?g:g+""}):Qa.currentStyle&&(Ra=function(a){return a.currentStyle},Sa=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ra(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Oa.test(g)&&!Ta.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function Ua(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Va=/alpha\([^)]*\)/i,Wa=/opacity\s*=\s*([^)]*)/i,Xa=/^(none|table(?!-c[ea]).+)/,Ya=new RegExp("^("+T+")(.*)$","i"),Za={position:"absolute",visibility:"hidden",display:"block"},$a={letterSpacing:"0",fontWeight:"400"},_a=["Webkit","O","Moz","ms"],ab=d.createElement("div").style;function bb(a){if(a in ab)return a;var b=a.charAt(0).toUpperCase()+a.slice(1),c=_a.length;while(c--)if(a=_a[c]+b,a in ab)return a}function cb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=n._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&W(d)&&(f[g]=n._data(d,"olddisplay",Ma(d.nodeName)))):(e=W(d),(c&&"none"!==c||!e)&&n._data(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function db(a,b,c){var d=Ya.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function eb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+V[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+V[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+V[f]+"Width",!0,e))):(g+=n.css(a,"padding"+V[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+V[f]+"Width",!0,e)));return g}function fb(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ra(a),g=l.boxSizing&&"border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Sa(a,b,f),(0>e||null==e)&&(e=a.style[b]),Oa.test(e))return e;d=g&&(l.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+eb(a,b,c||(g?"border":"content"),d,f)+"px"}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Sa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":l.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;if(b=n.cssProps[h]||(n.cssProps[h]=bb(h)||h),g=n.cssHooks[b]||n.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=U.exec(c))&&e[1]&&(c=X(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(n.cssNumber[h]?"":"px")),l.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=bb(h)||h),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Sa(a,b,d)),"normal"===f&&b in $a&&(f=$a[b]),""===c||c?(e=parseFloat(f),c===!0||isFinite(e)?e||0:f):f}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?Xa.test(n.css(a,"display"))&&0===a.offsetWidth?Pa(a,Za,function(){return fb(a,b,d)}):fb(a,b,d):void 0},set:function(a,c,d){var e=d&&Ra(a);return db(a,c,d?eb(a,b,d,l.boxSizing&&"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),l.opacity||(n.cssHooks.opacity={get:function(a,b){return Wa.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=n.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===n.trim(f.replace(Va,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Va.test(f)?f.replace(Va,e):f+" "+e)}}),n.cssHooks.marginRight=Ua(l.reliableMarginRight,function(a,b){return b?Pa(a,{display:"inline-block"},Sa,[a,"marginRight"]):void 0}),n.cssHooks.marginLeft=Ua(l.reliableMarginLeft,function(a,b){return b?(parseFloat(Sa(a,"marginLeft"))||(n.contains(a.ownerDocument,a)?a.getBoundingClientRect().left-Pa(a,{
marginLeft:0},function(){return a.getBoundingClientRect().left}):0))+"px":void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+V[d]+b]=f[d]||f[d-2]||f[0];return e}},Na.test(a)||(n.cssHooks[a+b].set=db)}),n.fn.extend({css:function(a,b){return Y(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=Ra(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return cb(this,!0)},hide:function(){return cb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){W(this)?n(this).show():n(this).hide()})}});function gb(a,b,c,d,e){return new gb.prototype.init(a,b,c,d,e)}n.Tween=gb,gb.prototype={constructor:gb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||n.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=gb.propHooks[this.prop];return a&&a.get?a.get(this):gb.propHooks._default.get(this)},run:function(a){var b,c=gb.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):gb.propHooks._default.set(this),this}},gb.prototype.init.prototype=gb.prototype,gb.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[n.cssProps[a.prop]]&&!n.cssHooks[a.prop]?a.elem[a.prop]=a.now:n.style(a.elem,a.prop,a.now+a.unit)}}},gb.propHooks.scrollTop=gb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},n.fx=gb.prototype.init,n.fx.step={};var hb,ib,jb=/^(?:toggle|show|hide)$/,kb=/queueHooks$/;function lb(){return a.setTimeout(function(){hb=void 0}),hb=n.now()}function mb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=V[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function nb(a,b,c){for(var d,e=(qb.tweeners[b]||[]).concat(qb.tweeners["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ob(a,b,c){var d,e,f,g,h,i,j,k,m=this,o={},p=a.style,q=a.nodeType&&W(a),r=n._data(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,m.always(function(){m.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=n.css(a,"display"),k="none"===j?n._data(a,"olddisplay")||Ma(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(l.inlineBlockNeedsLayout&&"inline"!==Ma(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",l.shrinkWrapBlocks()||m.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],jb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(o))"inline"===("none"===j?Ma(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=n._data(a,"fxshow",{}),f&&(r.hidden=!q),q?n(a).show():m.done(function(){n(a).hide()}),m.done(function(){var b;n._removeData(a,"fxshow");for(b in o)n.style(a,b,o[b])});for(d in o)g=nb(q?r[d]:0,d,m),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function pb(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function qb(a,b,c){var d,e,f=0,g=qb.prefilters.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=hb||lb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{},easing:n.easing._default},c),originalProperties:b,originalOptions:c,startTime:hb||lb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(pb(k,j.opts.specialEasing);g>f;f++)if(d=qb.prefilters[f].call(j,a,k,j.opts))return n.isFunction(d.stop)&&(n._queueHooks(j.elem,j.opts.queue).stop=n.proxy(d.stop,d)),d;return n.map(k,nb,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(qb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return X(c.elem,a,U.exec(b),c),c}]},tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.match(G);for(var c,d=0,e=a.length;e>d;d++)c=a[d],qb.tweeners[c]=qb.tweeners[c]||[],qb.tweeners[c].unshift(b)},prefilters:[ob],prefilter:function(a,b){b?qb.prefilters.unshift(a):qb.prefilters.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(W).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=qb(this,n.extend({},a),f);(e||n._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=n._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&kb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=n._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(mb(b,!0),a,d,e)}}),n.each({slideDown:mb("show"),slideUp:mb("hide"),slideToggle:mb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=n.timers,c=0;for(hb=n.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||n.fx.stop(),hb=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){ib||(ib=a.setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){a.clearInterval(ib),ib=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(b,c){return b=n.fx?n.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a,b=d.createElement("input"),c=d.createElement("div"),e=d.createElement("select"),f=e.appendChild(d.createElement("option"));c=d.createElement("div"),c.setAttribute("className","t"),c.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",a=c.getElementsByTagName("a")[0],b.setAttribute("type","checkbox"),c.appendChild(b),a=c.getElementsByTagName("a")[0],a.style.cssText="top:1px",l.getSetAttribute="t"!==c.className,l.style=/top/.test(a.getAttribute("style")),l.hrefNormalized="/a"===a.getAttribute("href"),l.checkOn=!!b.value,l.optSelected=f.selected,l.enctype=!!d.createElement("form").enctype,e.disabled=!0,l.optDisabled=!f.disabled,b=d.createElement("input"),b.setAttribute("value",""),l.input=""===b.getAttribute("value"),b.value="t",b.setAttribute("type","radio"),l.radioValue="t"===b.value}();var rb=/\r/g,sb=/[\x20\t\r\n\f]+/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a)).replace(sb," ")}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],(c.selected||i===e)&&(l.optDisabled?!c.disabled:null===c.getAttribute("disabled"))&&(!c.parentNode.disabled||!n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)if(d=e[g],n.inArray(n.valHooks.option.get(d),f)>-1)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>-1:void 0}},l.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var tb,ub,vb=n.expr.attrHandle,wb=/^(?:checked|selected)$/i,xb=l.getSetAttribute,yb=l.input;n.fn.extend({attr:function(a,b){return Y(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),e=n.attrHooks[b]||(n.expr.match.bool.test(b)?ub:tb)),void 0!==c?null===c?void n.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=n.find.attr(a,b),null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!l.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(G);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)?yb&&xb||!wb.test(c)?a[d]=!1:a[n.camelCase("default-"+c)]=a[d]=!1:n.attr(a,c,""),a.removeAttribute(xb?c:d)}}),ub={set:function(a,b,c){return b===!1?n.removeAttr(a,c):yb&&xb||!wb.test(c)?a.setAttribute(!xb&&n.propFix[c]||c,c):a[n.camelCase("default-"+c)]=a[c]=!0,c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=vb[b]||n.find.attr;yb&&xb||!wb.test(b)?vb[b]=function(a,b,d){var e,f;return d||(f=vb[b],vb[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,vb[b]=f),e}:vb[b]=function(a,b,c){return c?void 0:a[n.camelCase("default-"+b)]?b.toLowerCase():null}}),yb&&xb||(n.attrHooks.value={set:function(a,b,c){return n.nodeName(a,"input")?void(a.defaultValue=b):tb&&tb.set(a,b,c)}}),xb||(tb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},vb.id=vb.name=vb.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},n.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:tb.set},n.attrHooks.contenteditable={set:function(a,b,c){tb.set(a,""===b?!1:b,c)}},n.each(["width","height"],function(a,b){n.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),l.style||(n.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var zb=/^(?:input|select|textarea|button|object)$/i,Ab=/^(?:a|area)$/i;n.fn.extend({prop:function(a,b){return Y(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return a=n.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),n.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&n.isXMLDoc(a)||(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=n.find.attr(a,"tabindex");return b?parseInt(b,10):zb.test(a.nodeName)||Ab.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),l.hrefNormalized||n.each(["href","src"],function(a,b){n.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),l.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this}),l.enctype||(n.propFix.enctype="encoding");var Bb=/[\t\r\n\f]/g;function Cb(a){return n.attr(a,"class")||""}n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,Cb(this)))});if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=Cb(c),d=1===c.nodeType&&(" "+e+" ").replace(Bb," ")){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=n.trim(d),e!==h&&n.attr(c,"class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,Cb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=Cb(c),d=1===c.nodeType&&(" "+e+" ").replace(Bb," ")){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=n.trim(d),e!==h&&n.attr(c,"class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):n.isFunction(a)?this.each(function(c){n(this).toggleClass(a.call(this,c,Cb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=n(this),f=a.match(G)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=Cb(this),b&&n._data(this,"__className__",b),n.attr(this,"class",b||a===!1?"":n._data(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+Cb(c)+" ").replace(Bb," ").indexOf(b)>-1)return!0;return!1}}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Db=a.location,Eb=n.now(),Fb=/\?/,Gb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;n.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=n.trim(b+"");return e&&!n.trim(e.replace(Gb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():n.error("Invalid JSON: "+b)},n.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new a.DOMParser,c=d.parseFromString(b,"text/xml")):(c=new a.ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||n.error("Invalid XML: "+b),c};var Hb=/#.*$/,Ib=/([?&])_=[^&]*/,Jb=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Kb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Lb=/^(?:GET|HEAD)$/,Mb=/^\/\//,Nb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Ob={},Pb={},Qb="*/".concat("*"),Rb=Db.href,Sb=Nb.exec(Rb.toLowerCase())||[];function Tb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(G)||[];if(n.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Ub(a,b,c,d){var e={},f=a===Pb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Vb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&n.extend(!0,a,c),a}function Wb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Xb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Rb,type:"GET",isLocal:Kb.test(Sb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Qb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Vb(Vb(a,n.ajaxSettings),b):Vb(n.ajaxSettings,a)},ajaxPrefilter:Tb(Ob),ajaxTransport:Tb(Pb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var d,e,f,g,h,i,j,k,l=n.ajaxSetup({},c),m=l.context||l,o=l.context&&(m.nodeType||m.jquery)?n(m):n.event,p=n.Deferred(),q=n.Callbacks("once memory"),r=l.statusCode||{},s={},t={},u=0,v="canceled",w={readyState:0,getResponseHeader:function(a){var b;if(2===u){if(!k){k={};while(b=Jb.exec(g))k[b[1].toLowerCase()]=b[2]}b=k[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===u?g:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return u||(a=t[c]=t[c]||a,s[a]=b),this},overrideMimeType:function(a){return u||(l.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>u)for(b in a)r[b]=[r[b],a[b]];else w.always(a[w.status]);return this},abort:function(a){var b=a||v;return j&&j.abort(b),y(0,b),this}};if(p.promise(w).complete=q.add,w.success=w.done,w.error=w.fail,l.url=((b||l.url||Rb)+"").replace(Hb,"").replace(Mb,Sb[1]+"//"),l.type=c.method||c.type||l.method||l.type,l.dataTypes=n.trim(l.dataType||"*").toLowerCase().match(G)||[""],null==l.crossDomain&&(d=Nb.exec(l.url.toLowerCase()),l.crossDomain=!(!d||d[1]===Sb[1]&&d[2]===Sb[2]&&(d[3]||("http:"===d[1]?"80":"443"))===(Sb[3]||("http:"===Sb[1]?"80":"443")))),l.data&&l.processData&&"string"!=typeof l.data&&(l.data=n.param(l.data,l.traditional)),Ub(Ob,l,c,w),2===u)return w;i=n.event&&l.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),l.type=l.type.toUpperCase(),l.hasContent=!Lb.test(l.type),f=l.url,l.hasContent||(l.data&&(f=l.url+=(Fb.test(f)?"&":"?")+l.data,delete l.data),l.cache===!1&&(l.url=Ib.test(f)?f.replace(Ib,"$1_="+Eb++):f+(Fb.test(f)?"&":"?")+"_="+Eb++)),l.ifModified&&(n.lastModified[f]&&w.setRequestHeader("If-Modified-Since",n.lastModified[f]),n.etag[f]&&w.setRequestHeader("If-None-Match",n.etag[f])),(l.data&&l.hasContent&&l.contentType!==!1||c.contentType)&&w.setRequestHeader("Content-Type",l.contentType),w.setRequestHeader("Accept",l.dataTypes[0]&&l.accepts[l.dataTypes[0]]?l.accepts[l.dataTypes[0]]+("*"!==l.dataTypes[0]?", "+Qb+"; q=0.01":""):l.accepts["*"]);for(e in l.headers)w.setRequestHeader(e,l.headers[e]);if(l.beforeSend&&(l.beforeSend.call(m,w,l)===!1||2===u))return w.abort();v="abort";for(e in{success:1,error:1,complete:1})w[e](l[e]);if(j=Ub(Pb,l,c,w)){if(w.readyState=1,i&&o.trigger("ajaxSend",[w,l]),2===u)return w;l.async&&l.timeout>0&&(h=a.setTimeout(function(){w.abort("timeout")},l.timeout));try{u=1,j.send(s,y)}catch(x){if(!(2>u))throw x;y(-1,x)}}else y(-1,"No Transport");function y(b,c,d,e){var k,s,t,v,x,y=c;2!==u&&(u=2,h&&a.clearTimeout(h),j=void 0,g=e||"",w.readyState=b>0?4:0,k=b>=200&&300>b||304===b,d&&(v=Wb(l,w,d)),v=Xb(l,v,w,k),k?(l.ifModified&&(x=w.getResponseHeader("Last-Modified"),x&&(n.lastModified[f]=x),x=w.getResponseHeader("etag"),x&&(n.etag[f]=x)),204===b||"HEAD"===l.type?y="nocontent":304===b?y="notmodified":(y=v.state,s=v.data,t=v.error,k=!t)):(t=y,!b&&y||(y="error",0>b&&(b=0))),w.status=b,w.statusText=(c||y)+"",k?p.resolveWith(m,[s,y,w]):p.rejectWith(m,[w,y,t]),w.statusCode(r),r=void 0,i&&o.trigger(k?"ajaxSuccess":"ajaxError",[w,l,k?s:t]),q.fireWith(m,[w,y]),i&&(o.trigger("ajaxComplete",[w,l]),--n.active||n.event.trigger("ajaxStop")))}return w},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax(n.extend({url:a,type:b,dataType:e,data:c,success:d},n.isPlainObject(a)&&a))}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){if(n.isFunction(a))return this.each(function(b){n(this).wrapAll(a.call(this,b))});if(this[0]){var b=n(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return n.isFunction(a)?this.each(function(b){n(this).wrapInner(a.call(this,b))}):this.each(function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}});function Yb(a){return a.style&&a.style.display||n.css(a,"display")}function Zb(a){if(!n.contains(a.ownerDocument||d,a))return!0;while(a&&1===a.nodeType){if("none"===Yb(a)||"hidden"===a.type)return!0;a=a.parentNode}return!1}n.expr.filters.hidden=function(a){return l.reliableHiddenOffsets()?a.offsetWidth<=0&&a.offsetHeight<=0&&!a.getClientRects().length:Zb(a)},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var $b=/%20/g,_b=/\[\]$/,ac=/\r?\n/g,bc=/^(?:submit|button|image|reset|file)$/i,cc=/^(?:input|select|textarea|keygen)/i;function dc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||_b.test(a)?d(a,e):dc(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)dc(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)dc(c,a[c],b,e);return d.join("&").replace($b,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&cc.test(this.nodeName)&&!bc.test(a)&&(this.checked||!Z.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(ac,"\r\n")}}):{name:b.name,value:c.replace(ac,"\r\n")}}).get()}}),n.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return this.isLocal?ic():d.documentMode>8?hc():/^(get|post|head|put|delete|options)$/i.test(this.type)&&hc()||ic()}:hc;var ec=0,fc={},gc=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in fc)fc[a](void 0,!0)}),l.cors=!!gc&&"withCredentials"in gc,gc=l.ajax=!!gc,gc&&n.ajaxTransport(function(b){if(!b.crossDomain||l.cors){var c;return{send:function(d,e){var f,g=b.xhr(),h=++ec;if(g.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(f in b.xhrFields)g[f]=b.xhrFields[f];b.mimeType&&g.overrideMimeType&&g.overrideMimeType(b.mimeType),b.crossDomain||d["X-Requested-With"]||(d["X-Requested-With"]="XMLHttpRequest");for(f in d)void 0!==d[f]&&g.setRequestHeader(f,d[f]+"");g.send(b.hasContent&&b.data||null),c=function(a,d){var f,i,j;if(c&&(d||4===g.readyState))if(delete fc[h],c=void 0,g.onreadystatechange=n.noop,d)4!==g.readyState&&g.abort();else{j={},f=g.status,"string"==typeof g.responseText&&(j.text=g.responseText);try{i=g.statusText}catch(k){i=""}f||!b.isLocal||b.crossDomain?1223===f&&(f=204):f=j.text?200:404}j&&e(f,i,j,g.getAllResponseHeaders())},b.async?4===g.readyState?a.setTimeout(c):g.onreadystatechange=fc[h]=c:c()},abort:function(){c&&c(void 0,!0)}}}});function hc(){try{return new a.XMLHttpRequest}catch(b){}}function ic(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=d.head||n("head")[0]||d.documentElement;return{send:function(e,f){b=d.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||f(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var jc=[],kc=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=jc.pop()||n.expando+"_"+Eb++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(kc.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&kc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(kc,"$1"+e):b.jsonp!==!1&&(b.url+=(Fb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?n(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,jc.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||d;var e=x.exec(a),f=!c&&[];return e?[b.createElement(e[1])]:(e=ja([a],b,f),f&&f.length&&n(f).remove(),n.merge([],e.childNodes))};var lc=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&lc)return lc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=n.trim(a.slice(h,a.length)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};function mc(a){return n.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&n.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,n.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,n.contains(b,e)?("undefined"!=typeof e.getBoundingClientRect&&(d=e.getBoundingClientRect()),c=mc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===n.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(c=a.offset()),c.top+=n.css(a[0],"borderTopWidth",!0),c.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-n.css(d,"marginTop",!0),left:b.left-c.left-n.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Qa})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);n.fn[a]=function(d){return Y(this,function(a,d,e){var f=mc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?n(f).scrollLeft():e,c?e:n(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=Ua(l.pixelPosition,function(a,c){return c?(c=Sa(a,b),Oa.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({
padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return Y(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var nc=a.jQuery,oc=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=oc),b&&a.jQuery===n&&(a.jQuery=nc),n},b||(a.jQuery=a.$=n),n});
/* Promise polyfill for ES5 */
!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n():"function"==typeof define&&define.amd?define(n):n()}(0,function(){"use strict";function e(e){var n=this.constructor;return this.then(function(t){return n.resolve(e()).then(function(){return t})},function(t){return n.resolve(e()).then(function(){return n.reject(t)})})}function n(e){return!(!e||"undefined"==typeof e.length)}function t(){}function o(e){if(!(this instanceof o))throw new TypeError("Promises must be constructed via new");if("function"!=typeof e)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=undefined,this._deferreds=[],c(e,this)}function r(e,n){for(;3===e._state;)e=e._value;0!==e._state?(e._handled=!0,o._immediateFn(function(){var t=1===e._state?n.onFulfilled:n.onRejected;if(null!==t){var o;try{o=t(e._value)}catch(r){return void f(n.promise,r)}i(n.promise,o)}else(1===e._state?i:f)(n.promise,e._value)})):e._deferreds.push(n)}function i(e,n){try{if(n===e)throw new TypeError("A promise cannot be resolved with itself.");if(n&&("object"==typeof n||"function"==typeof n)){var t=n.then;if(n instanceof o)return e._state=3,e._value=n,void u(e);if("function"==typeof t)return void c(function(e,n){return function(){e.apply(n,arguments)}}(t,n),e)}e._state=1,e._value=n,u(e)}catch(r){f(e,r)}}function f(e,n){e._state=2,e._value=n,u(e)}function u(e){2===e._state&&0===e._deferreds.length&&o._immediateFn(function(){e._handled||o._unhandledRejectionFn(e._value)});for(var n=0,t=e._deferreds.length;t>n;n++)r(e,e._deferreds[n]);e._deferreds=null}function c(e,n){var t=!1;try{e(function(e){t||(t=!0,i(n,e))},function(e){t||(t=!0,f(n,e))})}catch(o){if(t)return;t=!0,f(n,o)}}var a=setTimeout;o.prototype["catch"]=function(e){return this.then(null,e)},o.prototype.then=function(e,n){var o=new this.constructor(t);return r(this,new function(e,n,t){this.onFulfilled="function"==typeof e?e:null,this.onRejected="function"==typeof n?n:null,this.promise=t}(e,n,o)),o},o.prototype["finally"]=e,o.all=function(e){return new o(function(t,o){function r(e,n){try{if(n&&("object"==typeof n||"function"==typeof n)){var u=n.then;if("function"==typeof u)return void u.call(n,function(n){r(e,n)},o)}i[e]=n,0==--f&&t(i)}catch(c){o(c)}}if(!n(e))return o(new TypeError("Promise.all accepts an array"));var i=Array.prototype.slice.call(e);if(0===i.length)return t([]);for(var f=i.length,u=0;i.length>u;u++)r(u,i[u])})},o.resolve=function(e){return e&&"object"==typeof e&&e.constructor===o?e:new o(function(n){n(e)})},o.reject=function(e){return new o(function(n,t){t(e)})},o.race=function(e){return new o(function(t,r){if(!n(e))return r(new TypeError("Promise.race accepts an array"));for(var i=0,f=e.length;f>i;i++)o.resolve(e[i]).then(t,r)})},o._immediateFn="function"==typeof setImmediate&&function(e){setImmediate(e)}||function(e){a(e,0)},o._unhandledRejectionFn=function(e){void 0!==console&&console&&console.warn("Possible Unhandled Promise Rejection:",e)};var l=function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw Error("unable to locate global object")}();"Promise"in l?l.Promise.prototype["finally"]||(l.Promise.prototype["finally"]=e):l.Promise=o});

// 86acbd31cd7c09cf30acb66d2fbedc91daa48b86:1617891839.5269887
!function (n, r, e, t, c) {
	var i, o = "Promise" in n, u = {
		then: function () { return u }, catch: function (n) {
			return n(new Error("Airship SDK Error: Unsupported browser")), u
		}
	}, s = o ? new Promise((function (n, r) { i = function (e, t) { e ? r(e) : n(t) } })) : u
	; s._async_setup = function (n) { if (o) try { i(null, n(c)) } catch (n) { i(n) } }, n[t] = s; var a = r.createElement("script"); a.src = e, a.async = !0, a.id = "_uasdk",
		a.rel = t, r.head.appendChild(a)
}(window, document, 'https://aswpsdkus.com/notify/v1/ua-sdk.min.js',
	'UA', {

	// Only needed when used on insecure hosts:
	// secureIframeUrl: 'https://your.secure.domain/path/to/web-push-secure-bridge.html',
	workerUrl: '/ServiceWorker.js',
	vapidPublicKey: vapidpublickey,
	websitePushId: 'web.com.deloitte.myiqa',
	appKey: appkey,
	token: token
});

function registerNotifications() {
	UA.then(function(sdk) {
		sdk.register() 
	});
	UA.then(function(sdk) {
		sdk.getChannel().then(function(channel)  {
			if (channel.namedUser.id == null) channel.namedUser.set(uid)
		})
	});
}
function optoutNotifications() {
	UA.then(function(sdk) {
		sdk.getChannel().then(function(channel) {
			channel.optOut()
		})
	})
}
//Configurable Variables
var SOCIAL_LOGIN_SCREEN_SET = "MyDeloitte1B-RegistrationLogin";

// Global variables
var SOCIAL_IS_LOGGED = false;
var SOCIAL_PROFILE = null;
var SOCIAL_PROFILE_UID = null;

var isUserLoggingViaBM = false; // var that will identify if user is logging in via bookmark button

var USER_IS_LOGGED;
var isAlumniSelected = false;
var isReceiveEmails = false;
/* Interests JSON Object Mapped interests */
var existingInterests = [];
// var that identify if user is new one or existing while social log in
var IS_NEW_USER = false;
var redirect_to = null;
var diffDays = 0;
var IS_NO_CHECK = null;
/* Array that stores the tags added by the user */
var userAddedTags = [];
var existingAccountBookMarks = [];
var interestsSelected = [];
var tagsAdded = "";
var MCID_COOKIE_NAME = "AMCV_5742550D515CABFF0A490D44%40AdobeOrg";
var mcidValue = "";
var MCID_COOKIE_FIELD_NAME = "MCMID";
var COUNTRY = "us";
var LANGUAGE = "en";
var evalUserResponseObject;
var PAGE_URL = window.location.href;
var MY_PROFILE = null;
var requestorDomain = "";
var newDataAvailableFromDCom = false;
var isOptinReceiveEmails;
var optInResp;
var site = JSON.stringify(myDelLocale.replace(/\//g, "-"));
var siteVal = "site=" + myDelLocale.replace(/\//g, "_");
//variables for the Quick register and client dashboard
var accountGroupId;
var company;
var companyId;
var country;
var industry;
var jobTitle;
var jobFunction;
var jobLevel;
var locationOfResidence;
var qrBusinessEmail;

// response - below variable is responsible for resopnse
var response;

var pageTypeArray = [
  "registration",
  "unsubscribe",
  "misc",
  "undefined",
  "genericerror",
];

/*###########################################################
  Global Methods
    ---------------------
    @method urlParam
    @method strcmp
    @method validateEmail
    @method randomValue
    @method labelActive
    @method showSigninScreen
    @method showRegistrationScreen
    @method showGatedRegistrationScreen
    @method getRandomAPISuffix
    @method randomValue
    @method readCookie
    @method removeSpecialCharacters
    @method showRegSigninTab
    @method parseDate
    @method setAccountInfoResponsePR
    @method setSubPageInfoResponse
    @method sendSubscriptionsToGigya
    @method sendSubscriptionsToGigyaPR

//###########################################################*/

//#region functions

// putting global functions here
$.urlParam = function (name) {
  var results = new RegExp("[?&]" + name + "=([^&#]*)").exec(window.location.href);
  if (results == null) {
    return "";
  } else {
    return decodeURI(results[1]) || 0;
  }
};

//A utility function to compare two strings.
function strcmp(a, b) {
  if (a.toString() < b.toString()) return -1;
  if (a.toString() > b.toString()) return 1;
  return 0;
}

// function for email validation
function validateEmail(emailField) {
  var reg = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
  var box;
  if (reg.test(emailField.value) === false && emailField.value.length !== 0) {
    box = $(emailField).next();
    box.css({
      top: "-1em",
      "font-size": "1.4em",
      "font-weight": "bold",
    });
  }
  if (emailField.value.length === 0 && !$(emailField).hasClass("gigya-error")) {
    box = $(emailField).next();
    box.css({
      top: "0.5em",
      "font-size": "1.6em",
      "font-weight": "normal",
    });
  }
}

//function to get random values with a given range (0,min(range,65000))
function randomValue(range){
  var i;
  var RandomArray
  try{
    // for internet explorer
      RandomArray= Uint16Array(1);
      RandomArray=(window.msCrypto.getRandomValues(RandomArray));
  }
  catch(e){
    // for other browsers
      RandomArray= new Uint16Array(1);
      RandomArray=(window.crypto.getRandomValues(RandomArray));
  }

  i=(RandomArray[0] % (range+1));
  return i;

}



function labelActive(emailField) {
  if (emailField.value.length === 0) {
    var box = $(emailField).next();
    box.css({
      top: "-1em",
      "font-size": "1.4em",
      "font-weight": "bold",
    });
  }
}

function showSigninScreen() {
  var signInTab = "#signin";
  signInTab && $('ul.nav a[href="' + signInTab + '"]').tab("show");
  gigya.accounts.showScreenSet(signinParams);
  gigya.accounts.showScreenSet(regParams);
}

// A function to show registration screen set.
function showRegistrationScreen() {
  var regTab = "#registration";
  regTab && $('ul.nav a[href="' + regTab + '"]').tab("show");
  gigya.accounts.showScreenSet(regParams);
}

//A function to show gated registration screen set.
function showGatedRegistrationScreen() {
  gigya.accounts.showScreenSet(gatedRegParams);
}

function getRandomAPISuffix() {
  try {
    var rnd = randomValue(4) + 1;
    return rnd.toString();
  } catch (e) {
    return "";
  }
}


//A function to read a cookie.
function readCookie(name) {
  var nameEQ = name + "=";
  var ca = document.cookie.split(";");
  for (var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) === " ") c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0) {
      var cookieVal = c.substring(nameEQ.length, c.length);
      cookieVal = unescape(cookieVal);
      return cookieVal;
    }
  }
  return null;
}

function removeSpecialCharacters(str) {
  if (str !== null) {
    var convertedStr = encodeURI(str);
    return convertedStr;
  }
}

//handler for hash for register/signin from dcom or DI
function showRegSigninTab() {
  if (pagetype === "registration") {
    // show screensets
    var TAB;
    if (PAGE_URL.indexOf("state=signin") > -1) {
      TAB = "#signin";
      //show signin
      TAB && $('ul.nav a[href="' + TAB + '"]').tab("show");
      $("#registration-features, #privacy-statement-section").hide();
      $("#signin-features").show();
      gigya.accounts.showScreenSet(signinParams);
      gigya.accounts.hideScreenSet(regParams);
    } else if (PAGE_URL.indexOf("state=registration") > -1) {
      TAB = "#registration";
      //show registration
      TAB && $('ul.nav a[href="' + TAB + '"]').tab("show");
      gigya.accounts.hideScreenSet(signinParams);
      gigya.accounts.showScreenSet(regParams);
    }
  }
}

function parseDate(input) {
  // Transform date from text to date
  var parts = input.match(/(\d+)/g);
  // new Date(year, month [, date [, hours[, minutes[, seconds[, ms]]]]])
  return new Date(parts[0], parts[1] - 1, parts[2]); // months are 0-based
}

//VA move to global-vars.js
function getCurrentTimeUTC() {
  //RETURN  number of milliseconds between current UTC time and midnight of January 1, 1970
  //tmLoc = new Date();
  //The offset is in minutes -- convert it to ms
  //return tmLoc.getTime() + tmLoc.getTimezoneOffset() * 60000;
  var date = new Date().toISOString();
  date = '"' + date + '"';
  return date;
}

//VA move to global-vars.js
function formatDateTimeFromTicks(nTicks) {
  //'nTicks' = number of milliseconds since midnight of January 1, 1970
  //RETURN:   = Formatted date/time
  return new Date(nTicks).toLocaleString();
}

//VA: Move to Global vars.js
function randomAPI(invalidateEventArrayURL) {
  try {
    var URLS_ARRAY = invalidateEventArrayURL;
    return URLS_ARRAY[randomValue(URLS_ARRAY.length)];
  } catch (e) {
    return URLS_ARRAY[0];
  }
}

/* Returns the multi params from Query string */
//VA: Move to global vars.js
function getparamNameMultiValuesFromURL(paramName) {
  var sURL = window.document.URL.toString();
  sURL = decodeURI(sURL);
  var value = [];
  if (sURL.indexOf("?") > 0) {
    var arrParams = sURL.split("?");
    var arrURLParams = arrParams[1].split("&");
    for (var i = 0; i < arrURLParams.length; i++) {
      var sParam = arrURLParams[i].split("=");
      if (sParam && (sParam[0] === paramName) && (sParam.length > 0)) {
        
            value.push(sParam[1].trim());
        
      }
    }
  }
  return value.toString();
}

//VA: Move to global vars.js
function getParameterByName(name, url) {
  var regex,results;
  if (!url) url = window.location.href;
  name = name.replace(/[\[\]]/g, "\\$&");
  (regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)")),
    (results = regex.exec(url));
  if (!results) return null;
  if (!results[2]) return "";
  return decodeURIComponent(results[2].replace(/\+/g, " "));
}

//VA: Move to registration screen.js
function setCookiesIfDeloitteUserEmail(response) {
  try {
    if (typeof response.profile !== "undefined") {
      var useremail = response.profile.email;
      var deloittesubstring = "@deloitte";
      if (useremail.indexOf(deloittesubstring) !== -1) {
        document.cookie = "DeloitteID=true;domain=deloitte.com;path=/";
      }
    }
  } catch (err) {
   
  }
}

//VA: Move to registration screen.js
function resetResponseInSessionStorage(response) {
  try {
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(response));
  } catch (err) {
    
  }
}

//VA: Move to global vars.js or check usage
function setItemInLocalStorage(key, value) {
  try {
    localStorage.setItem(key, value);
  } catch (err) {
    
  }
}

//VA: Move to global vars.js or check usage
function setItemInSessionStorage(key, value) {
  try {
    sessionStorage.setItem(key, value);
  } catch (err) {
    
  }
}

//#endregion functions

//Fix for footerlinks.
if (pagetype === "registration" &&
    $.urlParam("site") !== "" &&
    $.urlParam("site") !== getCookie("myD_siteSelector")&&
    $.urlParam("site").indexOf("insights")===-1
  ) {
	/*Setting the myD_siteSelector cookie value to 1 year from the date of acceptence instead of 2099*/
	var expireDate = new Date();
	expireDate.setFullYear(expireDate.getFullYear() + 1); 
	var expires = "expires=" + expireDate.toUTCString();
    document.cookie =
      "myD_siteSelector=" +
      $.urlParam("site").replace("_", "-") +
      "; expires= " + expires; "path=/; secure";
    setSiteSelector($.urlParam("site").replace("_", "-"));
  
}

// Function to set account info in Gigya as callback
var setAccountInfoResponsePR = function (response) {
  if (typeof response.errorCode !== "undefined" && response.errorCode === 0) {
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(resObj));

    /**This if->condition will redirects the mydaas user from progressive profile to consumer app home page **/
    if (
      sessionStorage.getItem("isMyDaaSFlow") === "true" &&
      sessionStorage.getItem("emailupdates") === null &&
      ((mydaas_postback_url && typeof mydaas_postback_url !== "undefined") ||
        sessionStorage.getItem("mydaas_postback_url"))
    ) {
      post(mydaas_postback_url, resObj);
    } else if ($(".error-msg").length <= 0) {
      if (
        (localStorage.getItem("aoiKey") !== null ||
          localStorage.getItem("isNewUser") !== "true") &&
        localStorage.getItem("email-updates") !== "true"
      ) {
        var dashboard_page_URL = "./dashboard.html";
        $(location).attr("href", dashboard_page_URL);
      }
      localStorage.removeItem("aoiKey");
      localStorage.removeItem("isNewUser");
    }
  }
};

/* getting response from gigya account starts */
var setSubPageInfoResponse = function (response) {
  if (typeof response.errorCode !== "undefined" && response.errorCode === 0) {
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(resObj));
    localStorage.removeItem("isRedirectToSub");
    localStorage.removeItem("subKey");
    localStorage.removeItem("nocheck");
    /**This if->condition will redirects the mydaas user from progressive profile to consumer app home page **/
    if (
      sessionStorage.getItem("isMyDaaSFlow") === "true" &&
      sessionStorage.getItem("emailupdates") !== null &&
      ((mydaas_postback_url && typeof mydaas_postback_url !== "undefined") ||
        sessionStorage.getItem("mydaas_postback_url"))
    ) {
      post(mydaas_postback_url, resObj);
    } else {
      var dashboard_page_URL = "./dashboard.html";
      $(location).attr("href", dashboard_page_URL);
      //Calling this function to update the subscriptions count in Dashboard page
      subscriptionsCount(resObj);
    }
  }
};

var sitesJson;
/* code for Function will save the subscriptions in gigya console starts */
function sendSubscriptionsToGigya() {
  var subIds = [];
  var dunsnumber="999999999";
  var emailupdatessubjson='['; 
  var securedlocInfo = getCookie("myD_siteSelector");
  var source=null;
  
  if(securedlocInfo === "us-en") {
      source="D&B";

  }else
  {
    source="DB";
  }

  var emailupdatessub=sessionStorage.getItem("emailupdates");
  if(emailupdatessub!=null){
     var len=emailupdatessub.split(',');
     for(var i=0;i<len.length;i++){ 
         emailupdatessubjson=  emailupdatessubjson + '{"date":"'+new Date().toISOString()+'","id":"'+len[i]+'","selected":"true"},';
 }
       emailupdatessubjson= emailupdatessubjson+']';
 }
 else{emailupdatessubjson="[]";
     }

  $.each($("input[name='subscription-topics']:checked"), function() {
    if (subIds.indexOf($(this).val()) === -1) {
      subIds.push($(this).val().replace(/["']/g, ""));
    }
  });

  var str = JSON.stringify(subIds);
  var keyStr = str.split(",");
  var interestStr = [];
  if (resObj !== undefined && resObj.data.myDeloitte.sites !== undefined) {
    interestStr = getInterestsAndSubscriptions(resObj, 'interests');

  }
  var intStr = JSON.stringify(interestStr);
  var intKeyStr = intStr.split(",");

  if (resObj.data.myDeloitte.sites === undefined) {
    resObj.data.myDeloitte.sites = [];
  }
  if (str.length > 2) {
    sitesJson = '"myDeloitte.sites": ' + '[{"site": '+ site +', "interests" : ' + intKeyStr + ', "subscriptions" : ' + keyStr +',"consents" : '+ emailupdatessubjson +'}],"myDeloitte.consent.fullUnsubscribe": false';
    resObj.data.myDeloitte.sites = [{
      "site": JSON.parse(site),
      "interests": JSON.parse(intKeyStr),
      "subscriptions": JSON.parse(keyStr)
    }];
    if (resObj.data.myDeloitte.consent !== undefined) {
      
      resObj.data.myDeloitte.consent.fullUnsubscribe = false;
    }
  } else {
    sitesJson = '"myDeloitte.sites": ' + '[{"site": '+ site +', "interests" : ' + intKeyStr + ', "subscriptions" : ' + keyStr  +',"consents" : '+ emailupdatessubjson +'}]';
    resObj.data.myDeloitte.sites = [{
      "site": JSON.parse(site),
      "interests": JSON.parse(intKeyStr),
      "subscriptions": JSON.parse(keyStr)
    }];
  }
  if (typeof(resObj.data.myDeloitte.company) != 'undefined' && typeof(resObj.data.myDeloitte.jobTitle) != 'undefined' && typeof(resObj.data.myDeloitte.function) != 'undefined' && typeof(resObj.data.myDeloitte.country) != 'undefined' && typeof(resObj.data.myDeloitte.function) != 'undefined' && typeof(resObj.data.myDeloitte.country) != 'undefined' && typeof(resObj.data.myDeloitte.industry) != 'undefined') {
    sitesJson = sitesJson + ',"myDeloitte.jobTitle":"' + resObj.data.myDeloitte.jobTitle + '","myDeloitte.function":"' + resObj.data.myDeloitte.function+'","myDeloitte.country":"' + resObj.data.myDeloitte.country + '","myDeloitte.industry":"' + resObj.data.myDeloitte.industry + '"';
    if (localStorage.getItem("DUNSNUMBER") != null) {
      dunsnumber = localStorage.getItem("DUNSNUMBER");
      localStorage.removeItem("DUNSNUMBER");
    } else if (typeof(resObj.data.myDeloitte.companyId) != 'undefined' && resObj.data.myDeloitte.companyId != null && resObj.data.myDeloitte.company === $("#company-name").val()) {
      
        dunsnumber = resObj.data.myDeloitte.companyId;
      
    }

  }
  if ($("#company-name").val() === "") {
    dunsnumber = resObj.data.myDeloitte.companyId;
  } else {
    resObj.data.myDeloitte.company = $("#company-name").val();
  }

  sitesJson = sitesJson + ',"myDeloitte.company":"' + resObj.data.myDeloitte.company + '","myDeloitte.companyId":"' + dunsnumber + '","myDeloitte.companySource":"' + source + '"';

  var dataDetailsJSON = '{' + sitesJson + '}';
  if (null !== resObj.UID && API_KEY !== "") {
    var params = {
      data: dataDetailsJSON,
      apiKey: API_KEY,
      UID: resObj.UID,
      callback: setSubPageInfoResponse
    };

    gigya.accounts.setAccountInfo(params);

  } 

}
/* code for Function will save the subscriptions in gigya console ends */



/* code for Function will save the subscriptions in gigya console starts */
var sendSubscriptionsToGigyaPR = function() {
  var subIds = [];
  var dunsnumber = "999999999";
  var emailupdatessubjson = "[";

  
  var emailupdatessub = sessionStorage.getItem("emailupdates");
  if (emailupdatessub != null) {
    var len = emailupdatessub.split(",");
    for (var i = 0; i < len.length; i++) {
      emailupdatessubjson =
        emailupdatessubjson +
        '{"date":"' +
        new Date().toISOString() +
        '","id":"' +
        len[i] +
        '","selected":"true"},';
    }
    emailupdatessubjson = emailupdatessubjson + "]";
  } else {
    emailupdatessubjson = "[]";
  }

  $.each($("input[name='subscription-topics']:checked"), function() {
    if (subIds.indexOf($(this).val()) === -1) {
      subIds.push($(this).val().replace(/["']/g, ""));
    }
  });

  var str = JSON.stringify(subIds);
  var keyStr = str.split(",");
  var interestStr = [];
  if (resObj !== undefined && resObj.data.myDeloitte.sites !== undefined) {
    interestStr = getInterestsAndSubscriptions(resObj, "interests");
  }
  var intStr = JSON.stringify(interestStr);
  var intKeyStr = intStr.split(",");

  if (resObj.data.myDeloitte.sites === undefined) {
    resObj.data.myDeloitte.sites = [];
  }
  if (str.length > 2) {
    sitesJson =
      '"myDeloitte.sites": ' +
      '[{"site": ' +
      site +
      ', "interests" : ' +
      intKeyStr +
      ', "subscriptions" : ' +
      keyStr +
      ',"consents" : ' +
      emailupdatessubjson +
      ' }],"myDeloitte.consent.fullUnsubscribe": false';
    resObj.data.myDeloitte.sites = [{
      site: JSON.parse(site),
      interests: JSON.parse(intKeyStr),
      subscriptions: JSON.parse(keyStr),
    }, ];
    if (resObj.data.myDeloitte.consent !== undefined) {
      resObj.data.myDeloitte.consent.fullUnsubscribe = false;
    }
  } else {
    sitesJson =
      '"myDeloitte.sites": ' +
      '[{"site": ' +
      site +
      ', "interests" : ' +
      intKeyStr +
      ', "subscriptions" : ' +
      keyStr +
      ',"consents" : ' +
      emailupdatessubjson +
      " }]";
    resObj.data.myDeloitte.sites = [{
      site: JSON.parse(site),
      interests: JSON.parse(intKeyStr),
      subscriptions: JSON.parse(keyStr),
    }, ];
  }
  if (
    typeof resObj.data.myDeloitte.company != "undefined" &&
    typeof resObj.data.myDeloitte.jobTitle != "undefined" &&
    typeof resObj.data.myDeloitte.function != "undefined" &&
    typeof resObj.data.myDeloitte.country != "undefined" &&
    typeof resObj.data.myDeloitte.function != "undefined" &&
    typeof resObj.data.myDeloitte.country != "undefined" &&
    typeof resObj.data.myDeloitte.industry != "undefined" &&
    typeof resObj.data.myDeloitte.zip != "undefined"
  ) {
    sitesJson =
      sitesJson +
      ',"myDeloitte.jobTitle":"' +
      resObj.data.myDeloitte.jobTitle +
      '","myDeloitte.function":"' +
      resObj.data.myDeloitte.function+
      '","myDeloitte.country":"' +
      resObj.data.myDeloitte.country +
      '","myDeloitte.industry":"' +
      resObj.data.myDeloitte.industry +
      '","myDeloitte.zip":"' +
      resObj.data.myDeloitte.zip +
      '"';
    if (localStorage.getItem("DUNSNUMBER") != null) {
      dunsnumber = localStorage.getItem("DUNSNUMBER");
      localStorage.removeItem("DUNSNUMBER");
    } else if (
      typeof resObj.data.myDeloitte.companyId != "undefined" &&
      resObj.data.myDeloitte.companyId != null &&
      resObj.data.myDeloitte.company === $("#company-name").val()){
        dunsnumber = resObj.data.myDeloitte.companyId;
      
    }
  }
  if ($(" -profile-professional-info#company-name").val() === "") {
    dunsnumber = resObj.data.myDeloitte.companyId;
  } else {
    resObj.data.myDeloitte.company = $(
      "#new-profile-professional-info #company-name"
    ).val();
  }

  sitesJson =
    sitesJson +
    ',"myDeloitte.company":"' +
    resObj.data.myDeloitte.company +
    '","myDeloitte.companyId":"' +
    dunsnumber +
    '"';

  var dataDetailsJSON = "{" + sitesJson + "}";
  if (null !== resObj.UID) {
    var params = {
      data: dataDetailsJSON,
      apiKey: API_KEY,
      UID: resObj.UID,
      callback: setSubPageInfoResponse,
    };

    gigya.accounts.setAccountInfo(params);
  } 
}


/* code for Function will save the subscriptions in gigya console ends */


// function to hide and show profile email updates frequency section (profileFreq)

function toggleProfileFrequencyDisplay(){
  // show frequency section if email yes selected
  if($('#profile-email-updates input#emails-yes').is(':checked')){
    $(".profileFreq").removeClass('d-none');
  }
  // toggle display on change
  $('#profile-email-updates input[name="receiveEmails"]').click(function () {
    if(this.id === "emails-yes"){
      $(".profileFreq").removeClass('d-none');
    }
    else if(this.id === "emails-no"){
      $(".profileFreq").addClass('d-none');
      $("[name='myDeloitte.consent.profileFreq']").attr('checked', false); // reset radios
    }
  });
}

function validateProfileFrequency(){
  $('input[name="myDeloitte.consent.profileFreq"]').change( function() {
    if($(this).is(":checked")){
      $(".profileFreq__warning").addClass("d-none").removeClass("error-msg");
    }
  });

  // called from any of the submit buttons either on progressive, profile or gated
  if($("#emails-yes, #gated-emails-yes").is(":checked")){
    if($('input[name="myDeloitte.consent.profileFreq"]').is(':checked')){
      $(".profileFreq__warning").addClass('d-none').removeClass('error-msg');
    }
    else{
      $(".profileFreq__warning").removeClass('d-none').addClass('error-msg');
    }
  } else {
    $(".profileFreq__warning").addClass('d-none').removeClass('error-msg');
  }
}
// gigya key map for errors
var errorKeyMapParams = {
    email_already_exists: email_already_exists +"<a href='#' data-toggle='modal' data-target='#modal-forgot-password' data-backdrop='static' class='gigya-composite-control gigya-composite-control-link myD-forgot-password-link' onclick='gigya.accounts.showScreenSet(fpParams)' data-screenset-element-id-publish='false' data-screenset-roles='template,template,instance'>"+email_already_pwd+"</a>.",
    email_address_is_invalid:email_address_is_invalid,
    password_does_not_meet_complexity_requirements: password_does_not_meet_complexity_requirements,
    passwords_do_not_match: passwords_do_not_match,
    invalid_login_or_password: invalid_login_or_password,
    there_is_no_user_with_that_username_or_email: there_is_no_user_with_that_username_or_email,
    this_field_is_required:this_field_is_required,
    please_choose_a_region_of_residence: please_choose_a_region_of_residence
}

// change password custom lang params
var cpErrorKeyMapParams = {
    this_field_is_required:this_field_is_required1,
    invalid_login_or_password:invalid_login_or_password1,
    passwords_do_not_match:passwords_do_not_match1,
    password_does_not_meet_complexity_requirements: password_does_not_meet_complexity_requirements1
}

// registration parameters
var regParams = {
    screenSet: "MyDeloitte1B-RegistrationLogin",
    startScreen: "gigya-register-screen",
    containerID: "myD-reg-screenset-container",
    onSubmit: handleRegistrationSubmit,
    onAfterScreenLoad: registrationFlow,
    customButtons: [
                        {   "type": "saml",
                            "providerName":"Deloitte",
                            "idpName":"deloitte",
                            "position":"99"
                        }],
    // onError: errorHandlerForRegister,
    onAfterSubmit: aftersubmitcallback,
    onBeforeSubmit: validateDeloitteEmail,
    customLang: errorKeyMapParams

}

// sigin parameters
var signinParams = {
    screenSet: "MyDeloitte1B-RegistrationLogin",
    startScreen: "gigya-login-screen",
    containerID: "myD-login-screenset-container",
    onSubmit: handleLoginSubmit,
    onAfterScreenLoad: signinFlow,
    customButtons: [
                        {   "type": "saml",
                            "providerName":"Deloitte",
                            "idpName":"deloitte",
                            "position":"99"
                        }],
    customLang: errorKeyMapParams,
    onError: errorHandlerForSignIn
}

// forgot password parameters 
var fpParams = {
    screenSet: 'MyDeloitte1B-RegistrationLogin',
    startScreen: 'gigya-forgot-password-screen',
    containerID: 'gigya-forgot-password-screen-container',
    onBeforeSubmit: validateuser,
    onFieldChanged: validateEmailForForgotUser,
    onAfterSubmit: showForgotPasswordSucessScreen,
    customLang: errorKeyMapParams
}

//change password params - account settings page 
var cpParams = {
    screenSet: 'MyDeloitte1B-ProfileUpdate',
    startScreen: 'gigya-change-password-screen',
    containerID: 'change-password-gigya-screen',
    onAfterSubmit: onUpdate,
    customLang: cpErrorKeyMapParams
}
// function for gigya registration screen flow
var globalSelectListJson = JSON.parse(
  sessionStorage.getItem("globalSelectListJson")
);
function registrationFlow(response) {
  if (response.currentScreen !== "gigya-register-screen") {
    $("#registration-features").hide();
  }
  if (
    response.currentScreen === "gigya-register-screen" &&
    PAGE_URL.indexOf("action=") > -1 &&
    PAGE_URL.indexOf("p=") > -1
  ) {
    var urlAction = $.urlParam("action");
    var urlEncryptedJson = $.urlParam("p");
    if (urlAction !== "" && urlAction === "qr" && urlEncryptedJson !== "") {
      // logic to decode and  prepopulate user related info
      var urlDecryptedJson = atobUTF16(urlEncryptedJson);
      urlDecryptedJson = JSON.parse(urlDecryptedJson);
      $("#gigya-register-form input[type='email']").val(urlDecryptedJson.e);
      $("#gigya-register-form input[name='profile.firstName']").val(
        urlDecryptedJson.f
      );
      $("#gigya-register-form input[name='profile.lastName']").val(
        urlDecryptedJson.l
      );
       accountGroupId = urlDecryptedJson.g;
      // values prepopulated in profile page
       company = urlDecryptedJson.cn;
       companyId = urlDecryptedJson.ci;
       country = urlDecryptedJson.c;
       jobTitle = urlDecryptedJson.jt;
       industryKey = urlDecryptedJson.i;
       qrBusinessEmail = urlDecryptedJson.e;
      if (industryKey != null && industryKey != "undefined") {
        loadIndustryForQuickRegisterProfile(industryKey);
      }
      var jobLevelKey = urlDecryptedJson.jl;
      if (jobLevelKey != null && jobLevelKey !== "undefined") {
        loadJobLevelForQuickRegisterProfile(jobLevelKey);
      }
      var jobFunctionKey = urlDecryptedJson.jf;
      if (jobFunctionKey != null && jobFunctionKey !== "undefined") {
        loadJobFunctionForQuickRegisterProfile(jobFunctionKey);
      }
      var CountryKey = urlDecryptedJson.lr;
      if (CountryKey != null && CountryKey !== "undefined") {
        loadCountryForQuickRegisterProfile(CountryKey);
      }
      if (locationOfResidence !== "undefined" && locationOfResidence != null) {
        document.getElementById("country-config").value = locationOfResidence;
      } else {
        if (country !== "undefined" && country != null) {
          var CountryLocale = country.split("-");
          var CountryCode = CountryLocale[0].toUpperCase();
          if (CountryCode != null && CountryCode !== "GLOBAL") {
            document.getElementById("country-config").value = CountryCode;
          } else {
            document.getElementById("country-config").value = "ZZ";
          }
        }
      }
    } 
  }
  // gigya-verification-sent-screen
  if (response.currentScreen === "gigya-verification-sent-screen" &&
      $("#myD-reg-screenset-container_content div[id='gigya-verification-sent-screen']").length
    ) {
      $(".myD-reg-signin-wrapper").addClass(
        "verfication-sent-screen light-theme"
      );
      $(".form-screen").addClass("reg-flow-active");
      $(".reg-flow-active .col-md-7").addClass("col-md-8");
      $(".verfication-sent-screen").css(
        "background-image",
        "url(" + verification_screen_bg_image + ")"
      );
    
  }

  // gigya-complete-registration-screen
  if (response.currentScreen === "gigya-complete-registration-screen" &&
    (  $("#myD-reg-screenset-container_content div[id='gigya-complete-registration-screen']").length ||
      $("#myD-login-screenset-container_content div[id='gigya-complete-registration-screen']").length )
    ) {
      $(".myD-reg-signin-wrapper").addClass("complete-reg-screen light-theme");
      $(".form-screen").addClass("reg-flow-active");
      $(".reg-flow-active .col-md-7").addClass("col-md-8");
      $(".complete-reg-screen").css(
        "background-image",
        "url(" + verification_screen_bg_image + ")"
      );
    
  }

  // gigya link account screen
  if (response.currentScreen === "gigya-link-account-screen" && (
      $("#myD-reg-screenset-container_child_content div[id='gigya-link-account-screen']").length ||
      $("#myD-login-screenset-container_child_content div[id='gigya-link-account-screen']").length
    ) ){
      $(".myD-reg-signin-wrapper").addClass("link-account-screen light-theme");
      $(".form-screen").addClass("reg-flow-active");
      $(".reg-flow-active .col-md-7").addClass("col-md-8");
      $(".link-account-screen").css(
        "background-image",
        "url(" + verification_screen_bg_image + ")"
      );
    
  }

  // gigya-verification-pending-screen
  if (response.currentScreen === "gigya-verification-pending-screen" &&
      $("#myD-login-screenset-container_content div[id='gigya-verification-pending-screen']").length
    ) {
      $(".myD-reg-signin-wrapper").addClass(
        "verfication-pending-screen light-theme"
      );
      $(".form-screen").addClass("reg-flow-active");
      $(".reg-flow-active .col-md-7").addClass("col-md-8");
      $(".verfication-pending-screen").css(
        "background-image",
        "url(" + verification_screen_bg_image + ")"
      );
    
  }
  //scroll window to top
  $(window).scrollTop(0);
}

function signinFlow(response) {
  // gigya-verification-pending-screen
  if (response.currentScreen === "gigya-verification-pending-screen" &&
      $(
        "#myD-login-screenset-container_content div[id='gigya-verification-pending-screen']"
      ).length
    ) {
      $(".myD-reg-signin-wrapper").addClass(
        "verfication-pending-screen light-theme"
      );
      $(".form-screen").addClass("reg-flow-active");
      $(".reg-flow-active .col-md-7").addClass("col-md-8");
      $(".verfication-pending-screen").css(
        "background-image",
        "url(" + verification_screen_bg_image + ")"
      );
    
  }

  // gigya link account screen
  if (response.currentScreen === "gigya-link-account-screen" &&
    (
      $(
        "#myD-reg-screenset-container_child_content div[id='gigya-link-account-screen']"
      ).length ||
      $(
        "#myD-login-screenset-container_child_content div[id='gigya-link-account-screen']"
      ).length
    )) {
      $(".myD-reg-signin-wrapper").addClass("link-account-screen light-theme");
      $(".form-screen").addClass("reg-flow-active");
      $(".reg-flow-active .col-md-7").addClass("col-md-8");
      $(".link-account-screen").css(
        "background-image",
        "url(" + verification_screen_bg_image + ")"
      );

      //only if it is legacy deloitte user
      var userEmail = response.profile.email;
      if (userEmail.indexOf("@deloitte.com") > -1) {
        $("#gigya-link-account-screen a.gigya-forgotPassword").attr(
          "data-toggle",
          null
        );
        $("#gigya-link-account-screen a.gigya-forgotPassword").on(
          "click",
          function () {
            triggerResetPassword(userEmail);
          }
        );
      }
    
  }

  // gigya-complete-registration-screen
  if (response.currentScreen === "gigya-complete-registration-screen" &&
  (
      $(
        "#myD-reg-screenset-container_content div[id='gigya-complete-registration-screen']"
      ).length ||
      $(
        "#myD-login-screenset-container_content div[id='gigya-complete-registration-screen']"
      ).length
  )) {
      $(".myD-reg-signin-wrapper").addClass("complete-reg-screen light-theme");
      $(".form-screen").addClass("reg-flow-active");
      $(".reg-flow-active .col-md-7").addClass("col-md-8");
      $(".complete-reg-screen").css(
        "background-image",
        "url(" + verification_screen_bg_image + ")"
      );
    
  }
  //scroll window to top
  $(window).scrollTop(0);
}

// show
function triggerResetPassword(userEmail) {
  // show fp screen
  gigya.accounts.resetPassword({
    loginID: userEmail,
    callback: function (response) {
      if (response.errorCode === 0) {
        $("#modal-forgot-password-success").modal("show");
      }
    },
  });
}

//function to check reset password expiry state
function isResetPasswordLinkExpired(response) {
  if (
    response.errorDetails.indexOf("pwrt") > -1 ||
    response.errorCode === 403025
  ) {
    showResetPasswordExpiredScreen();
  } else {
    showResetPasswordScreen();
  }
}

// Reset password screen
function showResetPasswordScreen() {
  gigya.accounts.showScreenSet({
    screenSet: "MyDeloitte1B-RegistrationLogin",
    startScreen: "gigya-reset-password-screen",
    containerID: "myD-reg-screenset-container",
    customLang: errorKeyMapParams,
  });
  $(".myD-reg-signin-wrapper").addClass("reset-password-screen light-theme");
  $(".reset-password-screen").css(
    "background-image",
    "url(" + reset_password_screen_bg_image + ")"
  );
  $(".form-screen").addClass("reg-flow-active");
  $(".reg-flow-active .col-md-7").addClass("col-md-8");

  //Set button href to MyDaas URL if MyDaas and Forgot Password flow is true
  if (localStorage.getItem("mydaasforgotpassword") === "true") {
    setButtonUrlIfFPandMydaas();
  }
}

// Reset password expire screen
function showResetPasswordExpiredScreen() {
  gigya.accounts.showScreenSet({
    screenSet: "MyDeloitte1B-RegistrationLogin",
    startScreen: "gigya-password-link-expired-screen",
    containerID: "myD-reg-screenset-container",
  });
  $(".myD-reg-signin-wrapper").addClass(
    "password-link-expired-screen light-theme"
  );
  $(".form-screen").addClass("reg-flow-active");
  $(".reg-flow-active .col-md-7").addClass("col-md-8");
}

// Verify link expired screen
function showVerifyLinkExpired() {
  gigya.accounts.showScreenSet({
    screenSet: "MyDeloitte1B-RegistrationLogin",
    startScreen: "gigya-email-link-expired-screen",
    containerID: "myD-reg-screenset-container",
  });
  $(".myD-reg-signin-wrapper").addClass(
    "email-link-expired-screen light-theme"
  );
  $(".form-screen").addClass("reg-flow-active");
  $(".reg-flow-active .col-md-7").addClass("col-md-8");
}

// forgot password response handler
function showForgotPasswordSucessScreen(data) {
  $("#fwd-validataion-msg").hide();
  $("#modal-forgot-password").modal("hide");
  $("#modal-forgot-password-success").modal("show");
  if (data.response.errorCode === 0) {
    //Set Local Storage if MyDaas and Forgot Password Flow is true
    if (sessionStorage.getItem("mydaasflow") === "true") {
      setLocalStorageIfFPandMydaas();
    }

    if (pagetype === "accountsettings") {
      $("#modal-forgot-password-success").on("hidden.bs.modal", function () {
        logOut();
      });
    }
  }
}

// function for forgot password flow [@global]
function forgotPwdFlow() {
  var isForgotPwd = $.urlParam("showForgotPassword");
  if (isForgotPwd === "true" && isForgotPwd !== "" && isForgotPwd != 0) {
    showForgotPwdScreen();
  }
}

// show forgot password custom screen
function showForgotPwdScreen() {
  // show signin
  $("#myD-reg-signin-nav-tabs a.myD-signin-tab").tab("show");
  gigya.accounts.showScreenSet(signinParams);

  // show fp screen
  $("#modal-forgot-password").modal("show");
  gigya.accounts.showScreenSet(fpParams);
}

function updateURL(state) {
  var currentURL = window.location.href;
  if (state === "signin") {
    currentURL = currentURL.replace("state=registration", "state=signin");
  } else if (state === "registration") {
    currentURL = currentURL.replace("state=signin", "state=registration");
  }

  // update URL history
  if (history.pushState) {
    window.history.pushState("", "", currentURL);
  } else {
    window.location.href = currentURL;
  }
}

/* function for switch the screen */
function customSwitchScreen(name) {
  if (name === "gigya-login-screen") {
    updateURL("signin");
    gigya.accounts.showScreenSet(signinParams);
  } else {
    if (window.location.href.indexOf("#signin") > -1) {
      gigya.accounts.showScreenSet(regParams);
    } else {
      updateURL("registration");
      gigya.accounts.switchScreen({
        screenSet: "MyDeloitte1B-RegistrationLogin",
        screen: name,
        containerID: "myD-reg-screenset-container",
      });
    }
  }
}

function errorHandlerForSignIn() {
  
  _satellite.track("loginError");
}

function onloginerrorcallback() {
  _satellite.track("loginError");
}

function onregerrorcallback() {
  _satellite.track("registrationError");
}

function aftersubmitcallback() {
  _satellite.track("registrationSuccess");
}
/* Loading dropdown values for industry field for Quick registered user profile page*/
function loadIndustryForQuickRegisterProfile(industryKey) {
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  
  var industryJson =
    globalSelectListJson["myd-generic-list"]["industry-config-for-profile"];
  var industryVal='';
  if (industryJson) {
    for (var i = 0; i < industryJson.length; i++) {
      if (industryKey === industryJson[i]["value"]) {
        industryVal = industryJson[i]["value"];
        break;
      }
    }
    if (industryVal == null) {
      industryVal = "Other";
    }
  }
  industry = industryVal;
}
/* Loads dropdown values for current job level field in profile page starts*/
function loadJobLevelForQuickRegisterProfile(jobLevelKey) {
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  
  var currentJobLevelJson =
    globalSelectListJson["myd-generic-list"]["current-level-config"];
  var jobLevelVal='';
  if (currentJobLevelJson) {
    for (var i = 0; i < currentJobLevelJson.length; i++) {
      if (jobLevelKey === currentJobLevelJson[i]["value"]) {
        jobLevelVal = currentJobLevelJson[i]["value"];
        break;
      }
    }
    if (jobLevelVal == null) {
      jobLevelVal = "Other";
    }
  }

   jobLevel = jobLevelVal;
}

/* Loading dropdown values for job function field in profile page starts */
function loadJobFunctionForQuickRegisterProfile(jobFunctionKey) {
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  
  var jobFunctionJson =
    globalSelectListJson["myd-generic-list"]["job-function-in-profile-page"];
  var jobFuntionVal='';
  if (jobFunctionJson) {
    for (var i = 0; i < jobFunctionJson.length; i++) {
      if (jobFunctionKey === jobFunctionJson[i]["value"]) {
        jobFuntionVal = jobFunctionJson[i]["value"];
        break;
      }
    }
    if (jobFuntionVal == null) {
      jobFuntionVal = "Other";
    }
  }
   jobFunction = jobFuntionVal;
}

// loads the mf names for profile page fields Country & Memberfirm dropdown options.
function loadCountryForQuickRegisterProfile(CountryKey) {
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  var countryJson =
    globalSelectListJson["myd-generic-list"][
      "country-config-for-personal-info-section"
    ];
  var countryVal;
  if (countryJson) {
    for (var i = 0; i < countryJson.length; i++) {
      if (CountryKey === countryJson[i]["text"]) {
        countryVal = countryJson[i]["value"];
        break;
      }
    }
    if (countryVal == null) {
      countryVal = "ZZ";
    }
  }
   locationOfResidence = countryVal;
}

/* function starts for validating inouts for quick registration */
function validateDeloitteEmail(response) {
  if (!ValidateInput()) {
    return false;
  }
  /* function ends for validating inouts for quick registration */
  if (
    $("#country-config").val() === "" &&
    !$("#country-check").is(":checked")
  ) {
    $(".error-mandatory-msg").show();
    $(".country-dropdown .bar").css("border-bottom", "1.5px solid #DA291C");
    return false;
  }
  if (
    response.formData.email.indexOf("@deloitte") > -1 &&
    response.formData.loginID.indexOf("@deloitteretired") === -1
  ) {
    var deloitte = $(
      "#myD-reg-screenset-container_content button[title='Deloitte']"
    );
    $("#logindiv, #logindivjoin, #passworddiv").val("");
    deloitte.click();
    return false;
  }
}
//decrypts the profile details JSON during quick registration
function atobUTF16(sBase64) {
  var sBinaryString = atob(sBase64),
    aBinaryView = new Uint8Array(sBinaryString.length);
  Array.prototype.forEach.call(aBinaryView, function (el, idx, arr) {
    arr[idx] = sBinaryString.charCodeAt(idx);
  });
  return String.fromCharCode.apply(null, new Uint16Array(aBinaryView.buffer));
}

//Saving MCID data info in gigya
//VA move to gigya flow.js
function sendMCIDToGigya(mcidParam) {
  var dataDetailsJSON = {
    "myDeloitte.level": mcidParam,
  };

  var params = {
    data: dataDetailsJSON,
    apiKey: SOCIAL_API,
    UID: SOCIAL_PROFILE_UID,
    callback: setMCIDToGigyaResponse,
  };
  gigya.accounts.setAccountInfo(params);
}

//VA move to gigya flow.js
function setMCIDToGigyaResponse() {

}

// Set timeout variables.
var user_status = localStorage.getItem("loggedIn");
var timoutWarning = 1800000; // Display warning in 30 Mins.

var warningTimer;
var timeoutTimer;
var keepMeLoginStatus = readCookie("KEEP_ME_LOGIN"); // 582206-Keep me logged implementation: changed localstorage to cookies
if (keepMeLoginStatus === "false" && wcmMode === "DISABLED" && !$(".email-unsubscribe").length && !$(".myD-gatedFlow-container").length && pagetype !== "registration" && user_status !== null) {
    var StartTimers = function() {
        warningTimer = setTimeout("IdleWarning()", timoutWarning);
    }

    // Start timers.
    StartTimers();

    var ResetTimers = function() {
        clearTimeout(warningTimer);
        clearTimeout(timeoutTimer);
        StartTimers();
    }

    // Reset timers on mousemove.
    $(document).mousemove(function(){ResetTimers()});
}

// Show idle timeout warning dialog.
function IdleWarning() {
    sessionLogout();
    $('#sessionOutModal').modal({
        show: true,
        backdrop: 'static'
    });
}
$(".sessionout__login").on('click', function () {
    $("#modal-unsaved-profile,#modal-unsaved-subscription").remove();
    window.location.href = "./registration.html#signin";
})
/** Generic Form post function for my-daas starts from here * */
function post(mydaas_postback_url, resObj) {
	 if(!mydaas_postback_url){
 		 mydaas_postback_url = sessionStorage.getItem("mydaas_postback_url")
 	 }
	  var params = 
			 {
				uid: resObj.UID,
				timestamp: resObj.signatureTimestamp,
				signature: resObj.UIDSignature,
				bookmark: sessionStorage.getItem("bookmark")
			 };    	   
	var form = document.createElement('form');
	form.method = 'post';
	form.action = mydaas_postback_url;
	for ( var key in params) {
		if (params.hasOwnProperty(key)) {
			var hiddenField = document.createElement('input');
			hiddenField.type = 'hidden';
			hiddenField.name = key;
			hiddenField.value = params[key];
			form.appendChild(hiddenField);
		}
	}
	document.body.appendChild(form);
	form.submit();
}
/** Generic Form post function for my-daas ends here * */

/** Function to check if incoming appid has already TOU accepted starts from here * */
function checkIfTouExistsForApp(loginEvent) {

	var selectedappid = sessionStorage.getItem("appid");
	// MYDAAS: set flagforappid to true if TOU is accepted previously by user
	var flagforappid = false;

	if (loginEvent.data.mydaas !== undefined) {
		for (var i = 0; i < loginEvent.data.mydaas.tou.length; i++) {
			if (loginEvent.data.mydaas.tou[i].app === selectedappid) {
				flagforappid = true;
			}
		}
	}
	return flagforappid;
}
/** Function to check if incoming appid has already TOU accepted ends here * */

/** Function in to do form-post if TOU is already accepted for incoming appid * */
function doFormPostForExistingMydaasUser(loginEvent) {

	var uid = loginEvent.UID;
	var signature = loginEvent.UIDSignature;
	var timestamp = loginEvent.signatureTimestamp;
	var bookmark = '';

	if (sessionStorage.getItem("bookmark") !== null
			|| sessionStorage.getItem("bookmark") !== "null") {
		bookmark = sessionStorage.getItem("bookmark");
	}

	var postData = {
			UID : uid,
			signatureTimestamp : timestamp,
			UIDSignature : signature,
			bookmark : bookmark
	};
	post(sessionStorage.getItem("mydaas_postback_url"), postData);
}
/** Function in to do form-post if TOU is already accepted for incoming appid * */


/** Set TOU in gated login function starts **/
function setTOUonGatedLoginSubmit(resObj) {
	var appID = sessionStorage.getItem("appid");
	var deselectedFlag = false;
	var mydaas = {
		tou : []
	};

	if (resObj.data.mydaas !== undefined) {
		var existingMydaasApps = resObj.data.mydaas.tou;
		for (var i = 0; i < existingMydaasApps.length; i++) {
			var obj = existingMydaasApps[i];
			if (appID === obj.app) {
				deselectedFlag = true;
			} else {
				mydaas.tou.push({
					"app" : obj.app,
					"date" : obj.date
				});
			}
		}

	}
	// MYDAAS: add current appid fields to existing array
	if (deselectedFlag !== true) {
		mydaas.tou.push({
			"app" : appID,
			"date" : new Date().toISOString()
		});
	}
	return mydaas.tou;
}
/** Set TOU in gated login function starts **/

/**Start: Set Local Storage if MyDaas and Forgot Password Flow is true **/
function setLocalStorageIfFPandMydaas() {
	localStorage.setItem("mydaasforgotpassword","true");
	localStorage.setItem("mydaasfpappid",sessionStorage.getItem("appid"));
	localStorage.setItem("mydaasfppostback",sessionStorage.getItem("mydaas_postback_url"));
	localStorage.setItem("mydaasfpbookmark",sessionStorage.getItem("bookmark"));
	localStorage.setItem("mydaasfplocale",mydaas_locale);
	localStorage.setItem("mydaasfpsiteval",getParameterByName('site'));  
}
/**End: Set Local Storage if MyDaas and Forgot Password Flow is true **/


/**Start: Set Button URL if FP and MyDaas flow is true **/
function setButtonUrlIfFPandMydaas(){
	var url = "/registration.mydaas."+localStorage.getItem("mydaasfpappid")+"."+localStorage.getItem("mydaasfplocale")+".html?site="+localStorage.getItem("mydaasfpsiteval")+"&state=signin&bm="+localStorage.getItem("mydaasfpbookmark");
	localStorage.removeItem("mydaasforgotpassword");
	$(".back-to-signin__button").attr("href", url);
}
/**End: Set Button URL if FP and MyDaas flow is true **/

$(document).ready(function () {
 
  // VA: This can go to Dbriefs specific file
  if (PAGE_URL.indexOf("eventid") > 0) {
    var eventId = getparamNameMultiValuesFromURL("eventid");
    if (eventId !== null && eventId !== "") {
      setItemInSessionStorage("DBriefFlow", "true");
      setItemInSessionStorage("eventId", eventId);
      localStorage.removeItem("aoiKey");
      localStorage.removeItem("subKey");
    }
  }

  //check if mydaasflow and set items in sessionstorage
  // VA: Can be moved to MyDaaS specific file
  if (mydaas_action !== "") {
    if (mydaasApp_ID !== "" && is_valid_app_id !== "false") {
      sessionStorage.setItem("action", "mydaas");
      sessionStorage.setItem("appid", mydaasApp_ID);
      sessionStorage.setItem("mydaaslocale", mydaas_locale);
      sessionStorage.setItem("mydaasflow", "true");
      sessionStorage.setItem("mydaas_postback_url", mydaas_postback_url);
      if (
        getParameterByName("bm") !== "" &&
        sessionStorage.getItem("bookmark") == null
      ) {
        sessionStorage.setItem("bookmark", getParameterByName("bm"));
      }
    }
  }

  if (PAGE_URL.indexOf("site") > 0) {
    var lSource = getParameterByName("site");
    if (lSource === "insights-us-en_en") {
      localStorage.setItem("lSource", lSource);
    }
  }
  var hashes = PAGE_URL.split("?")[1];
  if (typeof hashes != "undefined" && hashes.indexOf("&") === -1) {
  
      localStorage.setItem("lSource", hashes);
  
  }

  $("#profile-header-nav").hide();
  if ($.urlParam("action") === "unsubscribe") {
    var pathname = window.location.pathname;
    if (pathname.indexOf("unsubscription.html") === -1) {
      $(location).attr("pathname", "./unsubscription.html");
    }
  }

  // Main call to Load the Gigya
  loadGigya();
  customShave(".dot-ellipsis", 70);

  if (
    localStorage.getItem("loggedIn") !== "true" ||
    localStorage.getItem("loggedIn") === null ||
    localStorage.getItem("loggedIn") === "undefined"
  ) {
    var logoLink = logoLinkNotLoggedIn;
    $("a.header__logo").attr("href", logoLink);
  }

  // XSS prevention
  $("input,textarea").on("keydown focusout", function () {
    $(this).val(encodeHTML($(this).val()));
  });

  function encodeHTML(s) {
    return s
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\//, "&#x2F;");
  }
});

// log out function.
//VA move to main.js if not redundant
var logOut = function () {
  setTimeout(function () {
    if (aModalIsPresent === false) {
      gigya.accounts.logout({
        callback: logOutResponse,
      });
    }
  }, 1000);
};

// Loads after page is loaded
$(window).bind("load", function () {
  // executes when complete page is fully loaded, including all frames, objects and images
  var loggedout = readCookie("USER_LOG_OUT_DCOM");

  if (loggedout === "true") {
    document.cookie = "USER_LOG_OUT_DCOM=false;domain=.deloitte.com;path=/";
    logOut();
  }

  if (pagetype === "registration") {
    var deloitteID = readCookie("DeloitteID");
    var userLoggedIn = localStorage.getItem("loggedIn");
    if (userLoggedIn) {
      if (PAGE_URL && PAGE_URL.indexOf("action=optin") > -1) {
        updateLocalStorageWithAoisAndSubscriptions();
      }
      evalUserResponse();
    } else if (deloitteID === "true") {
      var deloitte = $(
        "#myD-login-screenset-container_content button[title='Deloitte']"
      );
      deloitte.click();
    }

    // forgot password redirect from gigya
    forgotPwdFlow();

    // gigya verify link expired
    if (window.location.search.indexOf("errorCode=403002") > -1) {
      $("#registration-features").hide();
      showVerifyLinkExpired();
    }
    //scroll window to top
    $(window).scrollTop(0);
  }
});

//VA: This can be moved to registration-screen.js
function handleLoginSubmit(response) {
  if (response.screen === "gigya-complete-registration-screen") {
    response.formModel.data.myDeloitte.tou.date = new Date().toISOString();

    //578068 : code update for mydaas bug for closed account
    if (mydaasApp_ID !== "") {
      var mydaas = { tou: [] };
      mydaas.tou.push({ app: mydaasApp_ID, date: new Date().toISOString() });
      sessionStorage.setItem("closedaccmydaasuser", "true");
      response.formModel.data.mydaas = mydaas;
    }
  }
  if (response.screen === "gigya-login-screen") {
    // 582206-Keep me logged implementation
    var expireDate = new Date();
    expireDate.setFullYear(expireDate.getFullYear() + 1); // 582206-Keep me logged implementation: setting validity for one year
    var expires = "expires=" + expireDate.toUTCString();

    if(OptanonActiveGroups != undefined && OptanonActiveGroups.indexOf(3) > -1){    // if functional cookies are accepted

    if (response.formModel.profile.remember) {
      document.cookie =
        "KEEP_ME_LOGIN=true;" + expires + ";domain=.deloitte.com;path=/";
      localStorage.setItem("remember", true);
    } else {
      document.cookie =
        "KEEP_ME_LOGIN=false;" + expires + ";domain=.deloitte.com;path=/";
      localStorage.setItem("remember", false);
    }
  }
  }
  
  /**Code for to display optin screen for twitter registration from log in tab starts  **/
  if (
    response.form === "gigya-register-form" ||
    response.form === "gigya-profile-form"
  ) {
    if (
      !response.isVerified &&
      response.accountInfo !== undefined &&
      response.accountInfo.profile.lastName === undefined &&
      response.formModel.profile.lastName === undefined
    ) {
      response.formModel.profile.lastName = "Not provided";
      if (response.accountInfo.profile.firstName !== undefined) {
        response.formModel.profile.firstName =
          response.accountInfo.profile.firstName;
      }
    }
    if (PAGE_URL.indexOf("action=optin") > -1 && !response.isVerified) {
      var url_string = PAGE_URL.split(".com");
      var queryString = url_string.pop();
      response.formModel.data.myDeloitte.regState = queryString;
      response.formModel.data.myDeloitte.prefSite = getCookie(
        "myD_siteSelector"
      );
    }
  }

  /**Code for to display optin screen for twitter registration from log in tab ends **/
  /** Code for to save the url string in regState firld for dbrief starts**/
  if (PAGE_URL.indexOf("eventid") > -1 && !response.isVerified) {
  
    response.formModel.data.myDeloitte.regState = PAGE_URL;
  }
  /** Code for to save the url string in regState firld for dbrief ends**/
}
//VA: Can be moved into Registration-screen.js
var handleLogin = function(loginEvent) {
  // Setting local & session variables on succsessful Login
  // DE:246668 persistent session issue - Creating a localstorage variable and session cookie

  localStorage.setItem("userLoggedInIs", true);
  document.cookie = "userLoggedInIs=true; domain=deloitte.com; path=/";

  /** Saving site string value in gigya while login from dcom join link strats from here **/
  if (loginEvent) {
    if (
      loginEvent.data.myDeloitte !== undefined &&
      loginEvent.data.myDeloitte.prefSite !== undefined
    ) {
      var siteValue = encodeHTML(loginEvent.data.myDeloitte.prefSite);
	  /*Setting the myD_siteSelector cookie value to 1 year from the date of acceptence instead of 2099*/
	  var expireDate = new Date();
	  expireDate.setFullYear(expireDate.getFullYear() + 1); 
	  var expires = "expires=" + expireDate.toUTCString();
      document.cookie =
        "myD_siteSelector=" +
        siteValue +
        "; expires= " + expires; "path=/; secure";
    }
  }

  //MYDAAS: making form post call if mydaasflow and redirecting to consumer app
  if (loginEvent !== undefined && loginEvent != null && loginEvent.newUser) {
    var IS_NEW_USER = true;
    localStorage.setItem("isNewUser", "true");
  }

  //MYDAAS: check if flow is mydaas and TOU of appid is already accepted in response
  if (sessionStorage.getItem("mydaasflow") === "true" && !IS_NEW_USER) {
    //calling function in mydaas.js to check if appid TOU is already accepted for incoming app
    var flagforappid = false;
    flagforappid = checkIfTouExistsForApp(loginEvent);

    //MYDAAS: if mydaas terms and conditions are not accepted for the appid, then redirect to gated screen from evaluserresponse
    if (
      loginEvent.data.mydaas === undefined ||
      loginEvent.data.mydaas.tou === undefined ||
      flagforappid === false
    ) {
      sessionStorage.setItem("showmydaastou", "true");
      gigya.accounts.getAccountInfo({
        apiKey: SOCIAL_API,
        UID: loginEvent.UID,
        include: "profile,data,emails",
        extraProfileFields: "work,phones",
        callback: evalUserResponse,
      });
    }
    

    //MYDAAS: if mydaas terms and conditions are accepted, then do form post
    else {
      if (
        sessionStorage.getItem("closedaccmydaasuser") != null &&
        sessionStorage.getItem("closedaccmydaasuser") === "true" || (!fieldCompletionCheck(loginEvent))
      ) {
        if (
          getParameterByName("flow") != "" &&
          getParameterByName("flow") === "gated"
        ) {
          var gated_URL =
            "./optin/gated-optsin." +
            sessionStorage.getItem("action") +
            "." +
            sessionStorage.getItem("appid") +
            "." +
            sessionStorage.getItem("mydaaslocale") +
            ".html";
          $(location).attr("href", gated_URL);
        } else if (
          getParameterByName("flow") === "progressive" ||
          fieldCompletionCheck(loginEvent)
        ) {
          var progressive_URL =
            "./progressiveprofile.mydaas." +
            sessionStorage.getItem("appid") +
            "." +
            sessionStorage.getItem("mydaaslocale") +
            ".html";
          $(location).attr("href", progressive_URL);
        }
      } else {
        //MYDAAS: calling function in mydaas.js to do form-post as TOU is already accepted for incoming appid
	    doFormPostForExistingMydaasUser(loginEvent);
      }
    }
  }

  /** Saving site string value in gigya while login from dcom strats ends here **/

  // this is the ONLY time we call get Account Info
  gigya.accounts.getAccountInfo({
    apiKey: SOCIAL_API,
    include: "profile,data,emails",
    extraProfileFields: "work,phones",
    callback: evalUserResponse,
  });
};

//VA: Can be moved into Registration-screen.js
var addLoginLogoutHandlers = function () {
  gigya.accounts.addEventHandlers({
    onLogin: handleLogin,
  });
};

// Once the script is loaded, initialize components
// VA: Once whole page is loaded, this is OOTB function that gets invoked and set lot of param at client side.
var onGigyaServiceReady = function () {
  var requestorAgent = getParameterByName("pullDown");
  var userProfileFromDCOM = readCookie("USER_DCOM");
  // show reg/signin tab according to hash
  showRegSigninTab();
  // gigya reset password screen
  if (PAGE_URL.indexOf("resetpwd=true") > -1) {
    $("#registration-features").hide();
    var pwrt = $.urlParam("pwrt");
    gigya.accounts.resetPassword({
      passwordResetToken: pwrt,
      newPassword: "x",
      callback: isResetPasswordLinkExpired,
      customLang: errorKeyMapParams,
    });
  }

  /* This logic is for session continuity */
  //VA: This needs to be re-written for keep me logged in requirement

  if (
    (userProfileFromDCOM !== "undefined" || userProfileFromDCOM != null) &&
    requestorAgent === "true"
  ) {
    // document.cookie ="USER_DCOM_NOTIFICATION=updated;domain=.deloitte.com;path=/";
    var dcom_UID = JSON.parse(userProfileFromDCOM);
    if (dcom_UID == null || dcom_UID === "" || dcom_UID === "undefined") {
      var profPullDownFromDcom = readCookie("PROFILE_PULL_DOWN");
      if (profPullDownFromDcom != null && profPullDownFromDcom !== "") {
        dcom_UID = profPullDownFromDcom;
      }
    }
    gigya.accounts.getAccountInfo({
      apiKey: SOCIAL_API,
      UID: dcom_UID,
      callback: evalUserResponse,
    });
  } else {
    if (pagetype !== "undefined" && pagetype === "registration") {
      /** code for getting the interest IDs && subscription IDs from URLs starts**/
      if (PAGE_URL.indexOf("action=optin") > -1) {
        if (PAGE_URL.indexOf("aoi=") > -1) {
          var aoiKey = getparamNameMultiValuesFromURL("aoi");
          if (typeof [aoiKey !== "undefined"] && aoiKey !== "") {
            localStorage.setItem("aoiKey", aoiKey);
            localStorage.setItem("isRedirectToAoi", "true");
          }
        }
        if (PAGE_URL.indexOf("sub=") > -1) {
          var subKey = getparamNameMultiValuesFromURL("sub");
          if (typeof [subKey !== "undefined"] && subKey !== "") {
            localStorage.setItem("subKey", subKey);
            localStorage.setItem("isRedirectToSub", "true");
          }
        }
      }
      /** code for getting the interest IDs && subscription IDs from URLs ends **/
      if (PAGE_URL.indexOf("action=qr") > -1) {
        sessionStorage.setItem("isClientRegistration", "true");
      }
      /** Nocheck focus implementation for subscription starts**/
      if (
        PAGE_URL.indexOf("action=optin") > -1 &&
        PAGE_URL.indexOf("nocheck=true") > -1
      ) {
        
        localStorage.setItem("nocheck", "true");
        if (PAGE_URL.indexOf("sub=") > -1) {
          subKey = getparamNameMultiValuesFromURL("sub");
          if (typeof [subKey !== "undefined"] && subKey !== "") {
            localStorage.setItem("subKey", subKey);
            localStorage.setItem("isRedirectToSub", "true");
          }
        }
        if (PAGE_URL.indexOf("aoi=") > -1) {
          aoiKey = getparamNameMultiValuesFromURL("aoi");
          if (typeof [aoiKey !== "undefined"] && aoiKey !== "") {
            localStorage.setItem("aoiKey", aoiKey);
          }
        }
      }

      var newUserParam = getParameterByName("newUser");
      var errorCode = getParameterByName("errorCode");
      addLoginLogoutHandlers();

      //Note: need to check with Vishal and Bharat
      if (
        localStorage.getItem("remember") === "true" &&
        sessionStorage.getItem("response") !== null
      ) {
        handleLogin(null);
      } else {
        USER_IS_LOGGED = false;
        if (newUserParam == null || errorCode === 0) {
          // show registration screen.
          gigya.accounts.showScreenSet(regParams);
          if (
            PAGE_URL.indexOf("action=optin") > -1 ||
            PAGE_URL.indexOf("eventid") > -1
          ) {
            showSigninScreen();
          }
        }
      }
    }

    var user_closed_account = localStorage.getItem("userclosedaccount");
    if (user_closed_account) {
      $(".mydeloitte-alert").show();
      var alertHt = $(
        ".mydeloitte-alert.mydeloitte-alert--success"
      ).outerHeight(true);
      $("#header").css("top", alertHt);
      localStorage.removeItem("userclosedaccount");
    }

    if (
      pagetype !== "undefined" &&
      localStorage.getItem("loggedIn") === "true" &&
      pagetype !== "registration" &&
      sessionStorage.getItem("DBriefFlow") === "true"
    ) {
      evalUserResponse();
    } else {
      if (
        pagetype !== "undefined" &&
        localStorage.getItem("loggedIn") === "true" &&
        pagetype !== "registration"
      ) {
        evalUserResponse();
      }
    }
    if (
      pagetype !== "undefined" &&
      localStorage.getItem("loggedIn") === "true" &&
      pagetype === "registration"
    ) {
      if (
        localStorage.getItem("DbriefErrorMessage") !== null ||
        localStorage.getItem("DbriefSuccessMessage") !== null
      ) {
        if ($.urlParam("eventid") == null) {
          sessionStorage.removeItem("eventId");
        }
        if (sessionStorage.getItem("eventId") !== $.urlParam("eventid")) {
          setItemInSessionStorage("eventId", $.urlParam("eventid"));
        }
        evalUserResponse();
      }
    }
    if (typeof wcmMode === "undefined") {
      var wcmMode = "DISABLED";
    }

    if (
      localStorage.getItem("loggedIn") !== "true" &&
      wcmMode === "DISABLED" &&
      pageTypeArray.indexOf(pagetype) === -1 &&
      !sessionStorage.getItem("mydaasflow")
    ) {
      var redirect_URL = "./registration.html";
      $(location).attr("href", redirect_URL);
    }

    /* This logic is for session continuity */
    //VA: This needs to be re-written for keep me logged in requirement
    if (
      (userProfileFromDCOM !== "undefined" || userProfileFromDCOM != null) &&
      pagetype !== "accountsettings" &&
      pagetype !== "profile" &&
      pagetype !== "optininterests" &&
      pagetype !== "progressiveprofile" &&
      pagetype !== "subscription"
    ) {
      // document.cookie =
      //   "USER_DCOM_NOTIFICATION=updated;domain=.deloitte.com;path=/";
      dcom_UID = JSON.parse(userProfileFromDCOM);
      if (dcom_UID == null || dcom_UID === "" || dcom_UID === "undefined") {
        profPullDownFromDcom = readCookie("PROFILE_PULL_DOWN");
        if (profPullDownFromDcom != null && profPullDownFromDcom !== "") {
          dcom_UID = profPullDownFromDcom;
        }
      }
      gigya.accounts.getAccountInfo({
        apiKey: SOCIAL_API,
        UID: dcom_UID,
        callback: evalUserResponse,
      });
    }
  }
  bookmarkDataUpdate();
};


//Evaluate Session.
//VA: should be separate utility file
var evalSession = function () {
  getSessionResponse().then(function (response) {
    if (response.errorCode === 0) {
      sessionStorage.setItem("response", JSON.stringify(response));
      // populate response, profile, name, etc...
      evalResponse(response);
      (function (response) {
        requestorDomain = $.urlParam("requestedBy");

        //var userProfileFromDCOM;
        if (requestorDomain === "dcom" || requestorDomain === "di") {
          userProfileFromDCOM = readCookie("USER_DCOM");
          if (
            userProfileFromDCOM !== "undefined" &&
            userProfileFromDCOM != null
          ) {
            dcom_UID = JSON.parse(userProfileFromDCOM);
            evalUserResponse();
          }
        
        }

        if (sessionStorage.getItem("response") !== null) {
          if (requestorDomain !== "dcom" || requestorDomain !== "di") {
            response = JSON.parse(sessionStorage.getItem("response"));
            if (
              response !== null &&
              response !== undefined &&
              response.data !== undefined &&
              response.data.myDeloitte !== undefined &&
              response.profile !== undefined &&
              response.profile.email !== undefined
            ) {
              evalResponse(response);
            }
          } else {
            userProfileFromDCOM = readCookie("USER_DCOM");
            //Storing the response in sessionstorage
            sessionStorage.removeItem("response");
            sessionStorage.setItem("response", userProfileFromDCOM);
          }
        }
        if (typeof response !== "undefined") {
          if (
            typeof response.data.myDeloitte.sites !== "undefined" &&
            response.data.myDeloitte.sites !== "" &&
            response.data.myDeloitte.sites[0] !== undefined
          ) {
            if (
              typeof response.data.myDeloitte.sites[0].consents !==
                "undefined" &&
              response.data.myDeloitte.sites[0].consents !== ""
            ) {
              if (response.data.myDeloitte.consent.profile) {
                var emailUpdatesarray = [];
                var len = response.data.myDeloitte.sites[0].consents.length;
                for (var i = 0; i < len; i++) {
                  emailUpdatesarray.push(
                    response.data.myDeloitte.sites[0].consents[i].id
                  );
                }
                sessionStorage.setItem("emailupdates", emailUpdatesarray);
              }
            }
          }
        }
      })();
    } else if (pagetype !== "registration" && pagetype !== "unsubscribe") {
      // logout user if no response or error Code
      
      logOut();
    }
  });
};

//VA: Function called on callback to process User's response
function evalUserResponse() {
  getSessionResponse().then(function (response) {
    var NEW_USER = "newUser";
    var EVENTIDFROMSTRING = "eventid";
    var EVENTID = "eventId";
    var PAGETYPE_REGISTRATION = "registration";
    var PAGETYPE_OPTININTERESTS = "optininterests";
    var PAGETYPE_PROFILE = "profile";
    var LOGGED_IN = "loggedIn";
    var PAGETYPE_ACCOUNTSETTINGS = "accountsettings";
    var PAGETYPE_DASHBOARD = "dashboard";
    var PAGE_REDIRECT = "pageredirect";

    var isErrorCodeZero =
      response != null &&
      typeof response.errorCode !== "undefined" &&
      response.errorCode === 0;
    var pageTypeRegistrationOrOptininterests =
      pagetype === PAGETYPE_REGISTRATION || pagetype === PAGETYPE_OPTININTERESTS;

    setCookiesIfDeloitteUserEmail(response);
    //Fix for 794744 starts
	    var my_site = myDelLocale.replace(/\//g, "-");
	    var pref_site= response.data.myDeloitte.prefSite;
	    if(!(my_site === pref_site)){
	      getNotificationValfromPrefSite(pref_site);
	      var pageJSON = JSON.parse(
	    		    sessionStorage.getItem("pageJSON"));
	      if(pageJSON)
	    	  OPTIN_EMAIL_NOTIFICATION = pageJSON.properties.emailNotification;
	    }
    //Fix for 794744 ends
    if (isErrorCodeZero) {
      //Storing the response in local-storage
      resetResponseInSessionStorage(response);
    }

    //check if user is new. If yes, then check regstate. If regstate has eventId then set eventid in localstorage. If user signs up MyD while accessing Dbriefs, then regstate will have eventid in url.
    var newUserParam = getParameterByName(NEW_USER);
    if (newUserParam !== null) {
      if (
        response.data.myDeloitte !== undefined &&
        typeof response.data.myDeloitte.regState !== "undefined"
      ) {
        var regSt = getparamsFromQueryString(
          EVENTIDFROMSTRING,
          response.data.myDeloitte.regState
        );
        if (
          pageTypeRegistrationOrOptininterests &&
          regSt !== undefined &&
          regSt !== ""
        ) {
          setItemInSessionStorage(EVENTID, regSt);
        }
      }
    }
    if (
      pageTypeRegistrationOrOptininterests &&
      sessionStorage.getItem(EVENTID) !== null &&
      sessionStorage.getItem(EVENTID) !== ""
    ) {
      setItemInSessionStorage("Mysession", JSON.stringify(response));
      checkForValidity(response);
    }

    //Show gated consent-screen <div> if pagetype is OptinInterests
    //VA: Should be moved to optin specific script file for DOM Manipulation
    if (pagetype === "optininterests") {
      $("#dbrief-check-div").hide();

      if (sessionStorage.getItem("showmydaastou") === "true") {
        $(".mydaas-check").css("display", "block");
      }

      if (
        (localStorage.getItem("notConsented") === "true" ||
          localStorage.getItem("diffDays") > 365) &&
        sessionStorage.getItem("eventId") !== null &&
        sessionStorage.getItem("eventId") !== ""
      ) {
        $("#dbrief-check-div").show();
      }
      // US-344931
      // do not show legal text if subscription or optin url
      if (
        localStorage.getItem("subKey") !== null ||
        localStorage.getItem("aoiKey") !== null
      ) {
        $("#dbrief-legalcheck-div").hide();
        $("#dbrief-check-div").hide();
      }
      // only show legal text if it's not us site
      else if (
        (localStorage.getItem("notConsented") === "true" ||
          localStorage.getItem("diffDays") > 365) &&
        getCookie("myD_siteSelector").indexOf("us-en") === -1
      ) {
        $("#dbrief-legalcheck-div").show();
        $("#dbrief-check-div").show();
      }
    }

    setCountryLocation(response);

    // new user and event id exists
    if (typeof response !== "undefined" && pagetype !== PAGETYPE_PROFILE) {
      //make Dbriefs call if 'existing user' and consent difference is less than 365 days
      if (
        pageTypeRegistrationOrOptininterests &&
        sessionStorage.getItem(EVENTID) !== null &&
        !$.urlParam(NEW_USER) &&
        localStorage.getItem("isNewUser") !== "true" &&
        localStorage.getItem("diffDays") <= 365
      ) {
        makeDbriefCallForExistingUser(response);
      }
    }

    if (
      pagetype !== "undefined" &&
      pagetype === PAGETYPE_REGISTRATION &&
      isErrorCodeZero
    ) {
      //On login, set local-storage items so that user is auto-logged in if logout button is not clicked
      var isForgotPwd = $.urlParam("showForgotPassword");
      resetResponseInSessionStorage(response);
      setItemInLocalStorage(LOGGED_IN, "true");

      var isForgotPassword =
        isForgotPwd === "true" && isForgotPwd !== "" && isForgotPwd !== 0;

      //Setting localstorage item if stay signed not checked session out will hapeen for inactive for 30 min
      if (
        $(".gigya-keep-me-logged-in input").length &&
        $(".gigya-keep-me-logged-in #gigya-checkbox-remember").is(":checked")
      ) {
        setItemInLocalStorage("keepMeLogin", "true");
      }
 
      var touDiff = Math.abs(new Date() - new Date(response.data.myDeloitte.tou.date));
      var touDiffInsec = touDiff/(1000);
      newUserParam = getParameterByName(NEW_USER);
      if (newUserParam != null || touDiffInsec < 20) {
        setItemInLocalStorage("isNewUser", "true");
      }
     
      //Redirect: For new users if url has optin or dbrief, then redirect them to gated screen
      if ((localStorage.getItem("isNewUser") === "true" || newUserParam !== null) &&
        typeof response.data.myDeloitte.regState !== "undefined" &&
        (isOptinOrDbriefOrMyDaaSUser(response) ||
          (sessionStorage.getItem(EVENTID) !== null &&
            sessionStorage.getItem(EVENTID) !== ""))
      ) {
        newUserRedirectIfStateIsIsOptinOrDbrief(response);
      }

      //Redirect: For new user without eventId, redirect to dashboard or progressive-profile
      else if (
        (newUserParam !== null || IS_NEW_USER) &&
        sessionStorage.getItem(EVENTID) == null &&
        sessionStorage.getItem(EVENTID) !== ""
      ) {
        redirectNewUserWithOutEventId(response);
      }
      //Code to fix US-516163
      //Redirect: for existing user, if url is of groupinvite link...set Company and Group ID's to gigya
      else if (
        PAGE_URL.indexOf("action=qr") > -1 ||
        PAGE_URL.indexOf("p=") > -1
      ) {
        var urlEncryptedJson = $.urlParam("p");
        var urlDecryptedJson = atobUTF16(urlEncryptedJson);
        urlDecryptedJson = JSON.parse(urlDecryptedJson);
        var accountGroupId = urlDecryptedJson.g;
        var params = {
          data: {
            myDeloitte: {
              accountGroupId: accountGroupId,
            },
          },
          callback: redirecttoDashboard,
        };
        gigya.accounts.setAccountInfo(params);
      }
      //Code end for US-516163

      //Redirect: For existing user, if url is optin or dbrief.. call displayOptInscreen
      else if (
        IS_NO_CHECK === true ||
        PAGE_URL.indexOf("action=optin") > -1 ||
        (sessionStorage.getItem(EVENTID) !== null &&
          sessionStorage.getItem(EVENTID) !== "")
      ) {
        if (sessionStorage.getItem("response") !== null) {
          response = JSON.parse(sessionStorage.getItem("response"));
          displayOptInscreen(response);
        }
      } else if (sessionStorage.getItem("mydaasflow") !== "true") {
        /* Since below logic is specific to MyD/Optin and Dbriefs flow, masking whole redirects for MyDaaS flow*/
        var pageName = localStorage.getItem(PAGE_REDIRECT);
        if (
          !(isForgotPwd === "true" && isForgotPwd !== "" && isForgotPwd !== 0) &&
          pageName == null
        ) {
          if (response.profile != null && fieldCompletionCheckQR(response)) {
            $(location).attr("href", "./dashboard.html");
          }  else if (
            response.profile != null &&
            !fieldCompletionCheck(response) && (touDiffInsec < 20 )
          ) {
            $(location).attr("href", "./progressiveprofile.html");
            return false;
          } else if (
            response.profile != null &&
            !fieldCompletionCheck(response) &&
            localStorage.getItem("isNewUser") === "true"
          ) {
            $(location).attr("href", "./progressiveprofile.html");
            return false;
          } 
         
          else {
        	  if(gatedEmailNotificationCheckQR(response)){
        		  $(location).attr("href", "./optin/gated-optsin.html");
        		  return true;
        	  } else {
            $(location).attr("href", "./dashboard.html");
        	  }
          }
        }

        if (!isForgotPassword) {
          if (
            typeof response !== "undefined" &&
            (response.data.myDeloitte.regState === siteVal ||
              localStorage.getItem("lSource") === "insights-us-en_en") &&
            localStorage.getItem("isNewUser") === "true" &&
            fieldCompletionCheck(response)
          ) {
            pageName = localStorage.getItem(PAGE_REDIRECT);
            if (
              response.loginProvider !== "undefined" &&
              response.loginProvider === "site" &&
              pageName == null
            ) {
              window.location.href = "./profile.html?icid=success_reg_email";
            } else if (
              response.loginProvider !== "undefined" &&
              response.loginProvider !== "site" &&
              pageName == null
            ) {
              window.location.href =
                "./profile.html?icid=success_reg_" + response.loginProvider;
            } else {
              if (
                pageName == null ||
                pageName === "undefined" ||
                pageName === ""
              ) {
                pageName = "dashboard";
              }
              window.location.href = "./" + pageName + ".html";
            }
          } else if (
            !fieldCompletionCheck(response) &&
            (response.data.myDeloitte.regState.indexOf("action=optin") > -1 ||
              response.data.myDeloitte.regState.indexOf(EVENTIDFROMSTRING) > -1)
          ) {
            var step3_page_URL = "./optin/gated-optsin.html";
            $(location).attr("href", step3_page_URL);
          } else {
            $(location).attr("href", "./dashboard.html");
          }
        }

        /* For retiring user */
        if (
          newUserParam === null &&
          (requestorDomain !== "dcom" || requestorDomain !== "di")
        ) {
          if (
            !(isForgotPwd === "true" && isForgotPwd !== "" && isForgotPwd !== 0)
          ) {
            if (
              response.loginProvider !== "undefined" &&
              response.loginProvider === "site"
            ) {
              window.location.href =
                "./dashboard.html?icid=success_signin_email";
            } else if (
              response.loginProvider !== "undefined" &&
              response.loginProvider !== "site"
            ) {
              window.location.href =
                "./dashboard.html?icid=success_signin_" +
                response.loginProvider;
            } else {
              window.location.href = "./dashboard.html";
            }
          }
        }

      }
      // Below condition if for redirect to Gated optin when end user doesn't have TOU set or trying to login with new consumer app
      else if (sessionStorage.getItem("mydaasflow") === "true") {
    if(gatGatedFloeUserDetailsCheckQR(response) && fieldCompletionCheck(response)){  
         /** This function Redirects the MyDaas user from Gated to consumer app home screen**/
    	post(mydaas_postback_url, response);
    		    
      } else {
    	  sessionStorage.setItem(
    	          "showmydaastou",
    	          !checkIfTouExistsForApp(response)
    	        );
    	        var gated_URL =
    	          "./optin/gated-optsin." +
    	          sessionStorage.getItem("action") +
    	          "." +
    	          sessionStorage.getItem("appid") +
    	          "." +
    	          sessionStorage.getItem("mydaaslocale") +
    	          ".html";
    	        $(location).attr("href", gated_URL);
      }
      } 
    }

    // requestorDomain is set if user comes to My-Deloitte page using Dcom or Di website. Identified by 'requestedBy' in URL
    if (requestorDomain === "dcom" || requestorDomain === "di") {
      redirectIfReqDomainIsDcomOrDi(response);
    } else {
      if (pagetype !== "undefined" && pagetype !== PAGETYPE_REGISTRATION) {
        if (pagetype === PAGETYPE_ACCOUNTSETTINGS) {
          evalAccountSettingsSession();
        }
        evalSession();
      }

      //code for outdated email.

      if (
        pagetype !== "undefined" &&
        localStorage.getItem(LOGGED_IN) === "true" &&
        pagetype === PAGETYPE_DASHBOARD
      ) {
        if (
          typeof response.profile !== "undefined" &&
          typeof response.data.myDeloitte !== "undefined"
        ) {
          if (typeof response.data.myDeloitte.system !== "undefined") {
            if (
              typeof response.data.myDeloitte.system.rejectedEmail !==
                "undefined" &&
              response.data.myDeloitte.system.rejectedEmail === "true"
            ) {
              $(".user-email").html(
                "<strong>" + response.profile.email + "</strong>"
              );
              $("#inactiveProfile").modal({
                backdrop: "static",
                show: true,
              });
              return false;
            }
          }
        }
      }
    }
  });
}

//VA: Should be moved to Account settings specific script (Need to double check)
function setRejectedEmail() {
  var eventParam = {
    "myDeloitte.system.rejectedEmail": null,
  };
  var params = {
    data: eventParam,
    apiKey: SOCIAL_API,
    UID: SOCIAL_PROFILE_UID,
    callback: rejectedEmailResponse,
  };
  gigya.accounts.setAccountInfo(params);
}

//VA: Should be moved to Account settings specific script
function rejectedEmailResponse(response) {
  if (typeof response.errorCode !== "undefined" && response.errorCode === 0) {
   
    //Storing the response in sessionstorage
    var resObj = JSON.parse(sessionStorage.getItem("response"));
    resObj.data.myDeloitte.system.rejectedEmail = null;
    
    sessionStorage.setItem("response", JSON.stringify(resObj));
  }
}

//VA: Should be moved to registration screen
function setParametersForNewUser(response) {
  var regStateStr = response.data.myDeloitte.regState;
  if (regStateStr !== null && regStateStr.indexOf("action=optin") > -1) {
    if (regStateStr != null && regStateStr.indexOf("aoi") > -1) {
      var aoiKey = getparamsFromQueryString("aoi", regStateStr);
      if (typeof [aoiKey !== "undefined"] && aoiKey !== "") {
        localStorage.setItem("aoiKey", aoiKey);
      }
    }
    if (regStateStr != null && regStateStr.indexOf("sub") > -1) {
      var subKey = getparamsFromQueryString("sub", regStateStr);
      if (typeof [subKey !== "undefined"] && subKey !== "") {
        localStorage.setItem("subKey", subKey);
        localStorage.setItem("isRedirectToSub", "true");
      }
    }
  }
  /** Set Parameters for Nocheck focus implementation of subscription starts**/
  if (regStateStr !== null && regStateStr.indexOf("nocheck=true") > -1) {
    localStorage.setItem("nocheck", "true");
    subKey = getparamsFromQueryString("sub", regStateStr);
    if (typeof [subKey !== "undefined"] && subKey !== "") {
      localStorage.setItem("subKey", subKey);
      localStorage.setItem("isRedirectToSub", "true");
    }
    if (regStateStr != null && regStateStr.indexOf("aoi") > -1) {
      aoiKey = getparamsFromQueryString("aoi", regStateStr);
      if (typeof [aoiKey !== "undefined"] && aoiKey !== "") {
        localStorage.setItem("aoiKey", aoiKey);
      }
    }
  }
  /** Set Parameters for Nocheck focus implementation of subscription ends**/
  if (regStateStr !== null && regStateStr.indexOf("eventid") > -1) {
    var eventID = getparamsFromQueryString("eventid", regStateStr);
    if (typeof [eventID !== "undefined"] && eventID !== "") {
      setItemInSessionStorage("DeventId", eventID);
      setItemInSessionStorage("DBriefFlow", "true");
      setItemInSessionStorage("FirstTimeUser", "true");
    }
  }
  /** Set Parameters for mydaas consumer app starts**/
  if (regStateStr !== null && regStateStr.indexOf("registration.mydaas") > -1) {
    sessionStorage.setItem("isMyDaaSFlow", "true");
    if (getParameterByName("bm", regStateStr) !== "") {
      sessionStorage.setItem("bookmark", getParameterByName("bm", regStateStr));
    }
  }
  /** Set Parameters for mydaas consumer app ends**/
}

//Redirect to Dashboard page for Existing MyD user when logged in through GroupInviteLink
//VA: should be part of registration screen
function redirecttoDashboard(response) {
  //updating sessionn storage with updated groupaccountID
  var accountGroupId = response.requestParams.data.myDeloitte.accountGroupId;
  var sessionResponse = JSON.parse(sessionStorage.getItem("response"));
  sessionResponse.data.myDeloitte["accountGroupId"] = accountGroupId;
  sessionStorage.setItem("response", JSON.stringify(sessionResponse));
  $(location).attr("href", "./dashboard.html");
}
// ---- Function starts for page redirecting from register/log in via optin URL -------
//---- ends for page redirecting from register/log in via optin URL -------
//VA: should be part of optin screen script
function displayOptInscreen(response) {
  if (response !== null && response !== "undefined") {
    if (
      typeof response.profile !== "undefined" &&
      typeof response.data.myDeloitte !== "undefined"
    ) {
      if (typeof response.data.myDeloitte.consent !== "undefined") {
        if (
          (localStorage.getItem("notConsented") === "true" &&
            sessionStorage.getItem("eventId") !== null &&
            sessionStorage.getItem("eventId") !== "") ||
          localStorage.getItem("diffDays") > 365
        ) {
          var optin_page_URL = "./optin/gated-optsin.html";
          $(location).attr("href", optin_page_URL);
          return false;
        }
      }
      if (fieldCompletionCheck(response)) {
        if (
          sessionStorage.getItem("DbriefSuccessMessage") !== null &&
          sessionStorage.getItem("DBriefFlow") === "true"
        )
          if (
            sessionStorage.getItem("DbriefSuccessMessage") !== null &&
            sessionStorage.getItem("DBriefFlow") === "true" &&
            sessionStorage.getItem("eventId") !== null &&
            sessionStorage.getItem("eventId") !== null
          ) {
            window.location.href = sessionStorage.getItem(
              "DbriefSuccessMessage"
            );
            sessionStorage.removeItem("DbriefSuccessMessage");
            localStorage.removeItem("DbriefSuccessMessage");
            sessionStorage.removeItem("eventId");
            return false;
          }
        if (localStorage.getItem("isRedirectToSub") === "true") {
          window.location.href = "./subscriptions.html";
        } else if (localStorage.getItem("isRedirectToAoi") === "true") {
          localStorage.removeItem("isRedirectToAoi");
          if (
            response.loginProvider !== "undefined" &&
            response.loginProvider === "site"
          ) {
            window.location.href = "./profile.html?icid=success_reg_email";
          } else {
            if (
              response.loginProvider !== "undefined" &&
              response.loginProvider !== "site"
            ) {
              window.location.href = "./profile.html?icid=success_reg_" + response.loginProvider;
            }
          }
        } else if (
          typeof response !== "undefined" &&
          (response.data.myDeloitte.regState === siteVal ||
            localStorage.getItem("lSource") === "insights-us-en_en") &&
          localStorage.getItem("isNewUser") === "true"
        ) {
          if (
            response.loginProvider !== "undefined" &&
            response.loginProvider === "site" &&
            !fieldCompletionCheck(response)
          ) {
            optin_page_URL = "./profile.html?icid=success_reg_email";
          } else if (
            response.loginProvider !== "undefined" &&
            response.loginProvider !== "site" &&
            !fieldCompletionCheck(response)
          ) {
            optin_page_URL = "./profile.html?icid=success_reg_" + response.loginProvider;
          } else {
            optin_page_URL = "./profile.html";
          }
          localStorage.removeItem("lSource");
        } else {
          if (
            response.loginProvider !== "undefined" &&
            response.loginProvider === "site"
          ) {
            window.location.href = "./dashboard.html?icid=success_signin_email";
          } else if (
            response.loginProvider !== "undefined" &&
            response.loginProvider !== "site"
          ) {
            window.location.href =
              "./dashboard.html?icid=success_signin_" + response.loginProvider;
          } else {
            window.location.href = "./dashboard.html";
          }
        }
      } else {
        optin_page_URL = "./optin/gated-optsin.html";
        sessionStorage.removeItem("queryStringParam");
        $(location).attr("href", optin_page_URL);
      }
    } 
  }
}

//VA: should be separate utility file
var noOfTimesEvalResponseCalled = 0;
// adding variable to store no of times evalresponse() is called so that multiple calls to same function is avoided
function evalResponse(response) {
  noOfTimesEvalResponseCalled++;
  dataLayer.page.attributes.userRegistrationStatus = response.isRegistered;
  // adding the registered flag to cookie as well
  localStorage.setItem("isRegistered", response.isRegistered);
  var sc_gigyaId = "";
  try {
    sessionStorage.setItem("gigyaIdInSession", response.UID);
    sc_gigyaId = response.UID;
  } catch (err) {
    
    sc_gigyaId = response.UID;
  }

  USER_IS_LOGGED = true;
  localStorage.setItem("remember", true);

  SOCIAL_PROFILE = response;
  setRememberMecookie();

  SOCIAL_PROFILE_UID = response.UID;
  SOCIAL_PROFILE = response;
  
  var mcidCookieValue = readCookie(MCID_COOKIE_NAME);
  if (
    mcidCookieValue !== null &&
    typeof mcidCookieValue !== "undefined" &&
    mcidCookieValue.indexOf(MCID_COOKIE_FIELD_NAME) !== -1
  ) {
    var cookieFieldArray = mcidCookieValue.split("|");
    var mcidValue =
      cookieFieldArray[cookieFieldArray.indexOf(MCID_COOKIE_FIELD_NAME) + 1];
    localStorage.setItem("mcidValue", mcidValue);
  }

  if (
    typeof SOCIAL_PROFILE.data.myDeloitte !== "undefined" &&
    typeof SOCIAL_PROFILE.data.myDeloitte.bookmarks !== "undefined"
  ) {
    var existingAccountBookMarks = SOCIAL_PROFILE.data.myDeloitte.bookmarks;
    var bookmarks = JSON.stringify(existingAccountBookMarks);
    //Setting bookmarks details in localstorage to populate in content feed

    sessionStorage.setItem("bookmarks", bookmarks);
    var tempBookmarksVal = "";
    for (var i = 0; i < existingAccountBookMarks.length; i++) {
      var obj = existingAccountBookMarks[i];
      tempBookmarksVal = tempBookmarksVal + obj.id + "#" + obj.date + ",";
    }
    if (tempBookmarksVal !== "") {
      // Remove starting and trailing commas.
      if (tempBookmarksVal.substr(0, 1) === ",") {
        tempBookmarksVal = tempBookmarksVal.substring(1);
      }
      var len = tempBookmarksVal.length;
      if (tempBookmarksVal.substr(len - 1, 1) === ",") {
        tempBookmarksVal = tempBookmarksVal.substring(0, len - 1);
      }
    }

    sessionStorage.setItem("userAccountBookmarks", tempBookmarksVal);
  }
  //Fetch stored interests from gigya for this user.
  prepareInterestsAndTagsListFromGigya(SOCIAL_PROFILE);
  $("#profile-header-nav").show();
  $("#header-nav-hamburger").removeClass("d-none");
  $("#header-nav-hamburger").addClass("d-sm-block");

  if (typeof response.profile.thumbnailURL !== "undefined") {
    $("#profile-with-image").show();
    $("#profile-without-image").hide();
    $("#profile_thumbnail").attr("src", response.profile.thumbnailURL);
    if (pagetype === "profile") {
      $("#profile-image span").replaceWith(
        '<img id="profile-social-thumbnail" class="icon-myDeloitte-circle icon-myDeloitte-circle--bigger icon-user-o"/>'
      );
      $("#profile-social-thumbnail").attr(
        "alt",
        response.profile.firstName + "" + response.profile.lastName
      );
      $("#profile-social-thumbnail").attr("src", response.profile.thumbnailURL);
    }
  } else if (typeof response.profile.photoURL !== "undefined") {
    $("#profile-with-image").show();
    $("#profile-without-image").hide();
    $("#profile_thumbnail").attr("src", response.profile.photoURL);
    if (pagetype === "profile") {
      $("#profile-image span").replaceWith(
        '<img id="profile-social-thumbnail" class="icon-myDeloitte-circle icon-myDeloitte-circle--bigger icon-user-o"/>'
      );
      $("#profile-social-thumbnail").attr(
        "alt",
        response.profile.firstName + "" + response.profile.lastName
      );
      $("#profile-social-thumbnail").attr("src", response.profile.photoURL);
    }
  } else {
    $("#profile-with-image").hide();
    $("#profile-without-image").show();
    $("#profile-initials").html(response.profile.firstName[0]);
  }

  if (typeof response.profile.firstName !== "undefined") {
    /* Populating FirstName+LastName in profile page */
    $("#profile-name").html(
      response.profile.firstName + "  " + response.profile.lastName
    );
    $("#profile-initials").attr(
      "title",
      "My Deloitte Account: " +
        response.profile.firstName +
        "  " +
        response.profile.lastName
    );
    $("#profile_thumbnail").attr(
      "alt",
      response.profile.firstName + "" + response.profile.lastName
    );
    $("#profilefullname1").html(
      response.profile.firstName + "  " + response.profile.lastName
    );
    $("#profilefullname2").html(
      response.profile.firstName + "  " + response.profile.lastName
    );
  }
  /* Populating Name,jobTitle and Company in Dashboard page*/
  if ($(".dashboard-page").length) {
    if (
      typeof response.profile.firstName !== "undefined" &&
      response.profile.firstName !== ""
    ) {
      $("#dashboard-name").html(
        response.profile.firstName + "  " + response.profile.lastName
      );
    }
    if (
      typeof response.data.myDeloitte.jobTitle !== "undefined" &&
      response.data.myDeloitte.jobTitle !== ""
    ) {
      $("#dashboard-jobTitle").html(response.data.myDeloitte.jobTitle);
    }
    if (
      response.data.myDeloitte.company !== "" &&
      response.data.myDeloitte.jobTitle !== "" &&
      typeof response.data.myDeloitte.jobTitle !== "undefined" &&
      typeof response.data.myDeloitte.company !== "undefined"
    ) {
      $("#dashboard-profile-divider").html("| ");
    }
    if (
      typeof response.data.myDeloitte.company !== "undefined" &&
      response.data.myDeloitte.company !== ""
    ) {
      $("#dashboard-company").html(response.data.myDeloitte.company);
    }
  }

  SOCIAL_PROFILE_UID = response.UID;
  if (
    pagetype === "profile" ||
    pagetype === "optininterests" ||
    pagetype === "progressiveprofile"
  ) {
    $("#alumniRow1").hide();
    $("#alumniRow2").hide();
    $("#alumniRow3").hide();

    if (noOfTimesEvalResponseCalled === 1) {
      loadJobFunctions();
      loadIndustryForProfile();
      loadCurrentJobLevelForProfile();
    }
    loadMemeberfirms();
    loadYearSeparated();
    loadJobFunctionForAlumni();
    loadLocationsForAlumni();
    /** Handling button label change for profile page starts**/
    if (pagetype === "profile") {
      var isnew = localStorage.getItem("isNewUser");
      if (isnew || IS_NEW_USER) {
        $("#save-profile-page").html(new_user_save_btn);
      } else {
        $("#save-profile-page").html(existing_user_save_btn);
      }
    }
    /** Handling button label change for profile page ends**/
    if (typeof response !== "undefined") {
      displayDataProfilePage(response);
    }

    $("input#deloitteAlumni").change(function () {
      var $this = $(this);
      
      if ($this.is(":checked")) {
        $("#alumniRow1").show();
        $("#alumniRow2").show();
        $("#alumniRow3").show();
        isAlumniSelected = true;
      } else {
        $("#alumniRow1").hide();
        $("#alumniRow2").hide();
        $("#alumniRow3").hide();
        isAlumniSelected = false;
      }
    });
    $('input:radio[name="receiveEmails"]').change(function () {
      if (this.checked && this.value === "true") {
        isReceiveEmails = true;
      } else {
        isReceiveEmails = false;
      }
    });

    //Alumni section under personal info
    var isSelected = "";
    if (typeof response.data.myDeloitte.alumni !== "undefined") {
      isSelected = response.data.myDeloitte.alumni.selected;
      if (isSelected === true) {
        isAlumniSelected = true;
      }
    }
    if (
      typeof response.data.myDeloitte.consent !== "undefined" &&
      typeof response.data.myDeloitte.consent.profile !== "undefined"
    ) {
      isReceiveEmails = response.data.myDeloitte.consent.profile;
    }
    prepareRecData(interestsSelected, userAddedTags);
  }
  // This is for to populate subscriptions in
  if (pagetype === "subscription") {
    /* this will be used for feature release*/
    forwardResponseForSubPage(response, SOCIAL_API);
  }
  // Load accounts.js
  if (pagetype === "accountsettings") {
    forwardResponse(response, SOCIAL_API);
  }
  //}
}



//VA move to main.js if not redundant
function logOutResponse(response) {
  if (response.errorCode === 0) {
    USER_IS_LOGGED = false;
    localStorage.removeItem("remember");
    localStorage.removeItem("loggedIn");
    localStorage.removeItem("userLoggedInIs");
    sessionStorage.clear();
    localStorage.clear();
    // persist isRegistered flag after logout clear
    localStorage.setItem("isRegistered", true);
    var my_account_url = logoLinkNotLoggedIn + "?state=signin";
    window.location.replace(my_account_url);
  } else {
    localStorage.removeItem("remember");
    localStorage.removeItem("loggedIn");
    localStorage.removeItem("userLoggedInIs");
    sessionStorage.clear();
    localStorage.clear();
    
  }
}

//VA move to main.js if not redundant
var sessionLogout = function () {
  gigya.accounts.logout({
    callback: sessionLogOutResponse,
  });
};

//VA move to main.js if not redundant
function sessionLogOutResponse(response) {
  if (response.errorCode === 0) {
    USER_IS_LOGGED = false;
    localStorage.removeItem("remember");
    localStorage.removeItem("loggedIn");
    sessionStorage.clear();
    localStorage.clear();
  } 
}

//VA move to profile page script
function setShowSuccessInfoResponse(response) {
  if (response.errorCode === 0) {
    $("[data-screenset-element-id='modal-forgot-password']").modal("hide");
    $("#modal-forgot-password-success").modal("show");

    $("#modal-forgot-password-success").on("hidden.bs.modal", function () {
      gigya.accounts.showScreenSet(signinParams);
    });
  }
}

/* code for returning multi params from query string from gigya field regState ends */
//VA move to global-vars.js
function getparamsFromQueryString(paramName, queryString) {
  var sURL = decodeURI(queryString);
  var value = [];
  if (sURL.indexOf("?") > -1) {
    var arrParams = sURL.split("?");
    var arrURLParams = arrParams[1].split("&");
    for (var i = 0; i < arrURLParams.length; i++) {
      var sParam = arrURLParams[i].split("=");
      if (sParam) {
        if (sParam[0] === paramName) {
          if (sParam.length > 0) {
            value.push(sParam[1].trim());
          }
        }
      }
    }
  }
  return value.toString();
}

//A callback function for initregistration call.
//VA move to registration screen.js
function initRegistrationCallback(response) {
  if (response.errorCode === 0) {
    var regToken = response.regToken;
    registerUser(regToken);
  } else {
    _satellite.track("registrationError");
  }
}

//A function for register user.
//VA move to registration screen.js
function registerUser(regTokenValue) {
  var initRegToken = regTokenValue;
  var emailID = document.getElementsByName("email")[0].value;
  var passwd = document.getElementsByName("password")[0].value;
  var firstName = document.getElementsByName("profile.firstName")[0].value;
  var lastName = document.getElementsByName("profile.lastName")[0].value;
  var terms = document.getElementsByName("data.myDeloitte.tou.terms")[0].value;
  var termsBool = false;

  if (terms === "on") {
    termsBool = true;
  }

  var profileDetailsJSON = {
    firstName: firstName,
    lastName: lastName,
    email: emailID,
  };

  var dataDetailsJSON =
    "{" +
    ' "myDeloitte.tou.terms" : "' +
    termsBool +
    '",' +
    ' "myDeloitte.tou.date" : "' +
    new Date().toISOString() +
    '",' +
    ' "myDeloitte.tou.version" : "1"' +
    "}";
  // Set up the parameters required for accounts.register
  var regParams = {
    data: dataDetailsJSON,
    profile: profileDetailsJSON,
    email: emailID,
    password: passwd,
    regToken: initRegToken,
    callback: registrationCallback,
    finalizeRegistration: true,
  };

  gigya.accounts.register(regParams);
}

//A callback for registration call.
//VA move to registration screen.js
function registrationCallback(response) {
  if (typeof response.errorCode !== "undefined" && response.errorCode === 0) {
    dataLayer.page.attributes.userRegistrationStatus =
      response.data.isRegistered;
    _satellite.track("registrationSuccess");
  } else {
    _satellite.track("registrationError");
  }
}

//VA move to registration screen.js
function handleRegistrationSubmit(response) {

  if (accountGroupId !== "undefined" && accountGroupId !== null) {
    response.formModel.data.myDeloitte.accountGroupId = accountGroupId;
  }

  //setting values to prepopulate in profile page
  if (qrBusinessEmail !== "undefined" && qrBusinessEmail !== null) {
    response.formModel.data.myDeloitte.businessEmail = qrBusinessEmail;
  }
  if (company !== "undefined" && company !== null) {
    response.formModel.data.myDeloitte.company = company;
  }
  if (companyId !== "undefined" && companyId !== null) {
    response.formModel.data.myDeloitte.companyId = companyId;
  }
  if (industry !== "undefined" && industry !== null) {
    response.formModel.data.myDeloitte.industry = industry;
  }
  if (jobTitle !== "undefined" && jobTitle !== null) {
    response.formModel.data.myDeloitte.jobTitle = jobTitle;
  }
  if (jobFunction !== "undefined" && jobFunction !== null) {
    response.formModel.data.myDeloitte.function = jobFunction;
  }
  if (jobLevel !== "undefined" && jobLevel !== null) {
    response.formModel.data.myDeloitte.level = jobLevel;
  }
  if (
    response.form === "gigya-register-form" ||
    response.form === "gigya-profile-form"
  ) {
    if (
      !response.isVerified &&
      response.accountInfo !== undefined &&
      response.accountInfo.profile.lastName === undefined &&
      response.formModel.profile.lastName === undefined
    ) {
      response.formModel.profile.lastName = "Not provided";
      if (response.accountInfo.profile.firstName !== undefined) {
        response.formModel.profile.firstName =
          response.accountInfo.profile.firstName;
      }
    }
    

    response.formModel.data.myDeloitte.tou.date = new Date().toISOString();
    response.formModel.data.myDeloitte.tou.version = "1";
    /** Saving querystring value in regstate for Nocheck & Optin & Dbrief starts**/
    if (
      PAGE_URL.indexOf("action=optin") > -1 ||
      PAGE_URL.indexOf("eventid") > -1 ||
      mydaas_action !== ""
    ) {
      if (mydaasApp_ID !== "") {
        var mydaas = { tou: [] };
        mydaas.tou.push({ app: mydaasApp_ID, date: new Date().toISOString() });
        response.formModel.data.mydaas = mydaas;
      }
      var url_string =
        mydaasApp_ID !== "" ? PAGE_URL.split(domain) : PAGE_URL.split(".com");
      var queryString = url_string.pop();
      response.formModel.data.myDeloitte.regState = removeSpecialCharacters(
        queryString
      );
    }
    /** Saving querystring value in regstate for Nocheck & Optin & Dbrief ends**/

    if (
      sessionStorage.getItem("eventId") !== null &&
      sessionStorage.getItem("eventId") !== ""
    ) {
      var evnId = sessionStorage.getItem("eventId");
      response.formModel.data.myDeloitte.regState = removeSpecialCharacters(
        PAGE_URL + "&eventId=" + evnId
      );
    }
    /**Saving querystring value in regstate for Nocheck and capturing lead Source*/
    if (
      !(
        PAGE_URL.indexOf("action=optin") > -1 ||
        PAGE_URL.indexOf("eventid") > -1 ||
        mydaas_action !== ""
      ) &&
      localStorage.getItem("lSource") !== null &&
      localStorage.getItem("lSource") !== ""
    ) {
      response.formModel.data.myDeloitte.regState = removeSpecialCharacters(
        localStorage.getItem("lSource")
      );
    }
  }
  userEmail = response.formModel.email;
  /** Saving site string value in gigya while registrering from dcom join link strats from here **/

  var siteVal = readCookie("myD_siteSelector");

  if (siteVal === "null" || siteVal === "undefined" || !siteVal) {
    siteVal = "global-en";
  }
  response.formModel.data.myDeloitte.prefSite = siteVal;
  siteVal = encodeHTML(siteVal);
  /*Setting the myD_siteSelector cookie value to 1 year from the date of acceptence instead of 2099*/
	var expireDate = new Date();
	expireDate.setFullYear(expireDate.getFullYear() + 1); 
	var expires = "expires=" + expireDate.toUTCString();
  document.cookie =
    "myD_siteSelector=" +
    siteVal +
    "; expires= " + expires; "path=/; secure";

  /** Saving country info for the end user who is trying to register **/
  var countryInfo;
  if ($("#country-check").is(":checked")) {
    var countrytempInfo = getCookie("myD_siteSelector");
    countrytempInfo = countrytempInfo.substr(0, countrytempInfo.indexOf("-"));
    countryInfo = countrytempInfo.toUpperCase();
    if (countryInfo === "GLOBAL") {
      countryInfo = "ZZ";
    }
  } else {
    countryInfo = $("#country-config option:selected").val();
  }
  response.formModel.data.myDeloitte.country = countryInfo;
  /** Saving site string value in gigya while registrering from dcom strats ends here **/
}

// sets the GIGYA UID as cookie, if remember me option is selected to 1 year, else 30 min to default.
//VA: This needs to be revamped with Keep me logged changes. Need to be written inside registration-screen.js
function setRememberMecookie() {
  
  var rememberMe = localStorage.getItem("loggedIn");
  //Add cookie - if remember is set then 1 year else 30 mins
  var expireDate = new Date();
  if (rememberMe === "true") {
    
    expireDate.setFullYear(expireDate.getFullYear() + 1); // changing to 1 year as per coleen's request
  } else {
    expireDate.setMinutes(expireDate.getMinutes() + 30);
  }

  expires = "expires=" + expireDate.toUTCString();
}

//VA: should be a separate utility file as segragated function
function getSavedResponse(response) {
  if (
    sessionStorage.getItem("DBriefFlow") === "true" ||
    sessionStorage.getItem("DBriefFlow") === true
  ) {
    if (
      sessionStorage.getItem("eventId") !== null &&
      sessionStorage.getItem("eventId") !== ""
    ) {
      makeDbriefCall(JSON.parse(sessionStorage.getItem("response")));
    }
  }
  if (response.errorCode === 0) {
    var loginFrom = JSON.parse(sessionStorage.getItem("response"));
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(optInResp));
    if (localStorage.getItem("isRedirectToSub") === "true") {
      window.location.href = content_path + "/subscriptions.html";
    } else if (localStorage.getItem("isRedirectToAoi") === "true") {
      localStorage.removeItem("isRedirectToAoi");
      if (
        loginFrom.loginProvider !== "undefined" &&
        loginFrom.loginProvider === "site"
      ) {
        window.location.href =
          content_path + "/profile.html?icid=success_reg_email";
      } else {
        if (
          loginFrom.loginProvider !== "undefined" &&
          loginFrom.loginProvider !== "site"
        ) {
          window.location.href =
            content_path +
            "/profile.html?icid=success_reg_" +
            response.loginProvider;
        }
      }
    } else if (sessionStorage.getItem("DbriefSuccessMessage") !== null) {
      window.location.href = sessionStorage.getItem("DbriefSuccessMessage");
      localStorage.removeItem("notConsented");
    } else if (
      localStorage.getItem("isNewUser") === "true" &&
      (sessionStorage.getItem("eventId") !== null ||
        sessionStorage.getItem("eventId") === "")
    ) {
      localStorage.removeItem("isNewUser");
      if (
        loginFrom.loginProvider !== "undefined" &&
        loginFrom.loginProvider === "site"
      ) {
        window.location.href =
          content_path + "/profile.html?icid=success_reg_email";
      } else {
        if (
          loginFrom.loginProvider !== "undefined" &&
          loginFrom.loginProvider !== "site"
        ) {
          window.location.href =
            content_path +
            "/profile.html?icid=success_reg_" +
            loginFrom.loginProvider;
        }
      }
    } else if (
      (sessionStorage.getItem("isMyDaaSFlow") === "true" ||
        sessionStorage.getItem("mydaasflow") === "true") &&
      ((mydaas_postback_url && typeof mydaas_postback_url !== "undefined") ||
        sessionStorage.getItem("mydaas_postback_url"))
    ) {
      /** This function Redirects the MyDaas user from Gated to consumer app home screen**/
      post(mydaas_postback_url, resObj);
    } else {
      var redirectResponse = JSON.parse(sessionStorage.getItem("response"));
      if (
        redirectResponse.loginProvider !== "undefined" &&
        redirectResponse.loginProvider === "site"
      ) {
        
        window.location.href =
          content_path + "/dashboard.html?icid=success_signin_email";
      } else if (
        redirectResponse.loginProvider !== "undefined" &&
        redirectResponse.loginProvider !== "site"
      ) {
        window.location.href =
          content_path +
          "/dashboard.html?icid=success_signin_" +
          redirectResponse.loginProvider;
      } else {
        
        window.location.href = content_path + "/dashboard.html";
      }
    }
  }
  if (response.errorCode !== 0) {
    $("div.gigya-screen-loader-container").hide();
  }
}

//VA move to Dashboard script
var bookmarkResponse = JSON.parse(sessionStorage.getItem("response"));

//A function to save the bookmarked promos
//for the logged in user.
//VA move to Dashboard script
function sendBookmarkToGigya(promoID) {
  var currentTimeVal = new Date();
  var formattedDateVal = currentTimeVal.toISOString();
  var deselectedFlag = false;
  var myDeloitte = {
    bookmarks: [],
  };
  // This condition checks if existingAccountBookMarks[] is empty then it assign the existing bookmarks if any exist in the GIGYA response.
  if (typeof SOCIAL_PROFILE.data.myDeloitte !== "undefined" && typeof SOCIAL_PROFILE.data.myDeloitte.bookmarks !== "undefined"){
	   existingAccountBookMarks = SOCIAL_PROFILE.data.myDeloitte.bookmarks;
   }  

  // Looping through the existing bookmarks of the user and
  // populating the myDeloitte.bookmarks array with the same.
  for (var i = 0; i < existingAccountBookMarks.length; i++) {
    var obj = existingAccountBookMarks[i];
    if (promoID === obj.id) {
      // set deselected flag for the promo.
      deselectedFlag = true;
    } else {
      myDeloitte.bookmarks.push({
        id: obj.id,
        date: obj.date,
      });
    }
  }
  if (deselectedFlag !== true) {
    //Pushing the latest selected page on myfeed page.
    myDeloitte.bookmarks.push({
      id: promoID,
      date: formattedDateVal,
    });
  }

  var updatedBookmarks = existingAccountBookMarks;
  if (typeof updatedBookmarks !== "undefined") {
    updatedBookmarks = myDeloitte.bookmarks;
    SOCIAL_PROFILE.data.myDeloitte.bookmarks = updatedBookmarks;
    bookmarkResponse.data.myDeloitte.bookmarks = updatedBookmarks;
  } else {
    updatedBookmarks = myDeloitte.bookmarks;
  }

  var params = {
    data: {
      myDeloitte: {
        bookmarks: updatedBookmarks,
      },
    },
    callback: sendBookmarkToGigyaResponse,
  };
  gigya.accounts.setAccountInfo(params);
}

//A callback function to handle the response of
//bookmark save operation to gigya.
//VA: Move to Dashboard scripts
function sendBookmarkToGigyaResponse(response) {
  if (typeof response.errorCode !== "undefined" && response.errorCode === 0) {
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(bookmarkResponse));
    evalSession();
    
  } 
}

//VA: Move to profile/progressive page scripts
function fieldCompletionCheck(response) {
  if (
    typeof response.data.myDeloitte.country !== "undefined" &&
    response.data.myDeloitte.country.length > 0 &&
    typeof response.data.myDeloitte.industry !== "undefined" &&
    response.data.myDeloitte.industry.length > 0 &&
    typeof response.data.myDeloitte.function !== "undefined" &&
    response.data.myDeloitte.function.length > 0 &&
    typeof response.data.myDeloitte.jobTitle !== "undefined" &&
    response.data.myDeloitte.jobTitle.length > 0 &&
    typeof response.data.myDeloitte.company !== "undefined" &&
    response.data.myDeloitte.company.length > 0 &&
    typeof response.data.myDeloitte.consent !== "undefined" &&
    typeof response.data.myDeloitte.consent.profile !== "undefined"
  ) {
    return true;
  } else {
    return false;
  }
}
//VA: Move to QR scripts
function fieldCompletionCheckQR(response) {
  if (
    typeof response.data.myDeloitte.country !== "undefined" &&
    response.data.myDeloitte.country.length > 0 &&
    typeof response.data.myDeloitte.industry !== "undefined" &&
    response.data.myDeloitte.industry.length > 0 &&
    typeof response.data.myDeloitte.function !== "undefined" &&
    response.data.myDeloitte.function.length > 0 &&
    typeof response.data.myDeloitte.jobTitle !== "undefined" &&
    response.data.myDeloitte.jobTitle.length > 0 &&
    typeof response.data.myDeloitte.company !== "undefined" &&
    response.data.myDeloitte.company.length > 0 &&
    typeof response.data.myDeloitte.accountGroupId !== "undefined"
  ) {
    return true;
  } else {
    return false;
  }
}

//VA standard function to be moved as separate file or can be moved to head.html with sightly condition
function loadGigya() {
  if (typeof gigya === "undefined" || gigya === null) {
    
    var scriptForGigya = document.createElement("script");
    scriptForGigya.onload = function () {

    };

    scriptForGigya.onerror = function () {
      
    };
    scriptForGigya.type = "text/javascript";
    scriptForGigya.async = true;
    scriptForGigya.src =
      "https://cdns.gigya.com/js/gigya.js?apiKey=" +
      SOCIAL_API +
      "&services=socialize.share,accounts.screenset,socialize.shareCounts,socialize.simpleShare,socialize.reactions";
    
    if (mycdnlang === undefined || mycdnlang === null) {
       mycdnlang = "en";
    }
    scriptForGigya.text = "{lang: " + JSON.stringify(mycdnlang) + " }";
    document.getElementsByTagName("head")[0].appendChild(scriptForGigya);
  }
}

//VA: Move to optin and interest specific script
function updateLocalStorageWithAoisAndSubscriptions() {
  if (PAGE_URL && PAGE_URL.indexOf("action=optin") > -1) {
    if (PAGE_URL.indexOf("aoi=") > -1) {
      aoiKey = getparamNameMultiValuesFromURL("aoi");
      if (typeof [aoiKey !== "undefined"] && aoiKey !== "") {
        localStorage.setItem("aoiKey", aoiKey);
        localStorage.setItem("isRedirectToAoi", "true");
      }
    }
    if (PAGE_URL.indexOf("sub=") > -1) {
      subKey = getparamNameMultiValuesFromURL("sub");
      if (typeof [subKey !== "undefined"] && subKey !== "") {
        localStorage.setItem("subKey", subKey);
        localStorage.setItem("isRedirectToSub", "true");
      }
    }
  }
}

/** This function will call make the AJAX call for tagsforinterest only one time**/
//VA: Move to profile page
function makeRequestForTagsForInterests() {
  var siteLocale = myDelLocale.replace(/\//g, "_");
  var tagsArr = null;
  var urlpath = window.location.href.replace(
    window.location.pathname.substring(
      window.location.pathname.indexOf("."),
      window.location.pathname.lastIndexOf(".html")
    ),
    ""
  );
  var servletUrl =
    urlpath.substring(0, urlpath.lastIndexOf(".html")) +
    ".deloitte-tagsforinterests.json";
  $.ajax({
    async: false,
    global: false,
    url: servletUrl,
    data: {
      site: siteLocale,
    },
    dataType: "json",
    success: function (data) {
      tagsArr = data;
      sessionStorage.setItem("tagsforinterests", JSON.stringify(tagsArr));
    },
    error: function () {
    },
  });
}
/** Ends****/


/*========================================
//	optins.js 
//	------------
//
//	Contains optins flow with the gated screen 
//	and all other validations
//========================================*/

// configuring the module, using dependencies `$location` for redirects.

//VA: This should be moved Optin specific file
function sendOptinAccountDetailsToGigya() {
  var dunsnumber = "999999999";
  var emptyExists = false;
  var securedlocInfo = getCookie("myD_siteSelector");
  var source = null;
  var isOptinReceiveEmails = '';
  var profileFrequency = $("input[type='radio'][name='myDeloitte.consent.profileFreq']:checked").val();
  if(!profileFrequency) profileFrequency = '';
  if (securedlocInfo === "us-en") {
    source = "D&B";
  } else {
    source = "DB";
  }

  $(".form-field .bar").removeClass("error-field");
  $(".form-field p.error-msg").remove();
  $(".myD-gatedFlow-container p.error-msg").remove();
  if (
    $("#country-config").val() === "none" ||
    $("#country-config").val() === "" ||
    $("#country-config").val() == null
  )
    emptyExists = displayError($("#country-config"), emptyExists);
  if (!$.trim($("#company-name").val()))
    emptyExists = displayError($("#company-name"), emptyExists);
  if (!$("#job-function-in-professional").val())
    emptyExists = displayError($("#job-function-in-professional"), emptyExists);
  if (!$("#job-title").val())
    emptyExists = displayError($("#job-title"), emptyExists);
  if (
    localStorage.getItem("notConsented") === "true" &&
    sessionStorage.getItem("eventId") !== null &&
    sessionStorage.getItem("eventId") !== ""
  ) {
    if (!$("#dbrief-check").is(":checked"))
      emptyExists = displayError($("#dbrief-check"), emptyExists);
  }
  var resp = JSON.parse(sessionStorage.getItem("response"))
  if (sessionStorage.getItem("showmydaastou") === "true") {
    if (!$("#gigya-mydaas-tou").is(":checked")) {
      emptyExists = displayError($("#gigya-mydaas-tou"), emptyExists);
    }
  }

  if (!$("#industry-config-for-profile").val())
    emptyExists = displayError($("#industry-config-for-profile"), emptyExists);
  if ($(".myD-gatedFlow-container .form-radio input:radio:checked").length <= 0)
    $(".myD-gatedFlow-container .form-radio").append(
      "<p class='error-msg'>" + missingmandfielderror + "</p>"
    );
  function displayError(obj, emptyE) {
    $(obj).closest(".form-field").find(".bar").addClass("error-field");
    $(obj)
      .closest(".form-field")
      .append("<p class='error-msg'>" + missingmandfielderror + "</p>");
    if (emptyE === false) {
      emptyE = true;
      $(obj).focus();
    }
    return emptyE;
  }
  if ($("#gated-emails-yes").is(":checked")) {
    isOptinReceiveEmails = true;
  }
  if ($("#gated-emails-no").is(":checked")) {
    isOptinReceiveEmails = false;
  }
  if (sessionStorage.getItem("response") !== null) {
    var resObj = JSON.parse(sessionStorage.getItem("response"));
  }
  if (
    sessionStorage.getItem("DBriefFlow") === "true" ||
    sessionStorage.getItem("DBriefFlow") === true
  ) {
    if (
      sessionStorage.getItem("eventId") !== null &&
      sessionStorage.getItem("eventId") !== ""
    ) {
      if ($("#dbrief-check").is(":checked")) {
        updateConsent(JSON.parse(sessionStorage.getItem("response")));
      }
    }
  }

  // below function is for profile frequency validation for different screens
  validateProfileFrequency();

  // Save the profile page input values in localStorage
  if (resObj.data.myDeloitte !== undefined) {
    //Professional Details
    if (localStorage.getItem("DUNSNUMBER") != null) {
      dunsnumber = localStorage.getItem("DUNSNUMBER");
    } else if (
      typeof resObj.data.myDeloitte.companyId != "undefined" &&
      resObj.data.myDeloitte.companyId != null
    ) {
      if (resObj.data.myDeloitte.company === $("#company-name").val()) {
        dunsnumber = resObj.data.myDeloitte.companyId;
      }
    }
    resObj.data.myDeloitte.country = $("#country-config").val();
    resObj.data.myDeloitte.zip = $("#zip").val();
    resObj.data.myDeloitte.industry = $("#industry-config-for-profile").val();
    resObj.data.myDeloitte.company = $("#company-name").val();
    resObj.data.myDeloitte.jobTitle = $("#job-title").val();
    resObj.data.myDeloitte.function = $("#job-function-in-professional").val();
    resObj.data.myDeloitte.companyId = dunsnumber;
    resObj.data.myDeloitte.companySource = source;
    resObj.data.myDeloitte.prefSite = securedlocInfo;

    if (resObj.data.myDeloitte.consent === undefined) {
      resObj.data.myDeloitte.consent = {};
    }
    resObj.data.myDeloitte.consent.profile = isOptinReceiveEmails;
    resObj.data.myDeloitte.consent.profileFreq = profileFrequency;
     optInResp = resObj;
  }

  //MYDAAS: if mydaas flow then create new array for appid or update existing in response
  if (
    sessionStorage.getItem("mydaasflow") === "true" &&
    sessionStorage.getItem("showmydaastou") === "true"
  ) {
    var mydaastou = setTOUonGatedLoginSubmit(resObj);
  }

  var dataDetailsJSON = {
    "myDeloitte.country": resObj.data.myDeloitte.country,
    "myDeloitte.industry": resObj.data.myDeloitte.industry,
    "myDeloitte.function": resObj.data.myDeloitte.function,
    "myDeloitte.company": resObj.data.myDeloitte.company,
    "myDeloitte.prefSite": resObj.data.myDeloitte.prefSite,
    "myDeloitte.jobTitle": resObj.data.myDeloitte.jobTitle,
    "myDeloitte.consent.profile": isOptinReceiveEmails,
    "myDeloitte.consent.profileFreq": profileFrequency,
    "myDeloitte.consent.profileDate": returnProfileConsentDate(
      isOptinReceiveEmails
    ).replace(/"/g, ""),
    "myDeloitte.companySource": source,
    "myDeloitte.companyId": resObj.data.myDeloitte.companyId,
  };
  if (
    isOptinReceiveEmails === true &&
    resObj.data.myDeloitte.consent !== undefined &&
    resObj.data.myDeloitte.consent.fullUnsubscribe !== undefined &&
    resObj.data.myDeloitte.consent.fullUnsubscribe === true
  ) {
    resObj.data.myDeloitte.consent.fullUnsubscribe = false;
    dataDetailsJSON = {
      "myDeloitte.country": resObj.data.myDeloitte.country,
      "myDeloitte.industry": resObj.data.myDeloitte.industry,
      "myDeloitte.function": resObj.data.myDeloitte.function,
      "myDeloitte.company": resObj.data.myDeloitte.company,
      "myDeloitte.prefSite": resObj.data.myDeloitte.prefSite,
      "myDeloitte.jobTitle": resObj.data.myDeloitte.jobTitle,
      "myDeloitte.consent.fullUnsubscribe": false,
      "myDeloitte.consent.profile": isOptinReceiveEmails,
      "myDeloitte.consent.profileFreq": profileFrequency,
      "myDeloitte.consent.profileDate": returnProfileConsentDate(
        isOptinReceiveEmails
      ).replace(/"/g, ""),
      "myDeloitte.companySource": source,
      "myDeloitte.companyId": resObj.data.myDeloitte.companyId,
    };

    if (
      sessionStorage.getItem("DBriefFlow") === "true" &&
      localStorage.getItem("notConsented") === "true" &&
      localStorage.getItem("isNewUser") === "true"
    ) {
      dataDetailsJSON = {
        "myDeloitte.country": resObj.data.myDeloitte.country,
        "myDeloitte.industry": resObj.data.myDeloitte.industry,
        "myDeloitte.function": resObj.data.myDeloitte.function,
        "myDeloitte.company": resObj.data.myDeloitte.company,
        "myDeloitte.prefSite": resObj.data.myDeloitte.prefSite,
        "myDeloitte.jobTitle": resObj.data.myDeloitte.jobTitle,
        "myDeloitte.consent.fullUnsubscribe": false,
        "myDeloitte.consent.profile": isOptinReceiveEmails,
        "myDeloitte.consent.profileFreq": profileFrequency,
        "myDeloitte.consent.profileDate": returnProfileConsentDate(
          isOptinReceiveEmails
        ).replace(/"/g, ""),
        "myDeloitte.consent.eventInfoDate": new Date().toISOString(),
        "myDeloitte.companySource": source,
        "myDeloitte.companyId": resObj.data.myDeloitte.companyId,
      };
    }
  }
  if (
    sessionStorage.getItem("mydaasflow") === "true" &&
    sessionStorage.getItem("showmydaastou") === "true"
  ) {
    //Setting TOU for user trying to login for MyDaas flow for new and existing users

    dataDetailsJSON = {
      "myDeloitte.country": resObj.data.myDeloitte.country,
      "myDeloitte.industry": resObj.data.myDeloitte.industry,
      "myDeloitte.function": resObj.data.myDeloitte.function,
      "myDeloitte.company": resObj.data.myDeloitte.company,
      "myDeloitte.prefSite": resObj.data.myDeloitte.prefSite,
      "myDeloitte.jobTitle": resObj.data.myDeloitte.jobTitle,
      "myDeloitte.consent.profile": isOptinReceiveEmails,
      "myDeloitte.consent.profileFreq": profileFrequency,
      "myDeloitte.consent.profileDate": returnProfileConsentDate(
        isOptinReceiveEmails
      ).replace(/"/g, ""),
      "myDeloitte.companySource": source,
      "mydaas.tou": mydaastou,
      "myDeloitte.companyId": resObj.data.myDeloitte.companyId,
    };
  }

  var params = {
    data: dataDetailsJSON,
    apiKey: SOCIAL_API,
    UID: SOCIAL_PROFILE_UID,
    callback: getSavedResponse,
  };
  if (!$(".error-msg").length) {
    localStorage.removeItem("DUNSNUMBER");
    $("div.gigya-screen-loader-container").show();
    gigya.accounts.setAccountInfo(params);
  }
}

function gatGatedFloeUserDetailsCheckQR(response) {
var touDiff = Math.abs(new Date() - new Date(response.data.myDeloitte.tou.date));
      var touDiffInsec = touDiff/(1000);
      if(touDiffInsec >20){
	if (!IS_NEW_USER 
			&& response.data.mydaas !== undefined 
			&& response.data.mydaas.tou !== undefined && response.data.mydaas.tou[0] !== undefined
			&& response.data.mydaas.tou[0].date && checkAppExistOrNot(sessionStorage.getItem("appid"), response.data.mydaas.tou)
    		&& (response.data.myDeloitte.consent.profile == false || (response.data.myDeloitte.consent.profile== true && OPTIN_EMAIL_NOTIFICATION !== 'true') ||(response.data.myDeloitte.consent.profile== true && OPTIN_EMAIL_NOTIFICATION === 'true' && (response.data.myDeloitte.consent.profileFreq != "" && (response.data.myDeloitte.consent.profileFreq !="undefined" && response.data.myDeloitte.consent.profileFreq !=undefined))))
			&& ((mydaas_postback_url && typeof mydaas_postback_url !== "undefined") || sessionStorage.getItem("mydaas_postback_url"))) {
		return true;
	}} else {
		return false;
	}
	
}
function checkAppExistOrNot(value,touJSON){
	var hasMatch =false;
	for (var index = 0; index < touJSON.length; ++index) {
	 var apps = touJSON[index];
	 if(apps.app == value){
	   hasMatch = true;
	   break;
	 }
	}
	 return hasMatch;
	}
/**This function validates the value of regState is valid or not code starts from here **/
//VA: Move to optin and interest specific script
function isOptinOrDbriefOrMyDaaSUser(response) {
  if (
    response.data.myDeloitte.regState &&
    (response.data.myDeloitte.regState.indexOf("action=optin") > -1 ||
      response.data.myDeloitte.regState.indexOf("eventid") > -1 ||
      response.data.myDeloitte.regState.indexOf("mydaas") > -1)
  ) {
    return true;
  } else if (
    PAGE_URL &&
    (PAGE_URL.indexOf("action=optin") > -1 || PAGE_URL.indexOf("eventid") > -1)
  ) {
    return true;
  } else {
    return false;
  }
}
/**This function validates the value of regState is valid or not code ends here **/

function toggleGatedProfileFrequencyDisplay(){
  // show frequency section if email yes selected
  if($('input#gated-emails-yes').is(':checked')){
    $(".profileFreq").removeClass('d-none');
  }
  // toggle display on change
  $('input[name="myDeloitte.consent.profile"]').click(function () {
    if(this.id === "gated-emails-yes"){
      $(".profileFreq").removeClass('d-none');
    }
    else if(this.id === "gated-emails-no"){
      $(".profileFreq").addClass('d-none');
      $("[name='myDeloitte.consent.profileFreq']").attr('checked', false); // reset radios
    }
  });
}
/*========================================
//	dbriefs.js 
//	------------
//
//	Contains dbrief flow with the gated screen 
//	and all other validations
//========================================*/

// Make Dbreif Call
function makeDbriefCall(response) {
  if (typeof response !== "undefined") {
    var origin = window.location.origin;
    var userId = response.UID;
    var signature = response.UIDSignature;
    var timeStamp = response.signatureTimestamp;
    sessionStorage.setItem("Dorigin", origin);
    sessionStorage.setItem("DuserId", userId);
    sessionStorage.setItem("Dsignature", signature);
    sessionStorage.setItem("DtimeStamp", timeStamp);
    if (
      sessionStorage.getItem("eventId") !== null &&
      sessionStorage.getItem("eventId") !== ""
    ) {
      sessionStorage.setItem("DeventId", sessionStorage.getItem("eventId"));
    }
    sessionStorage.setItem(
      "DFirstTimeUser",
      sessionStorage.getItem("FirstTimeUser")
    );
  }
  if (
    typeof response !== "undefined" &&
    sessionStorage.getItem("DuserId") != null
  ) {
    dbreif_params = {
      origin: sessionStorage.getItem("Dorigin"),
      eventid: sessionStorage.getItem("eventId"),
      uid: sessionStorage.getItem("DuserId"),
      signature: sessionStorage.getItem("Dsignature"),
      timestamp: sessionStorage.getItem("DtimeStamp"),
    };
    evalDbriefs(JSON.stringify(dbreif_params));
  }
}

/**retryDbriefCall is called after clicking retry button on POPUP which comes when any boomi error occurs   **/
function retryDbriefCall() {
  // showing the spinner on modal
  $(".gigya-screen-loader-container").show();
  sessionStorage.removeItem("DbriefErrorMessage");
  localStorage.removeItem("DbriefErrorMessage");
  sessionStorage.removeItem("DbriefSuccessMessage");
  localStorage.removeItem("DbriefSuccessMessage");
  dbreif_params = {
    origin: sessionStorage.getItem("Dorigin"),
    eventid: sessionStorage.getItem("eventId"),
    uid: sessionStorage.getItem("DuserId"),
    signature: sessionStorage.getItem("Dsignature"),
    timestamp: sessionStorage.getItem("DtimeStamp"),
  };
  evalDbriefs(JSON.stringify(dbreif_params));
  // hiding the spinner on modal
  $(".gigya-screen-loader-container").hide();
  if (
    sessionStorage.getItem("DbriefSuccessMessage") != null ||
    localStorage.getItem("DbriefSuccessMessage") != null
  ) {
    window.location.href = sessionStorage.getItem("DbriefSuccessMessage");
  }
}

function evalDbriefs(dbreif_params) {
  //defining actualURL for DBrief invalidate event
  $.ajax({
    type: "POST",
    crossDomain: true,
    data: dbreif_params,
    url: eventURL,
    async: false,
    headers: {
    "content-type": "application/json",
    "authorization": "Basic "+window.btoa(clientApiUsername+":"+clientApiPassword)
  },
    success: function (data) {
      // adding debug logs
      console.log("DBRF_ERR_MSG", data.errorMessage);
      if (data.eventURL.length === 0) {
        if (data.errorMessage != null) {
          sessionStorage.setItem("DbriefErrorMessage", data.errorMessage);
          localStorage.setItem("DbriefErrorMessage", data.errorMessage);
        }
      }
      if (data.eventURL.length > 0) {
        if (localStorage.getItem("isNewUser") === "true") {
          try {
            _satellite.track("dbriefsRegisterSuccess");
          } catch (e) {
            console.log("no call to AA for success dbs registration");
          }
        } else {
          try {
            _satellite.track("dbriefsSigninSuccess");
          } catch (e) {
            console.log("no call to AA for success dbs");
          }
        }
        var redirect_to = data.eventURL;
        localStorage.setItem("Dbrief_return", true);
        sessionStorage.setItem("DbriefSuccessMessage", redirect_to);
        localStorage.setItem("DbriefSuccessMessage", redirect_to);
      }
    },
    error: function (request) {
      console.log("DBRF_ERR_MSG", request.statusText);
      sessionStorage.setItem("DbriefErrorMessage", "ERR006");
      localStorage.setItem("DbriefErrorMessage", "ERR006");
    },
  });
}

// dbrief helper functions
//If a Dbrief call is made, check if user-consent is true and valid < 365 days
//VA: Should be moved to Dbriefs specific script file
function checkForValidity(response) {
  if (typeof response !== "undefined") {
    if (typeof response.data.myDeloitte === "undefined") {
      response.data.myDeloitte = {};
    }
    if (typeof response.data.myDeloitte.consent === "undefined") {
      response.data.myDeloitte.consent = {};
    }
    //using session-storage to set 'notConsented' and 'diffDays'
    if (typeof response.data.myDeloitte.consent.eventInfoDate === "undefined") {
      response.data.myDeloitte.consent.eventInfoDate = {};
      localStorage.setItem("notConsented", "true");
    }
    if (typeof response.data.myDeloitte.consent.eventInfoDate !== "undefined") {
      if (response.data.myDeloitte.consent.eventInfoDate.length > 0) {
        var existingDate = parseDate(
          response.data.myDeloitte.consent.eventInfoDate
        );
        var newDate = new Date();
        var diffDays = newDate - existingDate;
        localStorage.setItem(
          "diffDays",
          parseInt(diffDays / (24 * 3600 * 1000))
        );
        if (localStorage.getItem("diffDays") > 365) {
          localStorage.setItem("notConsented", "true");
        }
      }
    }
  }
}

//VA: Should be moved to Dbriefs specific script file
function updateConsent(response) {
  if (typeof response !== "undefined") {
    var eventParam = {
      "myDeloitte.consent.eventInfoDate": new Date().toISOString(),
    };
    var params = {
      data: eventParam,
      apiKey: SOCIAL_API,
      UID: response.UID,
      callback: eventDateResponse,
    };
    gigya.accounts.setAccountInfo(params);
  }
}

//VA: Should be moved to Dbriefs specific script file
function eventDateResponse(response) {
  if (typeof response.errorCode !== "undefined" && response.errorCode === 0) {
  }
}

/*========================================
//	sessionHelper.js 
//	------------
//
//	 add your session related methods if any below
//========================================*/

// checks the availability of gigay and resolves as a promise if true
function gigyaIsSet() {
  return new Promise(function (resolve, reject) {
    var waitForGigya = function () {
      try {
        if (gigya) return resolve(gigya);
        setTimeout(waitForGigya, 30);
      } catch (e) {
        setTimeout(waitForGigya, 30);
      }
    };
    waitForGigya();
  });
}

// checks and returns response as a promise
function getSessionResponse() {
  return new Promise(function (resolve, reject) {
    gigyaIsSet().then(function (gigya) {
      var sessionResponse = sessionStorage.getItem("response");
      if (sessionResponse === null || sessionResponse === undefined) {
        gigya.accounts.getAccountInfo({
          callback: function (res) {
            if (res.errorCode === 0) {
              sessionStorage.setItem("response", JSON.stringify(res));
              resolve(res);
            }
          },
        });
      } else {
        resolve(JSON.parse(sessionResponse));
      }
    });
  });
}

// A function to prepare Interests and their associated Tags for the
// logged in user.
//VA move to profile page script
function prepareInterestsAndTagsListFromGigya(socialProfileObject) {
  if (
    socialProfileObject != null &&
    socialProfileObject.data != null &&
    socialProfileObject.data.myDeloitte
  ) {
    populateInterestsAndTags(socialProfileObject);
  }
}

//A low level function to prepare Interests and
//their associated Tags for the
//logged in user.
//VA: Move to profile page scripts
function populateInterestsAndTags(response) {
  var existingInterests = fillExistingInterests(response);
  var siteLocale = myDelLocale.replace(/\//g, "_");

  // tagsjson - If it exist,take from session storage else make a servlet call and set it in session storage
  var tagsjson = JSON.parse(sessionStorage.getItem("tagsjson"));

  if (tagsjson == null) {
    var urlpath = window.location.href.replace(
      window.location.pathname.substring(
        window.location.pathname.indexOf("."),
        window.location.pathname.lastIndexOf(".html")
      ),
      ""
    );
    var servletUrl = urlpath.substring(0, urlpath.lastIndexOf(".html")) + ".deloitte-tagsforinterests.json";

    // servlet call to get and update tagsjson in session storage
    $.ajax({
      async: false,
      global: false,
      url: servletUrl,
      data: {
        site: siteLocale,
      },
      dataType: "json",
      success: function (data) {
        tagsjson = data;
        sessionStorage.setItem("tagsjson", JSON.stringify(data));
      },
      error: function () {
        console.log("Call to Tags for Interests servlet failed ...");
      },
    });
  }

  var interestsSelected = [];
  var tagsAdded = "";

  if (existingInterests !== undefined && existingInterests.length !== 0) {
    var str_array = existingInterests;

    for (var i = 0; i < str_array.length; i++) {
      // Trim the excess whitespace.
      str_array[i] = str_array[i].replace(/^\s*/, "").replace(/\s*$/, "");
      interestsSelected.push(str_array[i]);
    }
  }

  var interestsSelectedDetails;
  /*Fetching user selected interests details for dashboard page*/
  if (null != tagsjson) {
    interestsSelectedDetails = tagsjson.filter(function (item) {
      return interestsSelected.indexOf(item.text) !== -1;
    });
  }
  var interestsDetails = JSON.stringify(interestsSelectedDetails);
  sessionStorage.setItem("interestsDetails", interestsDetails);
  /*Fetching user selected interests details for dashboard page ends*/
  for (i = 0; i < interestsSelected.length; i++) {
    $.each(tagsjson, function (index) {
      if (strcmp(interestsSelected[i], tagsjson[index].text) === 0) {
        if (tagsjson[index].value !== "") {
          tagsAdded = tagsAdded + tagsjson[index].value + ",";
        }
        return false;
      }
    });
  }

  tagsAdded = tagsAdded.replace("/,s*$/", "");
  tagsAdded = tagsAdded.substring(0, tagsAdded.length - 1);
  var userAddedTags = tagsAdded.split(",");
  prepareRecData(interestsSelected, userAddedTags);
}

// Retrive interests or subscriptions from gigya
//VA: Move to profile page scripts
function getInterestsAndSubscriptions(response, intandsub) {
  var intandsubArray = [];
  var sitesArray = response.data.myDeloitte.sites;

  if (typeof sitesArray !== "undefined") {
    for (var i = 0; i < sitesArray.length; i++) {
      var obj = sitesArray[i];

      if (obj.site.replace("_", "-") === JSON.parse(site)) {
        if (intandsub === "interests") {
          intandsubArray = obj.interests;
        }
        if (intandsub === "subscriptions") {
          intandsubArray = obj.subscriptions;
        }
      }
    }
  }
  if (intandsubArray === undefined || intandsubArray === null) {
    intandsubArray = [];
  }
  return intandsubArray;
}

//A function to populate the user's existing interests.
//VA move to profile page script
function fillExistingInterests(SOCIAL_PROFILE) {
  if (
    SOCIAL_PROFILE != null &&
    SOCIAL_PROFILE.data != null &&
    SOCIAL_PROFILE.data.myDeloitte.sites
  ) {
    existingInterests = getInterestsAndSubscriptions(
      SOCIAL_PROFILE,
      "interests"
    );
    return existingInterests;
  }
}

// VA move to profile page script
// function to set profile interests and profile tags in local storage
function prepareRecData(interestsArray, tagsArray) {
  if (tagsArray !== undefined) {
    localStorage.setItem("profileTagsForSNP", tagsArray.toString());
  }

  if (interestsArray !== undefined) {
    localStorage.setItem("profileInterestsForSNP", interestsArray.toString());
  }
}

// window reference for global cookie compliance functions
function OptanonWrapper() {

  //if site selector comes before optanon banner  or if we have 404 page then close the cookie consent modal
  if($("#modal-site-confirm-language").hasClass("show") || $(".page-not-found").length >= 1){
    //  closing optanon modal
    $(".onetrust-pc-dark-filter, #onetrust-pc-sdk, #onetrust-banner-sdk").hide();   
  }

  // Hide the Modal consent when the country selector modal is popped up
  $("#modal-site-confirm-language").on('shown.bs.modal',function(){
    // closing optanon modal
    $(".onetrust-pc-dark-filter, #onetrust-pc-sdk, #onetrust-banner-sdk").hide(); 
  })


  // removing keep me login cookies if functional cookies not accepted
  if(OptanonActiveGroups.indexOf(3) < 1){
    document.cookie = "KEEP_ME_LOGIN= ; expires = Thu, 01 Jan 1970 00:00:00 GMT;domain=.deloitte.com;path=/";
  }

  setConsentShareCookie();
  window.cookieComplianceHelperJS = new (function () {
    var __proto__ = this.__proto__;

    // checks cookie category in optanon active groups list
    __proto__.isCookieCategorySelected = function (category) {
      var categories = OptanonActiveGroups;
      return categories.indexOf(category) > -1;
    };

    // toggles preference center using optanon API
    __proto__.togglePreferenceCenter = function () {
      Optanon.ToggleInfoDisplay();
    };
  })();

  // global class event for onetrust button preference center
  $(".onetrust-pc-btn-handler").on(
    "click",
    cookieComplianceHelperJS.togglePreferenceCenter
  );

  $(".optanon-show-settings").on(
    "click",
    Optanon.ToggleInfoDisplay
  );
  

  //trigger custom event
  $(document).trigger("OTReady");
}

/* This change is for refreshing the page whenever anyone clicks on 'Save All' or 'Change Settings' on cookie Consent Popup*/
$("body").on(
  "click",
  ".save-preference-btn-handler.onetrust-close-btn-handler, .ot-pc-refuse-all-handler, #accept-recommended-btn-handler, #onetrust-accept-btn-handler, #onetrust-reject-all-handler, .optanon-button-wrapper.optanon-save-settings-button, .optanon-button-wrapper.optanon-allow-all-button, .optanon-allow-all.accept-cookies-button,.accept-cookies-button",
  function () {
    if(pagetype === "accountsettings"){
      window.location.hash =  "settings";
    }
      window.location.reload();
    
    
  }
);


/*
 Copyright (C) Federico Zivolo 2017
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */(function(e,t){'object'==typeof exports&&'undefined'!=typeof module?module.exports=t():'function'==typeof define&&define.amd?define(t):e.Popper=t()})(this,function(){'use strict';function e(e){return e&&'[object Function]'==={}.toString.call(e)}function t(e,t){if(1!==e.nodeType)return[];var o=getComputedStyle(e,null);return t?o[t]:o}function o(e){return'HTML'===e.nodeName?e:e.parentNode||e.host}function n(e){if(!e)return document.body;switch(e.nodeName){case'HTML':case'BODY':return e.ownerDocument.body;case'#document':return e.body;}var i=t(e),r=i.overflow,p=i.overflowX,s=i.overflowY;return /(auto|scroll)/.test(r+s+p)?e:n(o(e))}function r(e){var o=e&&e.offsetParent,i=o&&o.nodeName;return i&&'BODY'!==i&&'HTML'!==i?-1!==['TD','TABLE'].indexOf(o.nodeName)&&'static'===t(o,'position')?r(o):o:e?e.ownerDocument.documentElement:document.documentElement}function p(e){var t=e.nodeName;return'BODY'!==t&&('HTML'===t||r(e.firstElementChild)===e)}function s(e){return null===e.parentNode?e:s(e.parentNode)}function d(e,t){if(!e||!e.nodeType||!t||!t.nodeType)return document.documentElement;var o=e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_FOLLOWING,i=o?e:t,n=o?t:e,a=document.createRange();a.setStart(i,0),a.setEnd(n,0);var l=a.commonAncestorContainer;if(e!==l&&t!==l||i.contains(n))return p(l)?l:r(l);var f=s(e);return f.host?d(f.host,t):d(e,s(t).host)}function a(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:'top',o='top'===t?'scrollTop':'scrollLeft',i=e.nodeName;if('BODY'===i||'HTML'===i){var n=e.ownerDocument.documentElement,r=e.ownerDocument.scrollingElement||n;return r[o]}return e[o]}function l(e,t){var o=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=a(t,'top'),n=a(t,'left'),r=o?-1:1;return e.top+=i*r,e.bottom+=i*r,e.left+=n*r,e.right+=n*r,e}function f(e,t){var o='x'===t?'Left':'Top',i='Left'==o?'Right':'Bottom';return parseFloat(e['border'+o+'Width'],10)+parseFloat(e['border'+i+'Width'],10)}function m(e,t,o,i){return J(t['offset'+e],t['scroll'+e],o['client'+e],o['offset'+e],o['scroll'+e],ie()?o['offset'+e]+i['margin'+('Height'===e?'Top':'Left')]+i['margin'+('Height'===e?'Bottom':'Right')]:0)}function h(){var e=document.body,t=document.documentElement,o=ie()&&getComputedStyle(t);return{height:m('Height',e,t,o),width:m('Width',e,t,o)}}function c(e){return se({},e,{right:e.left+e.width,bottom:e.top+e.height})}function g(e){var o={};if(ie())try{o=e.getBoundingClientRect();var i=a(e,'top'),n=a(e,'left');o.top+=i,o.left+=n,o.bottom+=i,o.right+=n}catch(e){}else o=e.getBoundingClientRect();var r={left:o.left,top:o.top,width:o.right-o.left,height:o.bottom-o.top},p='HTML'===e.nodeName?h():{},s=p.width||e.clientWidth||r.right-r.left,d=p.height||e.clientHeight||r.bottom-r.top,l=e.offsetWidth-s,m=e.offsetHeight-d;if(l||m){var g=t(e);l-=f(g,'x'),m-=f(g,'y'),r.width-=l,r.height-=m}return c(r)}function u(e,o){var i=ie(),r='HTML'===o.nodeName,p=g(e),s=g(o),d=n(e),a=t(o),f=parseFloat(a.borderTopWidth,10),m=parseFloat(a.borderLeftWidth,10),h=c({top:p.top-s.top-f,left:p.left-s.left-m,width:p.width,height:p.height});if(h.marginTop=0,h.marginLeft=0,!i&&r){var u=parseFloat(a.marginTop,10),b=parseFloat(a.marginLeft,10);h.top-=f-u,h.bottom-=f-u,h.left-=m-b,h.right-=m-b,h.marginTop=u,h.marginLeft=b}return(i?o.contains(d):o===d&&'BODY'!==d.nodeName)&&(h=l(h,o)),h}function b(e){var t=e.ownerDocument.documentElement,o=u(e,t),i=J(t.clientWidth,window.innerWidth||0),n=J(t.clientHeight,window.innerHeight||0),r=a(t),p=a(t,'left'),s={top:r-o.top+o.marginTop,left:p-o.left+o.marginLeft,width:i,height:n};return c(s)}function w(e){var i=e.nodeName;return'BODY'===i||'HTML'===i?!1:'fixed'===t(e,'position')||w(o(e))}function y(e,t,i,r){var p={top:0,left:0},s=d(e,t);if('viewport'===r)p=b(s);else{var a;'scrollParent'===r?(a=n(o(t)),'BODY'===a.nodeName&&(a=e.ownerDocument.documentElement)):'window'===r?a=e.ownerDocument.documentElement:a=r;var l=u(a,s);if('HTML'===a.nodeName&&!w(s)){var f=h(),m=f.height,c=f.width;p.top+=l.top-l.marginTop,p.bottom=m+l.top,p.left+=l.left-l.marginLeft,p.right=c+l.left}else p=l}return p.left+=i,p.top+=i,p.right-=i,p.bottom-=i,p}function E(e){var t=e.width,o=e.height;return t*o}function v(e,t,o,i,n){var r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===e.indexOf('auto'))return e;var p=y(o,i,r,n),s={top:{width:p.width,height:t.top-p.top},right:{width:p.right-t.right,height:p.height},bottom:{width:p.width,height:p.bottom-t.bottom},left:{width:t.left-p.left,height:p.height}},d=Object.keys(s).map(function(e){return se({key:e},s[e],{area:E(s[e])})}).sort(function(e,t){return t.area-e.area}),a=d.filter(function(e){var t=e.width,i=e.height;return t>=o.clientWidth&&i>=o.clientHeight}),l=0<a.length?a[0].key:d[0].key,f=e.split('-')[1];return l+(f?'-'+f:'')}function O(e,t,o){var i=d(t,o);return u(o,i)}function L(e){var t=getComputedStyle(e),o=parseFloat(t.marginTop)+parseFloat(t.marginBottom),i=parseFloat(t.marginLeft)+parseFloat(t.marginRight),n={width:e.offsetWidth+i,height:e.offsetHeight+o};return n}function x(e){var t={left:'right',right:'left',bottom:'top',top:'bottom'};return e.replace(/left|right|bottom|top/g,function(e){return t[e]})}function S(e,t,o){o=o.split('-')[0];var i=L(e),n={width:i.width,height:i.height},r=-1!==['right','left'].indexOf(o),p=r?'top':'left',s=r?'left':'top',d=r?'height':'width',a=r?'width':'height';return n[p]=t[p]+t[d]/2-i[d]/2,n[s]=o===s?t[s]-i[a]:t[x(s)],n}function T(e,t){return Array.prototype.find?e.find(t):e.filter(t)[0]}function D(e,t,o){if(Array.prototype.findIndex)return e.findIndex(function(e){return e[t]===o});var i=T(e,function(e){return e[t]===o});return e.indexOf(i)}function C(t,o,i){var n=void 0===i?t:t.slice(0,D(t,'name',i));return n.forEach(function(t){t['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var i=t['function']||t.fn;t.enabled&&e(i)&&(o.offsets.popper=c(o.offsets.popper),o.offsets.reference=c(o.offsets.reference),o=i(o,t))}),o}function N(){if(!this.state.isDestroyed){var e={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};e.offsets.reference=O(this.state,this.popper,this.reference),e.placement=v(this.options.placement,e.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),e.originalPlacement=e.placement,e.offsets.popper=S(this.popper,e.offsets.reference,e.placement),e.offsets.popper.position='absolute',e=C(this.modifiers,e),this.state.isCreated?this.options.onUpdate(e):(this.state.isCreated=!0,this.options.onCreate(e))}}function k(e,t){return e.some(function(e){var o=e.name,i=e.enabled;return i&&o===t})}function W(e){for(var t=[!1,'ms','Webkit','Moz','O'],o=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<t.length-1;n++){var i=t[n],r=i?''+i+o:e;if('undefined'!=typeof document.body.style[r])return r}return null}function P(){return this.state.isDestroyed=!0,k(this.modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.left='',this.popper.style.position='',this.popper.style.top='',this.popper.style[W('transform')]=''),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}function B(e){var t=e.ownerDocument;return t?t.defaultView:window}function H(e,t,o,i){var r='BODY'===e.nodeName,p=r?e.ownerDocument.defaultView:e;p.addEventListener(t,o,{passive:!0}),r||H(n(p.parentNode),t,o,i),i.push(p)}function A(e,t,o,i){o.updateBound=i,B(e).addEventListener('resize',o.updateBound,{passive:!0});var r=n(e);return H(r,'scroll',o.updateBound,o.scrollParents),o.scrollElement=r,o.eventsEnabled=!0,o}function I(){this.state.eventsEnabled||(this.state=A(this.reference,this.options,this.state,this.scheduleUpdate))}function M(e,t){return B(e).removeEventListener('resize',t.updateBound),t.scrollParents.forEach(function(e){e.removeEventListener('scroll',t.updateBound)}),t.updateBound=null,t.scrollParents=[],t.scrollElement=null,t.eventsEnabled=!1,t}function R(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=M(this.reference,this.state))}function U(e){return''!==e&&!isNaN(parseFloat(e))&&isFinite(e)}function Y(e,t){Object.keys(t).forEach(function(o){var i='';-1!==['width','height','top','right','bottom','left'].indexOf(o)&&U(t[o])&&(i='px'),e.style[o]=t[o]+i})}function j(e,t){Object.keys(t).forEach(function(o){var i=t[o];!1===i?e.removeAttribute(o):e.setAttribute(o,t[o])})}function F(e,t,o){var i=T(e,function(e){var o=e.name;return o===t}),n=!!i&&e.some(function(e){return e.name===o&&e.enabled&&e.order<i.order});if(!n){var r='`'+t+'`';console.warn('`'+o+'`'+' modifier is required by '+r+' modifier in order to work, be sure to include it before '+r+'!')}return n}function K(e){return'end'===e?'start':'start'===e?'end':e}function q(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],o=ae.indexOf(e),i=ae.slice(o+1).concat(ae.slice(0,o));return t?i.reverse():i}function V(e,t,o,i){var n=e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),r=+n[1],p=n[2];if(!r)return e;if(0===p.indexOf('%')){var s;switch(p){case'%p':s=o;break;case'%':case'%r':default:s=i;}var d=c(s);return d[t]/100*r}if('vh'===p||'vw'===p){var a;return a='vh'===p?J(document.documentElement.clientHeight,window.innerHeight||0):J(document.documentElement.clientWidth,window.innerWidth||0),a/100*r}return r}function z(e,t,o,i){var n=[0,0],r=-1!==['right','left'].indexOf(i),p=e.split(/(\+|\-)/).map(function(e){return e.trim()}),s=p.indexOf(T(p,function(e){return-1!==e.search(/,|\s/)}));p[s]&&-1===p[s].indexOf(',')&&console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');var d=/\s*,\s*|\s+/,a=-1===s?[p]:[p.slice(0,s).concat([p[s].split(d)[0]]),[p[s].split(d)[1]].concat(p.slice(s+1))];return a=a.map(function(e,i){var n=(1===i?!r:r)?'height':'width',p=!1;return e.reduce(function(e,t){return''===e[e.length-1]&&-1!==['+','-'].indexOf(t)?(e[e.length-1]=t,p=!0,e):p?(e[e.length-1]+=t,p=!1,e):e.concat(t)},[]).map(function(e){return V(e,n,t,o)})}),a.forEach(function(e,t){e.forEach(function(o,i){U(o)&&(n[t]+=o*('-'===e[i-1]?-1:1))})}),n}function G(e,t){var o,i=t.offset,n=e.placement,r=e.offsets,p=r.popper,s=r.reference,d=n.split('-')[0];return o=U(+i)?[+i,0]:z(i,p,s,d),'left'===d?(p.top+=o[0],p.left-=o[1]):'right'===d?(p.top+=o[0],p.left+=o[1]):'top'===d?(p.left+=o[0],p.top-=o[1]):'bottom'===d&&(p.left+=o[0],p.top+=o[1]),e.popper=p,e}for(var _=Math.min,X=Math.floor,J=Math.max,Q='undefined'!=typeof window&&'undefined'!=typeof document,Z=['Edge','Trident','Firefox'],$=0,ee=0;ee<Z.length;ee+=1)if(Q&&0<=navigator.userAgent.indexOf(Z[ee])){$=1;break}var i,te=Q&&window.Promise,oe=te?function(e){var t=!1;return function(){t||(t=!0,window.Promise.resolve().then(function(){t=!1,e()}))}}:function(e){var t=!1;return function(){t||(t=!0,setTimeout(function(){t=!1,e()},$))}},ie=function(){return void 0==i&&(i=-1!==navigator.appVersion.indexOf('MSIE 10')),i},ne=function(e,t){if(!(e instanceof t))throw new TypeError('Cannot call a class as a function')},re=function(){function e(e,t){for(var o,n=0;n<t.length;n++)o=t[n],o.enumerable=o.enumerable||!1,o.configurable=!0,'value'in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}return function(t,o,i){return o&&e(t.prototype,o),i&&e(t,i),t}}(),pe=function(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e},se=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var i in t=arguments[o],t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e},de=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'],ae=de.slice(3),le={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'},fe=function(){function t(o,i){var n=this,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};ne(this,t),this.scheduleUpdate=function(){return requestAnimationFrame(n.update)},this.update=oe(this.update.bind(this)),this.options=se({},t.Defaults,r),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=o&&o.jquery?o[0]:o,this.popper=i&&i.jquery?i[0]:i,this.options.modifiers={},Object.keys(se({},t.Defaults.modifiers,r.modifiers)).forEach(function(e){n.options.modifiers[e]=se({},t.Defaults.modifiers[e]||{},r.modifiers?r.modifiers[e]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(e){return se({name:e},n.options.modifiers[e])}).sort(function(e,t){return e.order-t.order}),this.modifiers.forEach(function(t){t.enabled&&e(t.onLoad)&&t.onLoad(n.reference,n.popper,n.options,t,n.state)}),this.update();var p=this.options.eventsEnabled;p&&this.enableEventListeners(),this.state.eventsEnabled=p}return re(t,[{key:'update',value:function(){return N.call(this)}},{key:'destroy',value:function(){return P.call(this)}},{key:'enableEventListeners',value:function(){return I.call(this)}},{key:'disableEventListeners',value:function(){return R.call(this)}}]),t}();return fe.Utils=('undefined'==typeof window?global:window).PopperUtils,fe.placements=de,fe.Defaults={placement:'bottom',eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(e){var t=e.placement,o=t.split('-')[0],i=t.split('-')[1];if(i){var n=e.offsets,r=n.reference,p=n.popper,s=-1!==['bottom','top'].indexOf(o),d=s?'left':'top',a=s?'width':'height',l={start:pe({},d,r[d]),end:pe({},d,r[d]+r[a]-p[a])};e.offsets.popper=se({},p,l[i])}return e}},offset:{order:200,enabled:!0,fn:G,offset:0},preventOverflow:{order:300,enabled:!0,fn:function(e,t){var o=t.boundariesElement||r(e.instance.popper);e.instance.reference===o&&(o=r(o));var i=y(e.instance.popper,e.instance.reference,t.padding,o);t.boundaries=i;var n=t.priority,p=e.offsets.popper,s={primary:function(e){var o=p[e];return p[e]<i[e]&&!t.escapeWithReference&&(o=J(p[e],i[e])),pe({},e,o)},secondary:function(e){var o='right'===e?'left':'top',n=p[o];return p[e]>i[e]&&!t.escapeWithReference&&(n=_(p[o],i[e]-('right'===e?p.width:p.height))),pe({},o,n)}};return n.forEach(function(e){var t=-1===['left','top'].indexOf(e)?'secondary':'primary';p=se({},p,s[t](e))}),e.offsets.popper=p,e},priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:function(e){var t=e.offsets,o=t.popper,i=t.reference,n=e.placement.split('-')[0],r=X,p=-1!==['top','bottom'].indexOf(n),s=p?'right':'bottom',d=p?'left':'top',a=p?'width':'height';return o[s]<r(i[d])&&(e.offsets.popper[d]=r(i[d])-o[a]),o[d]>r(i[s])&&(e.offsets.popper[d]=r(i[s])),e}},arrow:{order:500,enabled:!0,fn:function(e,o){var i;if(!F(e.instance.modifiers,'arrow','keepTogether'))return e;var n=o.element;if('string'==typeof n){if(n=e.instance.popper.querySelector(n),!n)return e;}else if(!e.instance.popper.contains(n))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),e;var r=e.placement.split('-')[0],p=e.offsets,s=p.popper,d=p.reference,a=-1!==['left','right'].indexOf(r),l=a?'height':'width',f=a?'Top':'Left',m=f.toLowerCase(),h=a?'left':'top',g=a?'bottom':'right',u=L(n)[l];d[g]-u<s[m]&&(e.offsets.popper[m]-=s[m]-(d[g]-u)),d[m]+u>s[g]&&(e.offsets.popper[m]+=d[m]+u-s[g]),e.offsets.popper=c(e.offsets.popper);var b=d[m]+d[l]/2-u/2,w=t(e.instance.popper),y=parseFloat(w['margin'+f],10),E=parseFloat(w['border'+f+'Width'],10),v=b-e.offsets.popper[m]-y-E;return v=J(_(s[l]-u,v),0),e.arrowElement=n,e.offsets.arrow=(i={},pe(i,m,Math.round(v)),pe(i,h,''),i),e},element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:function(e,t){if(k(e.instance.modifiers,'inner'))return e;if(e.flipped&&e.placement===e.originalPlacement)return e;var o=y(e.instance.popper,e.instance.reference,t.padding,t.boundariesElement),i=e.placement.split('-')[0],n=x(i),r=e.placement.split('-')[1]||'',p=[];switch(t.behavior){case le.FLIP:p=[i,n];break;case le.CLOCKWISE:p=q(i);break;case le.COUNTERCLOCKWISE:p=q(i,!0);break;default:p=t.behavior;}return p.forEach(function(s,d){if(i!==s||p.length===d+1)return e;i=e.placement.split('-')[0],n=x(i);var a=e.offsets.popper,l=e.offsets.reference,f=X,m='left'===i&&f(a.right)>f(l.left)||'right'===i&&f(a.left)<f(l.right)||'top'===i&&f(a.bottom)>f(l.top)||'bottom'===i&&f(a.top)<f(l.bottom),h=f(a.left)<f(o.left),c=f(a.right)>f(o.right),g=f(a.top)<f(o.top),u=f(a.bottom)>f(o.bottom),b='left'===i&&h||'right'===i&&c||'top'===i&&g||'bottom'===i&&u,w=-1!==['top','bottom'].indexOf(i),y=!!t.flipVariations&&(w&&'start'===r&&h||w&&'end'===r&&c||!w&&'start'===r&&g||!w&&'end'===r&&u);(m||b||y)&&(e.flipped=!0,(m||b)&&(i=p[d+1]),y&&(r=K(r)),e.placement=i+(r?'-'+r:''),e.offsets.popper=se({},e.offsets.popper,S(e.instance.popper,e.offsets.reference,e.placement)),e=C(e.instance.modifiers,e,'flip'))}),e},behavior:'flip',padding:5,boundariesElement:'viewport'},inner:{order:700,enabled:!1,fn:function(e){var t=e.placement,o=t.split('-')[0],i=e.offsets,n=i.popper,r=i.reference,p=-1!==['left','right'].indexOf(o),s=-1===['top','left'].indexOf(o);return n[p?'left':'top']=r[o]-(s?n[p?'width':'height']:0),e.placement=x(t),e.offsets.popper=c(n),e}},hide:{order:800,enabled:!0,fn:function(e){if(!F(e.instance.modifiers,'hide','preventOverflow'))return e;var t=e.offsets.reference,o=T(e.instance.modifiers,function(e){return'preventOverflow'===e.name}).boundaries;if(t.bottom<o.top||t.left>o.right||t.top>o.bottom||t.right<o.left){if(!0===e.hide)return e;e.hide=!0,e.attributes['x-out-of-boundaries']=''}else{if(!1===e.hide)return e;e.hide=!1,e.attributes['x-out-of-boundaries']=!1}return e}},computeStyle:{order:850,enabled:!0,fn:function(e,t){var o=t.x,i=t.y,n=e.offsets.popper,p=T(e.instance.modifiers,function(e){return'applyStyle'===e.name}).gpuAcceleration;void 0!==p&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');var s,d,a=void 0===p?t.gpuAcceleration:p,l=r(e.instance.popper),f=g(l),m={position:n.position},h={left:X(n.left),top:X(n.top),bottom:X(n.bottom),right:X(n.right)},c='bottom'===o?'top':'bottom',u='right'===i?'left':'right',b=W('transform');if(d='bottom'==c?-f.height+h.bottom:h.top,s='right'==u?-f.width+h.right:h.left,a&&b)m[b]='translate3d('+s+'px, '+d+'px, 0)',m[c]=0,m[u]=0,m.willChange='transform';else{var w='bottom'==c?-1:1,y='right'==u?-1:1;m[c]=d*w,m[u]=s*y,m.willChange=c+', '+u}var E={"x-placement":e.placement};return e.attributes=se({},E,e.attributes),e.styles=se({},m,e.styles),e.arrowStyles=se({},e.offsets.arrow,e.arrowStyles),e},gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:function(e){return Y(e.instance.popper,e.styles),j(e.instance.popper,e.attributes),e.arrowElement&&Object.keys(e.arrowStyles).length&&Y(e.arrowElement,e.arrowStyles),e},onLoad:function(e,t,o,i,n){var r=O(n,t,e),p=v(o.placement,r,t,e,o.modifiers.flip.boundariesElement,o.modifiers.flip.padding);return t.setAttribute('x-placement',p),Y(t,{position:'absolute'}),o},gpuAcceleration:void 0}}},fe});
//# sourceMappingURL=popper.min.js.map

/*! modernizr 3.5.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-applicationcache-audio-backgroundsize-bgpositionxy-bgsizecover-borderimage-borderradius-boxshadow-boxsizing-canvas-canvastext-checked-cssanimations-csscolumns-cssgradients-csshyphens_softhyphens_softhyphensfind-cssreflections-cssscrollbar-csstransforms-csstransforms3d-csstransitions-ellipsis-flash-flexbox-flexboxlegacy-fontface-forcetouch-generatedcontent-geolocation-getusermedia-hashchange-history-hsla-indexeddb-inlinesvg-input-inputtypes-lastchild-localizednumber-localstorage-matchmedia-microdata-multiplebgs-nthchild-opacity-placeholder-postmessage-rgba-sessionstorage-smil-supports-svg-svgasimg-svgclippaths-svgfilters-target-textshadow-touchevents-video-webgl-websockets-websqldatabase-webworkers-domprefixes-hasevent-mq-prefixes-printshiv-setclasses-testallprops-testprop-teststyles !*/
! function(e, t, n) {
    function r(e, t) {
        return typeof e === t
    }

    function o() {
        var e, t, n, o, i, a, s;
        for (var l in w)
            if (w.hasOwnProperty(l)) {
                if (e = [], t = w[l], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length))
                    for (n = 0; n < t.options.aliases.length; n++) e.push(t.options.aliases[n].toLowerCase());
                for (o = r(t.fn, "function") ? t.fn() : t.fn, i = 0; i < e.length; i++) a = e[i], s = a.split("."), 1 === s.length ? Modernizr[s[0]] = o : (!Modernizr[s[0]] || Modernizr[s[0]] instanceof Boolean || (Modernizr[s[0]] = new Boolean(Modernizr[s[0]])), Modernizr[s[0]][s[1]] = o), x.push((o ? "" : "no-") + s.join("-"))
            }
    }

    function i(e) {
        var t = N.className,
            n = Modernizr._config.classPrefix || "";
        if (z && (t = t.baseVal), Modernizr._config.enableJSClass) {
            var r = new RegExp("(^|\\s)" + n + "no-js(\\s|$)");
            t = t.replace(r, "$1" + n + "js$2")
        }
        Modernizr._config.enableClasses && (t += " " + n + e.join(" " + n), z ? N.className.baseVal = t : N.className = t)
    }

    function a() {
        return "function" != typeof t.createElement ? t.createElement(arguments[0]) : z ? t.createElementNS.call(t, "http://www.w3.org/2000/svg", arguments[0]) : t.createElement.apply(t, arguments)
    }

    function s() {
        var e = t.body;
        return e || (e = a(z ? "svg" : "body"), e.fake = !0), e
    }

    function l(e, n, r, o) {
        var i, l, d, c, u = "modernizr",
            f = a("div"),
            p = s();
        if (parseInt(r, 10))
            for (; r--;) d = a("div"), d.id = o ? o[r] : u + (r + 1), f.appendChild(d);
        return i = a("style"), i.type = "text/css", i.id = "s" + u, (p.fake ? p : f).appendChild(i), p.appendChild(f), i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(t.createTextNode(e)), f.id = u, p.fake && (p.style.background = "", p.style.overflow = "hidden", c = N.style.overflow, N.style.overflow = "hidden", N.appendChild(p)), l = n(f, e), p.fake ? (p.parentNode.removeChild(p), N.style.overflow = c, N.offsetHeight) : f.parentNode.removeChild(f), !!l
    }

    function d(e, t) {
        return !!~("" + e).indexOf(t)
    }

    function c(e) {
        return e.replace(/([a-z])-([a-z])/g, function(e, t, n) {
            return t + n.toUpperCase()
        }).replace(/^-/, "")
    }

    function u(e, t) {
        if ("object" == typeof e)
            for (var n in e) I(e, n) && u(n, e[n]);
        else {
            e = e.toLowerCase();
            var r = e.split("."),
                o = Modernizr[r[0]];
            if (2 == r.length && (o = o[r[1]]), "undefined" != typeof o) return Modernizr;
            t = "function" == typeof t ? t() : t, 1 == r.length ? Modernizr[r[0]] = t : (!Modernizr[r[0]] || Modernizr[r[0]] instanceof Boolean || (Modernizr[r[0]] = new Boolean(Modernizr[r[0]])), Modernizr[r[0]][r[1]] = t), i([(t && 0 != t ? "" : "no-") + r.join("-")]), Modernizr._trigger(e, t)
        }
        return Modernizr
    }

    function f(e, t) {
        return function() {
            return e.apply(t, arguments)
        }
    }

    function p(e, t, n) {
        var o;
        for (var i in e)
            if (e[i] in t) return n === !1 ? e[i] : (o = t[e[i]], r(o, "function") ? f(o, n || t) : o);
        return !1
    }

    function m(e) {
        return e.replace(/([A-Z])/g, function(e, t) {
            return "-" + t.toLowerCase()
        }).replace(/^ms-/, "-ms-")
    }

    function h(t, n, r) {
        var o;
        if ("getComputedStyle" in e) {
            o = getComputedStyle.call(e, t, n);
            var i = e.console;
            if (null !== o) r && (o = o.getPropertyValue(r));
            else if (i) {
                var a = i.error ? "error" : "log";
                i[a].call(i, "getComputedStyle returning null, its possible modernizr test results are inaccurate")
            }
        } else o = !n && t.currentStyle && t.currentStyle[r];
        return o
    }

    function v(t, r) {
        var o = t.length;
        if ("CSS" in e && "supports" in e.CSS) {
            for (; o--;)
                if (e.CSS.supports(m(t[o]), r)) return !0;
            return !1
        }
        if ("CSSSupportsRule" in e) {
            for (var i = []; o--;) i.push("(" + m(t[o]) + ":" + r + ")");
            return i = i.join(" or "), l("@supports (" + i + ") { #modernizr { position: absolute; } }", function(e) {
                return "absolute" == h(e, null, "position")
            })
        }
        return n
    }

    function g(e, t, o, i) {
        function s() {
            u && (delete G.style, delete G.modElem)
        }
        if (i = r(i, "undefined") ? !1 : i, !r(o, "undefined")) {
            var l = v(e, o);
            if (!r(l, "undefined")) return l
        }
        for (var u, f, p, m, h, g = ["modernizr", "tspan", "samp"]; !G.style && g.length;) u = !0, G.modElem = a(g.shift()), G.style = G.modElem.style;
        for (p = e.length, f = 0; p > f; f++)
            if (m = e[f], h = G.style[m], d(m, "-") && (m = c(m)), G.style[m] !== n) {
                if (i || r(o, "undefined")) return s(), "pfx" == t ? m : !0;
                try {
                    G.style[m] = o
                } catch (b) {}
                if (G.style[m] != h) return s(), "pfx" == t ? m : !0
            }
        return s(), !1
    }

    function b(e, t, n, o, i) {
        var a = e.charAt(0).toUpperCase() + e.slice(1),
            s = (e + " " + D.join(a + " ") + a).split(" ");
        return r(t, "string") || r(t, "undefined") ? g(s, t, o, i) : (s = (e + " " + M.join(a + " ") + a).split(" "), p(s, t, n))
    }

    function y(e, t, r) {
        return b(e, n, n, t, r)
    }

    function T(e, t) {
        var n = e.deleteDatabase(t);
        n.onsuccess = function() {
            u("indexeddb.deletedatabase", !0)
        }, n.onerror = function() {
            u("indexeddb.deletedatabase", !1)
        }
    }
    var x = [],
        w = [],
        k = {
            _version: "3.5.0",
            _config: {
                classPrefix: "",
                enableClasses: !0,
                enableJSClass: !0,
                usePrefixes: !0
            },
            _q: [],
            on: function(e, t) {
                var n = this;
                setTimeout(function() {
                    t(n[e])
                }, 0)
            },
            addTest: function(e, t, n) {
                w.push({
                    name: e,
                    fn: t,
                    options: n
                })
            },
            addAsyncTest: function(e) {
                w.push({
                    name: null,
                    fn: e
                })
            }
        },
        Modernizr = function() {};
    Modernizr.prototype = k, Modernizr = new Modernizr, Modernizr.addTest("applicationcache", "applicationCache" in e), Modernizr.addTest("geolocation", "geolocation" in navigator), Modernizr.addTest("history", function() {
        var t = navigator.userAgent;
        return -1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone") || "file:" === location.protocol ? e.history && "pushState" in e.history : !1
    }), Modernizr.addTest("postmessage", "postMessage" in e), Modernizr.addTest("svg", !!t.createElementNS && !!t.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect);
    var C = !1;
    try {
        C = "WebSocket" in e && 2 === e.WebSocket.CLOSING
    } catch (S) {}
    Modernizr.addTest("websockets", C);
    var E = "CSS" in e && "supports" in e.CSS,
        _ = "supportsCSS" in e;
    Modernizr.addTest("supports", E || _), Modernizr.addTest("microdata", "getItems" in t), Modernizr.addTest("localstorage", function() {
        var e = "modernizr";
        try {
            return localStorage.setItem(e, e), localStorage.removeItem(e), !0
        } catch (t) {
            return !1
        }
    }), Modernizr.addTest("sessionstorage", function() {
        var e = "modernizr";
        try {
            return sessionStorage.setItem(e, e), sessionStorage.removeItem(e), !0
        } catch (t) {
            return !1
        }
    }), Modernizr.addTest("websqldatabase", "openDatabase" in e), Modernizr.addTest("svgfilters", function() {
        var t = !1;
        try {
            t = "SVGFEColorMatrixElement" in e && 2 == SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE
        } catch (n) {}
        return t
    }), Modernizr.addTest("webworkers", "Worker" in e);
    var P = k._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];
    k._prefixes = P;
    var N = t.documentElement,
        z = "svg" === N.nodeName.toLowerCase();
    z || ! function(e, t) {
        function n(e, t) {
            var n = e.createElement("p"),
                r = e.getElementsByTagName("head")[0] || e.documentElement;
            return n.innerHTML = "x<style>" + t + "</style>", r.insertBefore(n.lastChild, r.firstChild)
        }

        function r() {
            var e = C.elements;
            return "string" == typeof e ? e.split(" ") : e
        }

        function o(e, t) {
            var n = C.elements;
            "string" != typeof n && (n = n.join(" ")), "string" != typeof e && (e = e.join(" ")), C.elements = n + " " + e, d(t)
        }

        function i(e) {
            var t = k[e[x]];
            return t || (t = {}, w++, e[x] = w, k[w] = t), t
        }

        function a(e, n, r) {
            if (n || (n = t), v) return n.createElement(e);
            r || (r = i(n));
            var o;
            return o = r.cache[e] ? r.cache[e].cloneNode() : T.test(e) ? (r.cache[e] = r.createElem(e)).cloneNode() : r.createElem(e), !o.canHaveChildren || y.test(e) || o.tagUrn ? o : r.frag.appendChild(o)
        }

        function s(e, n) {
            if (e || (e = t), v) return e.createDocumentFragment();
            n = n || i(e);
            for (var o = n.frag.cloneNode(), a = 0, s = r(), l = s.length; l > a; a++) o.createElement(s[a]);
            return o
        }

        function l(e, t) {
            t.cache || (t.cache = {}, t.createElem = e.createElement, t.createFrag = e.createDocumentFragment, t.frag = t.createFrag()), e.createElement = function(n) {
                return C.shivMethods ? a(n, e, t) : t.createElem(n)
            }, e.createDocumentFragment = Function("h,f", "return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(" + r().join().replace(/[\w\-:]+/g, function(e) {
                return t.createElem(e), t.frag.createElement(e), 'c("' + e + '")'
            }) + ");return n}")(C, t.frag)
        }

        function d(e) {
            e || (e = t);
            var r = i(e);
            return !C.shivCSS || h || r.hasCSS || (r.hasCSS = !!n(e, "article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")), v || l(e, r), e
        }

        function c(e) {
            for (var t, n = e.getElementsByTagName("*"), o = n.length, i = RegExp("^(?:" + r().join("|") + ")$", "i"), a = []; o--;) t = n[o], i.test(t.nodeName) && a.push(t.applyElement(u(t)));
            return a
        }

        function u(e) {
            for (var t, n = e.attributes, r = n.length, o = e.ownerDocument.createElement(E + ":" + e.nodeName); r--;) t = n[r], t.specified && o.setAttribute(t.nodeName, t.nodeValue);
            return o.style.cssText = e.style.cssText, o
        }

        function f(e) {
            for (var t, n = e.split("{"), o = n.length, i = RegExp("(^|[\\s,>+~])(" + r().join("|") + ")(?=[[\\s,>+~#.:]|$)", "gi"), a = "$1" + E + "\\:$2"; o--;) t = n[o] = n[o].split("}"), t[t.length - 1] = t[t.length - 1].replace(i, a), n[o] = t.join("}");
            return n.join("{")
        }

        function p(e) {
            for (var t = e.length; t--;) e[t].removeNode()
        }

        function m(e) {
            function t() {
                clearTimeout(a._removeSheetTimer), r && r.removeNode(!0), r = null
            }
            var r, o, a = i(e),
                s = e.namespaces,
                l = e.parentWindow;
            return !_ || e.printShived ? e : ("undefined" == typeof s[E] && s.add(E), l.attachEvent("onbeforeprint", function() {
                t();
                for (var i, a, s, l = e.styleSheets, d = [], u = l.length, p = Array(u); u--;) p[u] = l[u];
                for (; s = p.pop();)
                    if (!s.disabled && S.test(s.media)) {
                        try {
                            i = s.imports, a = i.length
                        } catch (m) {
                            a = 0
                        }
                        for (u = 0; a > u; u++) p.push(i[u]);
                        try {
                            d.push(s.cssText)
                        } catch (m) {}
                    }
                d = f(d.reverse().join("")), o = c(e), r = n(e, d)
            }), l.attachEvent("onafterprint", function() {
                p(o), clearTimeout(a._removeSheetTimer), a._removeSheetTimer = setTimeout(t, 500)
            }), e.printShived = !0, e)
        }
        var h, v, g = "3.7.3",
            b = e.html5 || {},
            y = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,
            T = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,
            x = "_html5shiv",
            w = 0,
            k = {};
        ! function() {
            try {
                var e = t.createElement("a");
                e.innerHTML = "<xyz></xyz>", h = "hidden" in e, v = 1 == e.childNodes.length || function() {
                    t.createElement("a");
                    var e = t.createDocumentFragment();
                    return "undefined" == typeof e.cloneNode || "undefined" == typeof e.createDocumentFragment || "undefined" == typeof e.createElement
                }()
            } catch (n) {
                h = !0, v = !0
            }
        }();
        var C = {
            elements: b.elements || "abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video",
            version: g,
            shivCSS: b.shivCSS !== !1,
            supportsUnknownElements: v,
            shivMethods: b.shivMethods !== !1,
            type: "default",
            shivDocument: d,
            createElement: a,
            createDocumentFragment: s,
            addElements: o
        };
        e.html5 = C, d(t);
        var S = /^$|\b(?:all|print)\b/,
            E = "html5shiv",
            _ = !v && function() {
                var n = t.documentElement;
                return !("undefined" == typeof t.namespaces || "undefined" == typeof t.parentWindow || "undefined" == typeof n.applyElement || "undefined" == typeof n.removeNode || "undefined" == typeof e.attachEvent)
            }();
        C.type += " print", C.shivPrint = m, m(t), "object" == typeof module && module.exports && (module.exports = C)
    }("undefined" != typeof e ? e : this, t);
    var A = "Moz O ms Webkit",
        M = k._config.usePrefixes ? A.toLowerCase().split(" ") : [];
    k._domPrefixes = M;
    var j = function() {
        function e(e, t) {
            var o;
            return e ? (t && "string" != typeof t || (t = a(t || "div")), e = "on" + e, o = e in t, !o && r && (t.setAttribute || (t = a("div")), t.setAttribute(e, ""), o = "function" == typeof t[e], t[e] !== n && (t[e] = n), t.removeAttribute(e)), o) : !1
        }
        var r = !("onblur" in t.documentElement);
        return e
    }();
    k.hasEvent = j, Modernizr.addTest("hashchange", function() {
        return j("hashchange", e) === !1 ? !1 : t.documentMode === n || t.documentMode > 7
    }), Modernizr.addTest("audio", function() {
        var e = a("audio"),
            t = !1;
        try {
            t = !!e.canPlayType, t && (t = new Boolean(t), t.ogg = e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), t.mp3 = e.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/, ""), t.opus = e.canPlayType('audio/ogg; codecs="opus"') || e.canPlayType('audio/webm; codecs="opus"').replace(/^no$/, ""), t.wav = e.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""), t.m4a = (e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""))
        } catch (n) {}
        return t
    }), Modernizr.addTest("canvas", function() {
        var e = a("canvas");
        return !(!e.getContext || !e.getContext("2d"))
    }), Modernizr.addTest("canvastext", function() {
        return Modernizr.canvas === !1 ? !1 : "function" == typeof a("canvas").getContext("2d").fillText
    }), Modernizr.addTest("video", function() {
        var e = a("video"),
            t = !1;
        try {
            t = !!e.canPlayType, t && (t = new Boolean(t), t.ogg = e.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ""), t.h264 = e.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ""), t.webm = e.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ""), t.vp9 = e.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ""), t.hls = e.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, ""))
        } catch (n) {}
        return t
    }), Modernizr.addTest("webgl", function() {
        var t = a("canvas"),
            n = "probablySupportsContext" in t ? "probablySupportsContext" : "supportsContext";
        return n in t ? t[n]("webgl") || t[n]("experimental-webgl") : "WebGLRenderingContext" in e
    }), Modernizr.addTest("cssgradients", function() {
        for (var e, t = "background-image:", n = "gradient(linear,left top,right bottom,from(#9f9),to(white));", r = "", o = 0, i = P.length - 1; i > o; o++) e = 0 === o ? "to " : "", r += t + P[o] + "linear-gradient(" + e + "left top, #9f9, white);";
        Modernizr._config.usePrefixes && (r += t + "-webkit-" + n);
        var s = a("a"),
            l = s.style;
        return l.cssText = r, ("" + l.backgroundImage).indexOf("gradient") > -1
    }), Modernizr.addTest("multiplebgs", function() {
        var e = a("a").style;
        return e.cssText = "background:url(https://),url(https://),red url(https://)", /(url\s*\(.*?){3}/.test(e.background)
    }), Modernizr.addTest("opacity", function() {
        var e = a("a").style;
        return e.cssText = P.join("opacity:.55;"), /^0.55$/.test(e.opacity)
    }), Modernizr.addTest("rgba", function() {
        var e = a("a").style;
        return e.cssText = "background-color:rgba(150,255,150,.5)", ("" + e.backgroundColor).indexOf("rgba") > -1
    }), Modernizr.addTest("placeholder", "placeholder" in a("input") && "placeholder" in a("textarea")), Modernizr.addTest("inlinesvg", function() {
        var e = a("div");
        return e.innerHTML = "<svg/>", "http://www.w3.org/2000/svg" == ("undefined" != typeof SVGRect && e.firstChild && e.firstChild.namespaceURI)
    });
    var R = function() {
        var t = e.matchMedia || e.msMatchMedia;
        return t ? function(e) {
            var n = t(e);
            return n && n.matches || !1
        } : function(t) {
            var n = !1;
            return l("@media " + t + " { #modernizr { position: absolute; } }", function(t) {
                n = "absolute" == (e.getComputedStyle ? e.getComputedStyle(t, null) : t.currentStyle).position
            }), n
        }
    }();
    k.mq = R;
    var B = k.testStyles = l;
    Modernizr.addTest("touchevents", function() {
        var n;
        if ("ontouchstart" in e || e.DocumentTouch && t instanceof DocumentTouch) n = !0;
        else {
            var r = ["@media (", P.join("touch-enabled),("), "heartz", ")", "{#modernizr{top:9px;position:absolute}}"].join("");
            B(r, function(e) {
                n = 9 === e.offsetTop
            })
        }
        return n
    }), Modernizr.addTest("checked", function() {
        return B("#modernizr {position:absolute} #modernizr input {margin-left:10px} #modernizr :checked {margin-left:20px;display:block}", function(e) {
            var t = a("input");
            return t.setAttribute("type", "checkbox"), t.setAttribute("checked", "checked"), e.appendChild(t), 20 === t.offsetLeft
        })
    });
    var L = function() {
        var e = navigator.userAgent,
            t = e.match(/w(eb)?osbrowser/gi),
            n = e.match(/windows phone/gi) && e.match(/iemobile\/([0-9])+/gi) && parseFloat(RegExp.$1) >= 9;
        return t || n
    }();
    L ? Modernizr.addTest("fontface", !1) : B('@font-face {font-family:"font";src:url("https://")}', function(e, n) {
        var r = t.getElementById("smodernizr"),
            o = r.sheet || r.styleSheet,
            i = o ? o.cssRules && o.cssRules[0] ? o.cssRules[0].cssText : o.cssText || "" : "",
            a = /src/i.test(i) && 0 === i.indexOf(n.split(" ")[0]);
        Modernizr.addTest("fontface", a)
    }), B('#modernizr{font:0/0 a}#modernizr:after{content:":)";visibility:hidden;font:7px/1 a}', function(e) {
        Modernizr.addTest("generatedcontent", e.offsetHeight >= 6)
    }), B("#modernizr div {width:100px} #modernizr :last-child{width:200px;display:block}", function(e) {
        Modernizr.addTest("lastchild", e.lastChild.offsetWidth > e.firstChild.offsetWidth)
    }, 2), B("#modernizr div {width:1px} #modernizr div:nth-child(2n) {width:2px;}", function(e) {
        for (var t = e.getElementsByTagName("div"), n = !0, r = 0; 5 > r; r++) n = n && t[r].offsetWidth === r % 2 + 1;
        Modernizr.addTest("nthchild", n)
    }, 5), B("#modernizr{overflow: scroll; width: 40px; height: 40px; }#" + P.join("scrollbar{width:10px} #modernizr::").split("#").slice(1).join("#") + "scrollbar{width:10px}", function(e) {
        Modernizr.addTest("cssscrollbar", "scrollWidth" in e && 30 == e.scrollWidth)
    }), Modernizr.addTest("target", function() {
        var t = e.document;
        if (!("querySelectorAll" in t)) return !1;
        try {
            return t.querySelectorAll(":target"), !0
        } catch (n) {
            return !1
        }
    });
    var O = a("input"),
        q = "autocomplete autofocus list placeholder max min multiple pattern required step".split(" "),
        W = {};
    Modernizr.input = function(t) {
        for (var n = 0, r = t.length; r > n; n++) W[t[n]] = !!(t[n] in O);
        return W.list && (W.list = !(!a("datalist") || !e.HTMLDataListElement)), W
    }(q);
    var $ = "search tel url email datetime date month week time datetime-local number range color".split(" "),
        F = {};
    Modernizr.inputtypes = function(e) {
        for (var r, o, i, a = e.length, s = "1)", l = 0; a > l; l++) O.setAttribute("type", r = e[l]), i = "text" !== O.type && "style" in O, i && (O.value = s, O.style.cssText = "position:absolute;visibility:hidden;", /^range$/.test(r) && O.style.WebkitAppearance !== n ? (N.appendChild(O), o = t.defaultView, i = o.getComputedStyle && "textfield" !== o.getComputedStyle(O, null).WebkitAppearance && 0 !== O.offsetHeight, N.removeChild(O)) : /^(search|tel)$/.test(r) || (i = /^(url|email)$/.test(r) ? O.checkValidity && O.checkValidity() === !1 : O.value != s)), F[e[l]] = !!i;
        return F
    }($), Modernizr.addTest("hsla", function() {
        var e = a("a").style;
        return e.cssText = "background-color:hsla(120,40%,100%,.5)", d(e.backgroundColor, "rgba") || d(e.backgroundColor, "hsla")
    }), Modernizr.addTest("formvalidation", function() {
        var t = a("form");
        if (!("checkValidity" in t && "addEventListener" in t)) return !1;
        if ("reportValidity" in t) return !0;
        var n, r = !1;
        return Modernizr.formvalidationapi = !0, t.addEventListener("submit", function(t) {
            (!e.opera || e.operamini) && t.preventDefault(), t.stopPropagation()
        }, !1), t.innerHTML = '<input name="modTest" required="required" /><button></button>', B("#modernizr form{position:absolute;top:-99999em}", function(e) {
            e.appendChild(t), n = t.getElementsByTagName("input")[0], n.addEventListener("invalid", function(e) {
                r = !0, e.preventDefault(), e.stopPropagation()
            }, !1), Modernizr.formvalidationmessage = !!n.validationMessage, t.getElementsByTagName("button")[0].click()
        }), r
    }), Modernizr.addTest("localizednumber", function() {
        if (!Modernizr.inputtypes.number) return !1;
        if (!Modernizr.formvalidation) return !1;
        var e, n = a("div"),
            r = s(),
            o = function() {
                return N.insertBefore(r, N.firstElementChild || N.firstChild)
            }();
        n.innerHTML = '<input type="number" value="1.0" step="0.1"/>';
        var i = n.childNodes[0];
        o.appendChild(n), i.focus();
        try {
            t.execCommand("SelectAll", !1), t.execCommand("InsertText", !1, "1,1")
        } catch (l) {}
        return e = "number" === i.type && 1.1 === i.valueAsNumber && i.checkValidity(), o.removeChild(n), r.fake && o.parentNode.removeChild(o), e
    });
    var H = {}.toString;
    Modernizr.addTest("svgclippaths", function() {
        return !!t.createElementNS && /SVGClipPath/.test(H.call(t.createElementNS("http://www.w3.org/2000/svg", "clipPath")))
    }), Modernizr.addTest("smil", function() {
        return !!t.createElementNS && /SVGAnimate/.test(H.call(t.createElementNS("http://www.w3.org/2000/svg", "animate")))
    });
    var D = k._config.usePrefixes ? A.split(" ") : [];
    k._cssomPrefixes = D;
    var I;
    ! function() {
        var e = {}.hasOwnProperty;
        I = r(e, "undefined") || r(e.call, "undefined") ? function(e, t) {
            return t in e && r(e.constructor.prototype[t], "undefined")
        } : function(t, n) {
            return e.call(t, n)
        }
    }(), k._l = {}, k.on = function(e, t) {
        this._l[e] || (this._l[e] = []), this._l[e].push(t), Modernizr.hasOwnProperty(e) && setTimeout(function() {
            Modernizr._trigger(e, Modernizr[e])
        }, 0)
    }, k._trigger = function(e, t) {
        if (this._l[e]) {
            var n = this._l[e];
            setTimeout(function() {
                var e, r;
                for (e = 0; e < n.length; e++)(r = n[e])(t)
            }, 0), delete this._l[e]
        }
    }, Modernizr._q.push(function() {
        k.addTest = u
    }), Modernizr.addAsyncTest(function() {
        var n, r, o = function(e) {
                N.contains(e) || N.appendChild(e)
            },
            i = function(e) {
                e.fake && e.parentNode && e.parentNode.removeChild(e)
            },
            l = function(e, t) {
                var n = !!e;
                if (n && (n = new Boolean(n), n.blocked = "blocked" === e), u("flash", function() {
                        return n
                    }), t && m.contains(t)) {
                    for (; t.parentNode !== m;) t = t.parentNode;
                    m.removeChild(t)
                }
            };
        try {
            r = "ActiveXObject" in e && "Pan" in new e.ActiveXObject("ShockwaveFlash.ShockwaveFlash")
        } catch (d) {}
        if (n = !("plugins" in navigator && "Shockwave Flash" in navigator.plugins || r), n || z) l(!1);
        else {
            var c, f, p = a("embed"),
                m = s();
            if (p.type = "application/x-shockwave-flash", m.appendChild(p), !("Pan" in p || r)) return o(m), l("blocked", p), void i(m);
            c = function() {
                return o(m), N.contains(m) ? (N.contains(p) ? (f = p.style.cssText, "" !== f ? l("blocked", p) : l(!0, p)) : l("blocked"), void i(m)) : (m = t.body || m, p = a("embed"), p.type = "application/x-shockwave-flash", m.appendChild(p), setTimeout(c, 1e3))
            }, setTimeout(c, 10)
        }
    }), Modernizr.addTest("svgasimg", t.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1"));
    var V = function(t) {
        var r, o = P.length,
            i = e.CSSRule;
        if ("undefined" == typeof i) return n;
        if (!t) return !1;
        if (t = t.replace(/^@/, ""), r = t.replace(/-/g, "_").toUpperCase() + "_RULE", r in i) return "@" + t;
        for (var a = 0; o > a; a++) {
            var s = P[a],
                l = s.toUpperCase() + "_" + r;
            if (l in i) return "@-" + s.toLowerCase() + "-" + t
        }
        return !1
    };
    k.atRule = V;
    var U = {
        elem: a("modernizr")
    };
    Modernizr._q.push(function() {
        delete U.elem
    });
    var G = {
        style: U.elem.style
    };
    Modernizr._q.unshift(function() {
        delete G.style
    });
    var X = k.testProp = function(e, t, r) {
        return g([e], n, t, r)
    };
    Modernizr.addTest("textshadow", X("textShadow", "1px 1px")), k.testAllProps = b, k.testAllProps = y, Modernizr.addTest("cssanimations", y("animationName", "a", !0)), Modernizr.addTest("bgpositionxy", function() {
            return y("backgroundPositionX", "3px", !0) && y("backgroundPositionY", "5px", !0)
        }), Modernizr.addTest("backgroundsize", y("backgroundSize", "100%", !0)), Modernizr.addTest("bgsizecover", y("backgroundSize", "cover")), Modernizr.addTest("borderimage", y("borderImage", "url() 1", !0)), Modernizr.addTest("borderradius", y("borderRadius", "0px", !0)), Modernizr.addTest("boxshadow", y("boxShadow", "1px 1px", !0)), Modernizr.addTest("boxsizing", y("boxSizing", "border-box", !0) && (t.documentMode === n || t.documentMode > 7)),
        function() {
            Modernizr.addTest("csscolumns", function() {
                var e = !1,
                    t = y("columnCount");
                try {
                    e = !!t, e && (e = new Boolean(e))
                } catch (n) {}
                return e
            });
            for (var e, t, n = ["Width", "Span", "Fill", "Gap", "Rule", "RuleColor", "RuleStyle", "RuleWidth", "BreakBefore", "BreakAfter", "BreakInside"], r = 0; r < n.length; r++) e = n[r].toLowerCase(), t = y("column" + n[r]), ("breakbefore" === e || "breakafter" === e || "breakinside" == e) && (t = t || y(n[r])), Modernizr.addTest("csscolumns." + e, t)
        }(), Modernizr.addTest("ellipsis", y("textOverflow", "ellipsis")), Modernizr.addTest("flexbox", y("flexBasis", "1px", !0)), Modernizr.addTest("flexboxlegacy", y("boxDirection", "reverse", !0)), Modernizr.addAsyncTest(function() {
            function n() {
                function o() {
                    try {
                        var e = a("div"),
                            n = a("span"),
                            r = e.style,
                            o = 0,
                            i = 0,
                            s = !1,
                            l = t.body.firstElementChild || t.body.firstChild;
                        return e.appendChild(n), n.innerHTML = "Bacon ipsum dolor sit amet jerky velit in culpa hamburger et. Laborum dolor proident, enim dolore duis commodo et strip steak. Salami anim et, veniam consectetur dolore qui tenderloin jowl velit sirloin. Et ad culpa, fatback cillum jowl ball tip ham hock nulla short ribs pariatur aute. Pig pancetta ham bresaola, ut boudin nostrud commodo flank esse cow tongue culpa. Pork belly bresaola enim pig, ea consectetur nisi. Fugiat officia turkey, ea cow jowl pariatur ullamco proident do laborum velit sausage. Magna biltong sint tri-tip commodo sed bacon, esse proident aliquip. Ullamco ham sint fugiat, velit in enim sed mollit nulla cow ut adipisicing nostrud consectetur. Proident dolore beef ribs, laborum nostrud meatball ea laboris rump cupidatat labore culpa. Shankle minim beef, velit sint cupidatat fugiat tenderloin pig et ball tip. Ut cow fatback salami, bacon ball tip et in shank strip steak bresaola. In ut pork belly sed mollit tri-tip magna culpa veniam, short ribs qui in andouille ham consequat. Dolore bacon t-bone, velit short ribs enim strip steak nulla. Voluptate labore ut, biltong swine irure jerky. Cupidatat excepteur aliquip salami dolore. Ball tip strip steak in pork dolor. Ad in esse biltong. Dolore tenderloin exercitation ad pork loin t-bone, dolore in chicken ball tip qui pig. Ut culpa tongue, sint ribeye dolore ex shank voluptate hamburger. Jowl et tempor, boudin pork chop labore ham hock drumstick consectetur tri-tip elit swine meatball chicken ground round. Proident shankle mollit dolore. Shoulder ut duis t-bone quis reprehenderit. Meatloaf dolore minim strip steak, laboris ea aute bacon beef ribs elit shank in veniam drumstick qui. Ex laboris meatball cow tongue pork belly. Ea ball tip reprehenderit pig, sed fatback boudin dolore flank aliquip laboris eu quis. Beef ribs duis beef, cow corned beef adipisicing commodo nisi deserunt exercitation. Cillum dolor t-bone spare ribs, ham hock est sirloin. Brisket irure meatloaf in, boudin pork belly sirloin ball tip. Sirloin sint irure nisi nostrud aliqua. Nostrud nulla aute, enim officia culpa ham hock. Aliqua reprehenderit dolore sunt nostrud sausage, ea boudin pork loin ut t-bone ham tempor. Tri-tip et pancetta drumstick laborum. Ham hock magna do nostrud in proident. Ex ground round fatback, venison non ribeye in.", t.body.insertBefore(e, l), r.cssText = "position:absolute;top:0;left:0;width:5em;text-align:justify;text-justification:newspaper;", o = n.offsetHeight, i = n.offsetWidth, r.cssText = "position:absolute;top:0;left:0;width:5em;text-align:justify;text-justification:newspaper;" + P.join("hyphens:auto; "), s = n.offsetHeight != o || n.offsetWidth != i, t.body.removeChild(e), e.removeChild(n), s
                    } catch (d) {
                        return !1
                    }
                }

                function i(e, n) {
                    try {
                        var r = a("div"),
                            o = a("span"),
                            i = r.style,
                            s = 0,
                            l = !1,
                            d = !1,
                            c = !1,
                            u = t.body.firstElementChild || t.body.firstChild;
                        return i.cssText = "position:absolute;top:0;left:0;overflow:visible;width:1.25em;", r.appendChild(o), t.body.insertBefore(r, u), o.innerHTML = "mm", s = o.offsetHeight, o.innerHTML = "m" + e + "m", d = o.offsetHeight > s, n ? (o.innerHTML = "m<br />m", s = o.offsetWidth, o.innerHTML = "m" + e + "m", c = o.offsetWidth > s) : c = !0, d === !0 && c === !0 && (l = !0), t.body.removeChild(r), r.removeChild(o), l
                    } catch (f) {
                        return !1
                    }
                }

                function s(n) {
                    try {
                        var r, o = a("input"),
                            i = a("div"),
                            s = "lebowski",
                            l = !1,
                            d = t.body.firstElementChild || t.body.firstChild;
                        i.innerHTML = s + n + s, t.body.insertBefore(i, d), t.body.insertBefore(o, i), o.setSelectionRange ? (o.focus(), o.setSelectionRange(0, 0)) : o.createTextRange && (r = o.createTextRange(), r.collapse(!0), r.moveEnd("character", 0), r.moveStart("character", 0), r.select());
                        try {
                            e.find ? l = e.find(s + s) : (r = e.self.document.body.createTextRange(), l = r.findText(s + s))
                        } catch (c) {
                            l = !1
                        }
                        return t.body.removeChild(i), t.body.removeChild(o), l
                    } catch (c) {
                        return !1
                    }
                }
                return t.body || t.getElementsByTagName("body")[0] ? (u("csshyphens", function() {
                    if (!y("hyphens", "auto", !0)) return !1;
                    try {
                        return o()
                    } catch (e) {
                        return !1
                    }
                }), u("softhyphens", function() {
                    try {
                        return i("&#173;", !0) && i("&#8203;", !1)
                    } catch (e) {
                        return !1
                    }
                }), void u("softhyphensfind", function() {
                    try {
                        return s("&#173;") && s("&#8203;")
                    } catch (e) {
                        return !1
                    }
                })) : void setTimeout(n, r)
            }
            var r = 300;
            setTimeout(n, r)
        }), Modernizr.addTest("cssreflections", y("boxReflect", "above", !0)), Modernizr.addTest("csstransforms", function() {
            return -1 === navigator.userAgent.indexOf("Android 2.") && y("transform", "scale(1)", !0)
        }), Modernizr.addTest("csstransforms3d", function() {
            var e = !!y("perspective", "1px", !0),
                t = Modernizr._config.usePrefixes;
            if (e && (!t || "webkitPerspective" in N.style)) {
                var n, r = "#modernizr{width:0;height:0}";
                Modernizr.supports ? n = "@supports (perspective: 1px)" : (n = "@media (transform-3d)", t && (n += ",(-webkit-transform-3d)")), n += "{#modernizr{width:7px;height:18px;margin:0;padding:0;border:0}}", B(r + n, function(t) {
                    e = 7 === t.offsetWidth && 18 === t.offsetHeight
                })
            }
            return e
        }), Modernizr.addTest("csstransitions", y("transition", "all", !0));
    var J = k.prefixed = function(e, t, n) {
        return 0 === e.indexOf("@") ? V(e) : (-1 != e.indexOf("-") && (e = c(e)), t ? b(e, t, n) : b(e, "pfx"))
    };
    Modernizr.addTest("forcetouch", function() {
        return j(J("mouseforcewillbegin", e, !1), e) ? MouseEvent.WEBKIT_FORCE_AT_MOUSE_DOWN && MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN : !1
    }), Modernizr.addAsyncTest(function() {
        var t;
        try {
            t = J("indexedDB", e)
        } catch (n) {}
        if (t) {
            var r = "modernizr-" + Math.random(),
                o = t.open(r);
            o.onerror = function() {
                o.error && "InvalidStateError" === o.error.name ? u("indexeddb", !1) : (u("indexeddb", !0), T(t, r))
            }, o.onsuccess = function() {
                u("indexeddb", !0), T(t, r)
            }
        } else u("indexeddb", !1)
    }), Modernizr.addTest("getusermedia", !!J("getUserMedia", navigator)), Modernizr.addTest("matchmedia", !!J("matchMedia", e)), o(), i(x), delete k.addTest, delete k.addAsyncTest;
    for (var K = 0; K < Modernizr._q.length; K++) Modernizr._q[K]();
    e.Modernizr = Modernizr
}(window, document);
/**
  shave - Shave is a javascript plugin that truncates multi-line text within a html element based on set max height
  @version v2.5.4
  @link https://github.com/dollarshaveclub/shave#readme
  @author Jeff Wainwright <yowainwright@gmail.com> (jeffry.in)
  @license MIT
**/
!function(e){"function"==typeof define&&define.amd?define(e):e()}(function(){"use strict";if("undefined"!=typeof window){var e=window.$||window.jQuery||window.Zepto;e&&(e.fn.shave=function(e,t){return function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};if(!t)throw Error("maxHeight is required");var i="string"==typeof e?document.querySelectorAll(e):e;if(i){var a=n.character||"",o=n.classname||"js-shave",r="boolean"!=typeof n.spaces||n.spaces,s='<span class="js-shave-char">'.concat(a,"</span>");"length"in i||(i=[i]);for(var c=0;c<i.length;c+=1){var h=i[c],d=h.style,l=h.querySelector(".".concat(o)),f=void 0===h.textContent?"innerText":"textContent";l&&(h.removeChild(h.querySelector(".js-shave-char")),h[f]=h[f]);var v=h[f],g=r?v.split(" "):v;if(!(g.length<2)){var u=d.height;d.height="auto";var p=d.maxHeight;if(d.maxHeight="none",h.offsetHeight<=t)d.height=u,d.maxHeight=p;else{for(var m=g.length-1,y=0,j=void 0;y<m;)j=y+m+1>>1,h[f]=r?g.slice(0,j).join(" "):g.slice(0,j),h.insertAdjacentHTML("beforeend",s),h.offsetHeight>t?m=r?j-1:j-2:y=j;h[f]=r?g.slice(0,m).join(" "):g.slice(0,m),h.insertAdjacentHTML("beforeend",s);var w=r?" ".concat(g.slice(m).join(" ")):g.slice(m),x=document.createTextNode(w),H=document.createElement("span");H.classList.add(o),H.style.display="none",H.appendChild(x),h.insertAdjacentElement("beforeend",H),d.height=u,d.maxHeight=p}}}}}(this,e,t),this})}});

function customShave(selector, maxheight, options) {
    if (selector && maxheight) {
        options = options || {
            character: '...'
        };
        setTimeout(function () {
            $(selector).shave(maxheight, options);
        }, 1000);
    }
}

/*
 AngularJS v1.3.2
 (c) 2010-2014 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(T,U,t){'use strict';function v(b){return function(){var a=arguments[0],c;c="["+(b?b+":":"")+a+"] http://errors.angularjs.org/1.3.2/"+(b?b+"/":"")+a;for(a=1;a<arguments.length;a++){c=c+(1==a?"?":"&")+"p"+(a-1)+"=";var d=encodeURIComponent,e;e=arguments[a];e="function"==typeof e?e.toString().replace(/ \{[\s\S]*$/,""):"undefined"==typeof e?"undefined":"string"!=typeof e?JSON.stringify(e):e;c+=d(e)}return Error(c)}}function Sa(b){if(null==b||Ta(b))return!1;var a=b.length;return b.nodeType===
ka&&a?!0:G(b)||H(b)||0===a||"number"===typeof a&&0<a&&a-1 in b}function r(b,a,c){var d,e;if(b)if(u(b))for(d in b)"prototype"==d||"length"==d||"name"==d||b.hasOwnProperty&&!b.hasOwnProperty(d)||a.call(c,b[d],d,b);else if(H(b)||Sa(b)){var f="object"!==typeof b;d=0;for(e=b.length;d<e;d++)(f||d in b)&&a.call(c,b[d],d,b)}else if(b.forEach&&b.forEach!==r)b.forEach(a,c,b);else for(d in b)b.hasOwnProperty(d)&&a.call(c,b[d],d,b);return b}function Bd(b,a,c){for(var d=Object.keys(b).sort(),e=0;e<d.length;e++)a.call(c,
b[d[e]],d[e]);return d}function kc(b){return function(a,c){b(c,a)}}function Cd(){return++ib}function lc(b,a){a?b.$$hashKey=a:delete b.$$hashKey}function F(b){for(var a=b.$$hashKey,c=1,d=arguments.length;c<d;c++){var e=arguments[c];if(e)for(var f=Object.keys(e),g=0,h=f.length;g<h;g++){var k=f[g];b[k]=e[k]}}lc(b,a);return b}function aa(b){return parseInt(b,10)}function mc(b,a){return F(new (F(function(){},{prototype:b})),a)}function A(){}function la(b){return b}function da(b){return function(){return b}}
function w(b){return"undefined"===typeof b}function y(b){return"undefined"!==typeof b}function M(b){return null!==b&&"object"===typeof b}function G(b){return"string"===typeof b}function V(b){return"number"===typeof b}function ea(b){return"[object Date]"===Ka.call(b)}function u(b){return"function"===typeof b}function jb(b){return"[object RegExp]"===Ka.call(b)}function Ta(b){return b&&b.window===b}function Ua(b){return b&&b.$evalAsync&&b.$watch}function Va(b){return"boolean"===typeof b}function nc(b){return!(!b||
!(b.nodeName||b.prop&&b.attr&&b.find))}function Dd(b){var a={};b=b.split(",");var c;for(c=0;c<b.length;c++)a[b[c]]=!0;return a}function sa(b){return R(b.nodeName||b[0].nodeName)}function Wa(b,a){var c=b.indexOf(a);0<=c&&b.splice(c,1);return a}function Da(b,a,c,d){if(Ta(b)||Ua(b))throw Xa("cpws");if(a){if(b===a)throw Xa("cpi");c=c||[];d=d||[];if(M(b)){var e=c.indexOf(b);if(-1!==e)return d[e];c.push(b);d.push(a)}if(H(b))for(var f=a.length=0;f<b.length;f++)e=Da(b[f],null,c,d),M(b[f])&&(c.push(b[f]),
d.push(e)),a.push(e);else{var g=a.$$hashKey;H(a)?a.length=0:r(a,function(b,c){delete a[c]});for(f in b)b.hasOwnProperty(f)&&(e=Da(b[f],null,c,d),M(b[f])&&(c.push(b[f]),d.push(e)),a[f]=e);lc(a,g)}}else if(a=b)H(b)?a=Da(b,[],c,d):ea(b)?a=new Date(b.getTime()):jb(b)?(a=new RegExp(b.source,b.toString().match(/[^\/]*$/)[0]),a.lastIndex=b.lastIndex):M(b)&&(e=Object.create(Object.getPrototypeOf(b)),a=Da(b,e,c,d));return a}function ta(b,a){if(H(b)){a=a||[];for(var c=0,d=b.length;c<d;c++)a[c]=b[c]}else if(M(b))for(c in a=
a||{},b)if("$"!==c.charAt(0)||"$"!==c.charAt(1))a[c]=b[c];return a||b}function ma(b,a){if(b===a)return!0;if(null===b||null===a)return!1;if(b!==b&&a!==a)return!0;var c=typeof b,d;if(c==typeof a&&"object"==c)if(H(b)){if(!H(a))return!1;if((c=b.length)==a.length){for(d=0;d<c;d++)if(!ma(b[d],a[d]))return!1;return!0}}else{if(ea(b))return ea(a)?ma(b.getTime(),a.getTime()):!1;if(jb(b)&&jb(a))return b.toString()==a.toString();if(Ua(b)||Ua(a)||Ta(b)||Ta(a)||H(a))return!1;c={};for(d in b)if("$"!==d.charAt(0)&&
!u(b[d])){if(!ma(b[d],a[d]))return!1;c[d]=!0}for(d in a)if(!c.hasOwnProperty(d)&&"$"!==d.charAt(0)&&a[d]!==t&&!u(a[d]))return!1;return!0}return!1}function kb(b,a,c){return b.concat(Ya.call(a,c))}function oc(b,a){var c=2<arguments.length?Ya.call(arguments,2):[];return!u(a)||a instanceof RegExp?a:c.length?function(){return arguments.length?a.apply(b,c.concat(Ya.call(arguments,0))):a.apply(b,c)}:function(){return arguments.length?a.apply(b,arguments):a.call(b)}}function Ed(b,a){var c=a;"string"===typeof b&&
"$"===b.charAt(0)&&"$"===b.charAt(1)?c=t:Ta(a)?c="$WINDOW":a&&U===a?c="$DOCUMENT":Ua(a)&&(c="$SCOPE");return c}function ua(b,a){return"undefined"===typeof b?t:JSON.stringify(b,Ed,a?"  ":null)}function pc(b){return G(b)?JSON.parse(b):b}function va(b){b=z(b).clone();try{b.empty()}catch(a){}var c=z("<div>").append(b).html();try{return b[0].nodeType===lb?R(c):c.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/,function(a,b){return"<"+R(b)})}catch(d){return R(c)}}function qc(b){try{return decodeURIComponent(b)}catch(a){}}
function rc(b){var a={},c,d;r((b||"").split("&"),function(b){b&&(c=b.replace(/\+/g,"%20").split("="),d=qc(c[0]),y(d)&&(b=y(c[1])?qc(c[1]):!0,Ib.call(a,d)?H(a[d])?a[d].push(b):a[d]=[a[d],b]:a[d]=b))});return a}function Jb(b){var a=[];r(b,function(b,d){H(b)?r(b,function(b){a.push(Ea(d,!0)+(!0===b?"":"="+Ea(b,!0)))}):a.push(Ea(d,!0)+(!0===b?"":"="+Ea(b,!0)))});return a.length?a.join("&"):""}function mb(b){return Ea(b,!0).replace(/%26/gi,"&").replace(/%3D/gi,"=").replace(/%2B/gi,"+")}function Ea(b,a){return encodeURIComponent(b).replace(/%40/gi,
"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%20/g,a?"%20":"+")}function Fd(b,a){var c,d,e=nb.length;b=z(b);for(d=0;d<e;++d)if(c=nb[d]+a,G(c=b.attr(c)))return c;return null}function Gd(b,a){var c,d,e={};r(nb,function(a){a+="app";!c&&b.hasAttribute&&b.hasAttribute(a)&&(c=b,d=b.getAttribute(a))});r(nb,function(a){a+="app";var e;!c&&(e=b.querySelector("["+a.replace(":","\\:")+"]"))&&(c=e,d=e.getAttribute(a))});c&&(e.strictDi=null!==Fd(c,"strict-di"),
a(c,d?[d]:[],e))}function sc(b,a,c){M(c)||(c={});c=F({strictDi:!1},c);var d=function(){b=z(b);if(b.injector()){var d=b[0]===U?"document":va(b);throw Xa("btstrpd",d.replace(/</,"&lt;").replace(/>/,"&gt;"));}a=a||[];a.unshift(["$provide",function(a){a.value("$rootElement",b)}]);c.debugInfoEnabled&&a.push(["$compileProvider",function(a){a.debugInfoEnabled(!0)}]);a.unshift("ng");d=Kb(a,c.strictDi);d.invoke(["$rootScope","$rootElement","$compile","$injector",function(a,b,c,d){a.$apply(function(){b.data("$injector",
d);c(b)(a)})}]);return d},e=/^NG_ENABLE_DEBUG_INFO!/,f=/^NG_DEFER_BOOTSTRAP!/;T&&e.test(T.name)&&(c.debugInfoEnabled=!0,T.name=T.name.replace(e,""));if(T&&!f.test(T.name))return d();T.name=T.name.replace(f,"");wa.resumeBootstrap=function(b){r(b,function(b){a.push(b)});d()}}function Hd(){T.name="NG_ENABLE_DEBUG_INFO!"+T.name;T.location.reload()}function Id(b){return wa.element(b).injector().get("$$testability")}function Lb(b,a){a=a||"_";return b.replace(Jd,function(b,d){return(d?a:"")+b.toLowerCase()})}
function Kd(){var b;tc||((na=T.jQuery)&&na.fn.on?(z=na,F(na.fn,{scope:La.scope,isolateScope:La.isolateScope,controller:La.controller,injector:La.injector,inheritedData:La.inheritedData}),b=na.cleanData,na.cleanData=function(a){var c;if(Mb)Mb=!1;else for(var d=0,e;null!=(e=a[d]);d++)(c=na._data(e,"events"))&&c.$destroy&&na(e).triggerHandler("$destroy");b(a)}):z=S,wa.element=z,tc=!0)}function Nb(b,a,c){if(!b)throw Xa("areq",a||"?",c||"required");return b}function ob(b,a,c){c&&H(b)&&(b=b[b.length-1]);
Nb(u(b),a,"not a function, got "+(b&&"object"===typeof b?b.constructor.name||"Object":typeof b));return b}function Ma(b,a){if("hasOwnProperty"===b)throw Xa("badname",a);}function uc(b,a,c){if(!a)return b;a=a.split(".");for(var d,e=b,f=a.length,g=0;g<f;g++)d=a[g],b&&(b=(e=b)[d]);return!c&&u(b)?oc(e,b):b}function pb(b){var a=b[0];b=b[b.length-1];var c=[a];do{a=a.nextSibling;if(!a)break;c.push(a)}while(a!==b);return z(c)}function oa(){return Object.create(null)}function Ld(b){function a(a,b,c){return a[b]||
(a[b]=c())}var c=v("$injector"),d=v("ng");b=a(b,"angular",Object);b.$$minErr=b.$$minErr||v;return a(b,"module",function(){var b={};return function(f,g,h){if("hasOwnProperty"===f)throw d("badname","module");g&&b.hasOwnProperty(f)&&(b[f]=null);return a(b,f,function(){function a(c,d,e,f){f||(f=b);return function(){f[e||"push"]([c,d,arguments]);return n}}if(!g)throw c("nomod",f);var b=[],d=[],e=[],q=a("$injector","invoke","push",d),n={_invokeQueue:b,_configBlocks:d,_runBlocks:e,requires:g,name:f,provider:a("$provide",
"provider"),factory:a("$provide","factory"),service:a("$provide","service"),value:a("$provide","value"),constant:a("$provide","constant","unshift"),animation:a("$animateProvider","register"),filter:a("$filterProvider","register"),controller:a("$controllerProvider","register"),directive:a("$compileProvider","directive"),config:q,run:function(a){e.push(a);return this}};h&&q(h);return n})}})}function Md(b){F(b,{bootstrap:sc,copy:Da,extend:F,equals:ma,element:z,forEach:r,injector:Kb,noop:A,bind:oc,toJson:ua,
fromJson:pc,identity:la,isUndefined:w,isDefined:y,isString:G,isFunction:u,isObject:M,isNumber:V,isElement:nc,isArray:H,version:Nd,isDate:ea,lowercase:R,uppercase:qb,callbacks:{counter:0},getTestability:Id,$$minErr:v,$$csp:Za,reloadWithDebugInfo:Hd});$a=Ld(T);try{$a("ngLocale")}catch(a){$a("ngLocale",[]).provider("$locale",Od)}$a("ng",["ngLocale"],["$provide",function(a){a.provider({$$sanitizeUri:Pd});a.provider("$compile",vc).directive({a:Qd,input:wc,textarea:wc,form:Rd,script:Sd,select:Td,style:Ud,
option:Vd,ngBind:Wd,ngBindHtml:Xd,ngBindTemplate:Yd,ngClass:Zd,ngClassEven:$d,ngClassOdd:ae,ngCloak:be,ngController:ce,ngForm:de,ngHide:ee,ngIf:fe,ngInclude:ge,ngInit:he,ngNonBindable:ie,ngPluralize:je,ngRepeat:ke,ngShow:le,ngStyle:me,ngSwitch:ne,ngSwitchWhen:oe,ngSwitchDefault:pe,ngOptions:qe,ngTransclude:re,ngModel:se,ngList:te,ngChange:ue,pattern:xc,ngPattern:xc,required:yc,ngRequired:yc,minlength:zc,ngMinlength:zc,maxlength:Ac,ngMaxlength:Ac,ngValue:ve,ngModelOptions:we}).directive({ngInclude:xe}).directive(rb).directive(Bc);
a.provider({$anchorScroll:ye,$animate:ze,$browser:Ae,$cacheFactory:Be,$controller:Ce,$document:De,$exceptionHandler:Ee,$filter:Cc,$interpolate:Fe,$interval:Ge,$http:He,$httpBackend:Ie,$location:Je,$log:Ke,$parse:Le,$rootScope:Me,$q:Ne,$$q:Oe,$sce:Pe,$sceDelegate:Qe,$sniffer:Re,$templateCache:Se,$templateRequest:Te,$$testability:Ue,$timeout:Ve,$window:We,$$rAF:Xe,$$asyncCallback:Ye})}])}function ab(b){return b.replace(Ze,function(a,b,d,e){return e?d.toUpperCase():d}).replace($e,"Moz$1")}function Dc(b){b=
b.nodeType;return b===ka||!b||9===b}function Ec(b,a){var c,d,e=a.createDocumentFragment(),f=[];if(Ob.test(b)){c=c||e.appendChild(a.createElement("div"));d=(af.exec(b)||["",""])[1].toLowerCase();d=ha[d]||ha._default;c.innerHTML=d[1]+b.replace(bf,"<$1></$2>")+d[2];for(d=d[0];d--;)c=c.lastChild;f=kb(f,c.childNodes);c=e.firstChild;c.textContent=""}else f.push(a.createTextNode(b));e.textContent="";e.innerHTML="";r(f,function(a){e.appendChild(a)});return e}function S(b){if(b instanceof S)return b;var a;
G(b)&&(b=P(b),a=!0);if(!(this instanceof S)){if(a&&"<"!=b.charAt(0))throw Pb("nosel");return new S(b)}if(a){a=U;var c;b=(c=cf.exec(b))?[a.createElement(c[1])]:(c=Ec(b,a))?c.childNodes:[]}Fc(this,b)}function Qb(b){return b.cloneNode(!0)}function sb(b,a){a||tb(b);if(b.querySelectorAll)for(var c=b.querySelectorAll("*"),d=0,e=c.length;d<e;d++)tb(c[d])}function Gc(b,a,c,d){if(y(d))throw Pb("offargs");var e=(d=ub(b))&&d.events,f=d&&d.handle;if(f)if(a)r(a.split(" "),function(a){if(y(c)){var d=e[a];Wa(d||
[],c);if(d&&0<d.length)return}b.removeEventListener(a,f,!1);delete e[a]});else for(a in e)"$destroy"!==a&&b.removeEventListener(a,f,!1),delete e[a]}function tb(b,a){var c=b.ng339,d=c&&vb[c];d&&(a?delete d.data[a]:(d.handle&&(d.events.$destroy&&d.handle({},"$destroy"),Gc(b)),delete vb[c],b.ng339=t))}function ub(b,a){var c=b.ng339,c=c&&vb[c];a&&!c&&(b.ng339=c=++df,c=vb[c]={events:{},data:{},handle:t});return c}function Rb(b,a,c){if(Dc(b)){var d=y(c),e=!d&&a&&!M(a),f=!a;b=(b=ub(b,!e))&&b.data;if(d)b[a]=
c;else{if(f)return b;if(e)return b&&b[a];F(b,a)}}}function Sb(b,a){return b.getAttribute?-1<(" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").indexOf(" "+a+" "):!1}function Tb(b,a){a&&b.setAttribute&&r(a.split(" "),function(a){b.setAttribute("class",P((" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").replace(" "+P(a)+" "," ")))})}function Ub(b,a){if(a&&b.setAttribute){var c=(" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ");r(a.split(" "),function(a){a=P(a);-1===
c.indexOf(" "+a+" ")&&(c+=a+" ")});b.setAttribute("class",P(c))}}function Fc(b,a){if(a)if(a.nodeType)b[b.length++]=a;else{var c=a.length;if("number"===typeof c&&a.window!==a){if(c)for(var d=0;d<c;d++)b[b.length++]=a[d]}else b[b.length++]=a}}function Hc(b,a){return wb(b,"$"+(a||"ngController")+"Controller")}function wb(b,a,c){9==b.nodeType&&(b=b.documentElement);for(a=H(a)?a:[a];b;){for(var d=0,e=a.length;d<e;d++)if((c=z.data(b,a[d]))!==t)return c;b=b.parentNode||11===b.nodeType&&b.host}}function Ic(b){for(sb(b,
!0);b.firstChild;)b.removeChild(b.firstChild)}function Jc(b,a){a||sb(b);var c=b.parentNode;c&&c.removeChild(b)}function ef(b,a){a=a||T;if("complete"===a.document.readyState)a.setTimeout(b);else z(a).on("load",b)}function Kc(b,a){var c=xb[a.toLowerCase()];return c&&Lc[sa(b)]&&c}function ff(b,a){var c=b.nodeName;return("INPUT"===c||"TEXTAREA"===c)&&Mc[a]}function gf(b,a){var c=function(c,e){c.isDefaultPrevented=function(){return c.defaultPrevented};var f=a[e||c.type],g=f?f.length:0;if(g){if(w(c.immediatePropagationStopped)){var h=
c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=!0;c.stopPropagation&&c.stopPropagation();h&&h.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};1<g&&(f=ta(f));for(var k=0;k<g;k++)c.isImmediatePropagationStopped()||f[k].call(b,c)}};c.elem=b;return c}function Na(b,a){var c=b&&b.$$hashKey;if(c)return"function"===typeof c&&(c=b.$$hashKey()),c;c=typeof b;return c="function"==c||"object"==c&&null!==b?b.$$hashKey=
c+":"+(a||Cd)():c+":"+b}function bb(b,a){if(a){var c=0;this.nextUid=function(){return++c}}r(b,this.put,this)}function hf(b){return(b=b.toString().replace(Nc,"").match(Oc))?"function("+(b[1]||"").replace(/[\s\r\n]+/," ")+")":"fn"}function Vb(b,a,c){var d;if("function"===typeof b){if(!(d=b.$inject)){d=[];if(b.length){if(a)throw G(c)&&c||(c=b.name||hf(b)),Fa("strictdi",c);a=b.toString().replace(Nc,"");a=a.match(Oc);r(a[1].split(jf),function(a){a.replace(kf,function(a,b,c){d.push(c)})})}b.$inject=d}}else H(b)?
(a=b.length-1,ob(b[a],"fn"),d=b.slice(0,a)):ob(b,"fn",!0);return d}function Kb(b,a){function c(a){return function(b,c){if(M(b))r(b,kc(a));else return a(b,c)}}function d(a,b){Ma(a,"service");if(u(b)||H(b))b=q.instantiate(b);if(!b.$get)throw Fa("pget",a);return p[a+"Provider"]=b}function e(a,b){return function(){var c=s.invoke(b,this,t,a);if(w(c))throw Fa("undef",a);return c}}function f(a,b,c){return d(a,{$get:!1!==c?e(a,b):b})}function g(a){var b=[],c;r(a,function(a){function d(a){var b,c;b=0;for(c=
a.length;b<c;b++){var e=a[b],f=q.get(e[0]);f[e[1]].apply(f,e[2])}}if(!m.get(a)){m.put(a,!0);try{G(a)?(c=$a(a),b=b.concat(g(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):u(a)?b.push(q.invoke(a)):H(a)?b.push(q.invoke(a)):ob(a,"module")}catch(e){throw H(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1==e.stack.indexOf(e.message)&&(e=e.message+"\n"+e.stack),Fa("modulerr",a,e.stack||e.message||e);}}});return b}function h(b,c){function d(a){if(b.hasOwnProperty(a)){if(b[a]===k)throw Fa("cdep",
a+" <- "+l.join(" <- "));return b[a]}try{return l.unshift(a),b[a]=k,b[a]=c(a)}catch(e){throw b[a]===k&&delete b[a],e;}finally{l.shift()}}function e(b,c,f,g){"string"===typeof f&&(g=f,f=null);var k=[];g=Vb(b,a,g);var h,l,n;l=0;for(h=g.length;l<h;l++){n=g[l];if("string"!==typeof n)throw Fa("itkn",n);k.push(f&&f.hasOwnProperty(n)?f[n]:d(n))}H(b)&&(b=b[h]);return b.apply(c,k)}return{invoke:e,instantiate:function(a,b,c){var d=function(){};d.prototype=(H(a)?a[a.length-1]:a).prototype;d=new d;a=e(a,d,b,
c);return M(a)||u(a)?a:d},get:d,annotate:Vb,has:function(a){return p.hasOwnProperty(a+"Provider")||b.hasOwnProperty(a)}}}a=!0===a;var k={},l=[],m=new bb([],!0),p={$provide:{provider:c(d),factory:c(f),service:c(function(a,b){return f(a,["$injector",function(a){return a.instantiate(b)}])}),value:c(function(a,b){return f(a,da(b),!1)}),constant:c(function(a,b){Ma(a,"constant");p[a]=b;n[a]=b}),decorator:function(a,b){var c=q.get(a+"Provider"),d=c.$get;c.$get=function(){var a=s.invoke(d,c);return s.invoke(b,
null,{$delegate:a})}}}},q=p.$injector=h(p,function(){throw Fa("unpr",l.join(" <- "));}),n={},s=n.$injector=h(n,function(a){var b=q.get(a+"Provider");return s.invoke(b.$get,b,t,a)});r(g(b),function(a){s.invoke(a||A)});return s}function ye(){var b=!0;this.disableAutoScrolling=function(){b=!1};this.$get=["$window","$location","$rootScope",function(a,c,d){function e(a){var b=null;Array.prototype.some.call(a,function(a){if("a"===sa(a))return b=a,!0});return b}function f(b){if(b){b.scrollIntoView();var c;
c=g.yOffset;u(c)?c=c():nc(c)?(c=c[0],c="fixed"!==a.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):V(c)||(c=0);c&&(b=b.getBoundingClientRect().top,a.scrollBy(0,b-c))}else a.scrollTo(0,0)}function g(){var a=c.hash(),b;a?(b=h.getElementById(a))?f(b):(b=e(h.getElementsByName(a)))?f(b):"top"===a&&f(null):f(null)}var h=a.document;b&&d.$watch(function(){return c.hash()},function(a,b){a===b&&""===a||ef(function(){d.$evalAsync(g)})});return g}]}function Ye(){this.$get=["$$rAF","$timeout",
function(b,a){return b.supported?function(a){return b(a)}:function(b){return a(b,0,!1)}}]}function lf(b,a,c,d){function e(a){try{a.apply(null,Ya.call(arguments,1))}finally{if(x--,0===x)for(;B.length;)try{B.pop()()}catch(b){c.error(b)}}}function f(a,b){(function za(){r(K,function(a){a()});E=b(za,a)})()}function g(){h();k()}function h(){I=b.history.state;I=w(I)?null:I;ma(I,Q)&&(I=Q);Q=I}function k(){if(C!==m.url()||J!==I)C=m.url(),J=I,r(W,function(a){a(m.url(),I)})}function l(a){try{return decodeURIComponent(a)}catch(b){return a}}
var m=this,p=a[0],q=b.location,n=b.history,s=b.setTimeout,O=b.clearTimeout,D={};m.isMock=!1;var x=0,B=[];m.$$completeOutstandingRequest=e;m.$$incOutstandingRequestCount=function(){x++};m.notifyWhenNoOutstandingRequests=function(a){r(K,function(a){a()});0===x?a():B.push(a)};var K=[],E;m.addPollFn=function(a){w(E)&&f(100,s);K.push(a);return a};var I,J,C=q.href,ca=a.find("base"),N=null;h();J=I;m.url=function(a,c,e){w(e)&&(e=null);q!==b.location&&(q=b.location);n!==b.history&&(n=b.history);if(a){var f=
J===e;if(C!==a||d.history&&!f){var g=C&&Ga(C)===Ga(a);C=a;J=e;!d.history||g&&f?(g||(N=a),c?q.replace(a):q.href=a):(n[c?"replaceState":"pushState"](e,"",a),h(),J=I);return m}}else return N||q.href.replace(/%27/g,"'")};m.state=function(){return I};var W=[],X=!1,Q=null;m.onUrlChange=function(a){if(!X){if(d.history)z(b).on("popstate",g);z(b).on("hashchange",g);X=!0}W.push(a);return a};m.$$checkUrlChange=k;m.baseHref=function(){var a=ca.attr("href");return a?a.replace(/^(https?\:)?\/\/[^\/]*/,""):""};
var ba={},y="",fa=m.baseHref();m.cookies=function(a,b){var d,e,f,g;if(a)b===t?p.cookie=encodeURIComponent(a)+"=;path="+fa+";expires=Thu, 01 Jan 1970 00:00:00 GMT":G(b)&&(d=(p.cookie=encodeURIComponent(a)+"="+encodeURIComponent(b)+";path="+fa).length+1,4096<d&&c.warn("Cookie '"+a+"' possibly not set or overflowed because it was too large ("+d+" > 4096 bytes)!"));else{if(p.cookie!==y)for(y=p.cookie,d=y.split("; "),ba={},f=0;f<d.length;f++)e=d[f],g=e.indexOf("="),0<g&&(a=l(e.substring(0,g)),ba[a]===
t&&(ba[a]=l(e.substring(g+1))));return ba}};m.defer=function(a,b){var c;x++;c=s(function(){delete D[c];e(a)},b||0);D[c]=!0;return c};m.defer.cancel=function(a){return D[a]?(delete D[a],O(a),e(A),!0):!1}}function Ae(){this.$get=["$window","$log","$sniffer","$document",function(b,a,c,d){return new lf(b,d,a,c)}]}function Be(){this.$get=function(){function b(b,d){function e(a){a!=p&&(q?q==a&&(q=a.n):q=a,f(a.n,a.p),f(a,p),p=a,p.n=null)}function f(a,b){a!=b&&(a&&(a.p=b),b&&(b.n=a))}if(b in a)throw v("$cacheFactory")("iid",
b);var g=0,h=F({},d,{id:b}),k={},l=d&&d.capacity||Number.MAX_VALUE,m={},p=null,q=null;return a[b]={put:function(a,b){if(l<Number.MAX_VALUE){var c=m[a]||(m[a]={key:a});e(c)}if(!w(b))return a in k||g++,k[a]=b,g>l&&this.remove(q.key),b},get:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;e(b)}return k[a]},remove:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;b==p&&(p=b.p);b==q&&(q=b.n);f(b.n,b.p);delete m[a]}delete k[a];g--},removeAll:function(){k={};g=0;m={};p=q=null},destroy:function(){m=
h=k=null;delete a[b]},info:function(){return F({},h,{size:g})}}}var a={};b.info=function(){var b={};r(a,function(a,e){b[e]=a.info()});return b};b.get=function(b){return a[b]};return b}}function Se(){this.$get=["$cacheFactory",function(b){return b("templates")}]}function vc(b,a){function c(a,b){var c=/^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/,d={};r(a,function(a,e){var f=a.match(c);if(!f)throw ia("iscp",b,e,a);d[e]={mode:f[1][0],collection:"*"===f[2],optional:"?"===f[3],attrName:f[4]||e}});return d}var d=
{},e=/^\s*directive\:\s*([\w\-]+)\s+(.*)$/,f=/(([\w\-]+)(?:\:([^;]+))?;?)/,g=Dd("ngSrc,ngSrcset,src,srcset"),h=/^(?:(\^\^?)?(\?)?(\^\^?)?)?/,k=/^(on[a-z]+|formaction)$/;this.directive=function p(a,e){Ma(a,"directive");G(a)?(Nb(e,"directiveFactory"),d.hasOwnProperty(a)||(d[a]=[],b.factory(a+"Directive",["$injector","$exceptionHandler",function(b,e){var f=[];r(d[a],function(d,g){try{var k=b.invoke(d);u(k)?k={compile:da(k)}:!k.compile&&k.link&&(k.compile=da(k.link));k.priority=k.priority||0;k.index=
g;k.name=k.name||a;k.require=k.require||k.controller&&k.name;k.restrict=k.restrict||"EA";M(k.scope)&&(k.$$isolateBindings=c(k.scope,k.name));f.push(k)}catch(h){e(h)}});return f}])),d[a].push(e)):r(a,kc(p));return this};this.aHrefSanitizationWhitelist=function(b){return y(b)?(a.aHrefSanitizationWhitelist(b),this):a.aHrefSanitizationWhitelist()};this.imgSrcSanitizationWhitelist=function(b){return y(b)?(a.imgSrcSanitizationWhitelist(b),this):a.imgSrcSanitizationWhitelist()};var l=!0;this.debugInfoEnabled=
function(a){return y(a)?(l=a,this):l};this.$get=["$injector","$interpolate","$exceptionHandler","$templateRequest","$parse","$controller","$rootScope","$document","$sce","$animate","$$sanitizeUri",function(a,b,c,s,O,D,x,B,K,E,I){function J(a,b){try{a.addClass(b)}catch(c){}}function C(a,b,c,d,e){a instanceof z||(a=z(a));r(a,function(b,c){b.nodeType==lb&&b.nodeValue.match(/\S+/)&&(a[c]=z(b).wrap("<span></span>").parent()[0])});var f=ca(a,b,a,c,d,e);C.$$addScopeClass(a);var g=null;return function(b,
c,d){Nb(b,"scope");d=d||{};var e=d.parentBoundTranscludeFn,k=d.transcludeControllers;d=d.futureParentElement;e&&e.$$boundTransclude&&(e=e.$$boundTransclude);g||(g=(d=d&&d[0])?"foreignobject"!==sa(d)&&d.toString().match(/SVG/)?"svg":"html":"html");d="html"!==g?z(T(g,z("<div>").append(a).html())):c?La.clone.call(a):a;if(k)for(var h in k)d.data("$"+h+"Controller",k[h].instance);C.$$addScopeInfo(d,b);c&&c(d,b);f&&f(b,d,d,e);return d}}function ca(a,b,c,d,e,f){function g(a,c,d,e){var f,h,l,q,n,p,B;if(s)for(B=
Array(c.length),q=0;q<k.length;q+=3)f=k[q],B[f]=c[f];else B=c;q=0;for(n=k.length;q<n;)h=B[k[q++]],c=k[q++],f=k[q++],c?(c.scope?(l=a.$new(),C.$$addScopeInfo(z(h),l)):l=a,p=c.transcludeOnThisElement?N(a,c.transclude,e,c.elementTranscludeOnThisElement):!c.templateOnThisElement&&e?e:!e&&b?N(a,b):null,c(f,l,h,d,p)):f&&f(a,h.childNodes,t,e)}for(var k=[],h,l,q,n,s,p=0;p<a.length;p++){h=new V;l=W(a[p],[],h,0===p?d:t,e);(f=l.length?ba(l,a[p],h,b,c,null,[],[],f):null)&&f.scope&&C.$$addScopeClass(h.$$element);
h=f&&f.terminal||!(q=a[p].childNodes)||!q.length?null:ca(q,f?(f.transcludeOnThisElement||!f.templateOnThisElement)&&f.transclude:b);if(f||h)k.push(p,f,h),n=!0,s=s||f;f=null}return n?g:null}function N(a,b,c,d){return function(d,e,f,g,k){d||(d=a.$new(!1,k),d.$$transcluded=!0);return b(d,e,{parentBoundTranscludeFn:c,transcludeControllers:f,futureParentElement:g})}}function W(b,c,g,k,h){var l=g.$attr,q;switch(b.nodeType){case ka:fa(c,xa(sa(b)),"E",k,h);for(var n,s,B,O=b.attributes,D=0,K=O&&O.length;D<
K;D++){var I=!1,J=!1;n=O[D];q=n.name;n=P(n.value);s=xa(q);if(B=Aa.test(s))q=Lb(s.substr(6),"-");var x=s.replace(/(Start|End)$/,""),C;a:{var E=x;if(d.hasOwnProperty(E)){C=void 0;for(var E=a.get(E+"Directive"),r=0,ca=E.length;r<ca;r++)if(C=E[r],C.multiElement){C=!0;break a}}C=!1}C&&s===x+"Start"&&(I=q,J=q.substr(0,q.length-5)+"end",q=q.substr(0,q.length-6));s=xa(q.toLowerCase());l[s]=q;if(B||!g.hasOwnProperty(s))g[s]=n,Kc(b,s)&&(g[s]=!0);S(b,c,n,s,B);fa(c,s,"A",k,h,I,J)}b=b.className;if(G(b)&&""!==
b)for(;q=f.exec(b);)s=xa(q[2]),fa(c,s,"C",k,h)&&(g[s]=P(q[3])),b=b.substr(q.index+q[0].length);break;case lb:Y(c,b.nodeValue);break;case 8:try{if(q=e.exec(b.nodeValue))s=xa(q[1]),fa(c,s,"M",k,h)&&(g[s]=P(q[2]))}catch(W){}}c.sort(v);return c}function X(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw ia("uterdir",b,c);a.nodeType==ka&&(a.hasAttribute(b)&&e++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return z(d)}function Q(a,b,c){return function(d,
e,f,g,k){e=X(e[0],b,c);return a(d,e,f,g,k)}}function ba(a,d,e,f,g,k,l,s,p){function B(a,b,c,d){if(a){c&&(a=Q(a,c,d));a.require=L.require;a.directiveName=ga;if(N===L||L.$$isolateScope)a=Z(a,{isolateScope:!0});l.push(a)}if(b){c&&(b=Q(b,c,d));b.require=L.require;b.directiveName=ga;if(N===L||L.$$isolateScope)b=Z(b,{isolateScope:!0});s.push(b)}}function K(a,b,c,d){var e,f="data",g=!1,k=c,l;if(G(b)){l=b.match(h);b=b.substring(l[0].length);l[3]&&(l[1]?l[3]=null:l[1]=l[3]);"^"===l[1]?f="inheritedData":"^^"===
l[1]&&(f="inheritedData",k=c.parent());"?"===l[2]&&(g=!0);e=null;d&&"data"===f&&(e=d[b])&&(e=e.instance);e=e||k[f]("$"+b+"Controller");if(!e&&!g)throw ia("ctreq",b,a);return e||null}H(b)&&(e=[],r(b,function(b){e.push(K(a,b,c,d))}));return e}function I(a,c,f,g,k){function h(a,b,c){var d;Ua(a)||(c=b,b=a,a=t);F&&(d=x);c||(c=F?W.parent():W);return k(a,b,d,c,Wb)}var n,p,B,J,x,cb,W,Q;d===f?(Q=e,W=e.$$element):(W=z(f),Q=new V(W,e));N&&(J=c.$new(!0));k&&(cb=h,cb.$$boundTransclude=k);E&&(ca={},x={},r(E,function(a){var b=
{$scope:a===N||a.$$isolateScope?J:c,$element:W,$attrs:Q,$transclude:cb};B=a.controller;"@"==B&&(B=Q[a.name]);b=D(B,b,!0,a.controllerAs);x[a.name]=b;F||W.data("$"+a.name+"Controller",b.instance);ca[a.name]=b}));if(N){C.$$addScopeInfo(W,J,!0,!(ba&&(ba===N||ba===N.$$originalDirective)));C.$$addScopeClass(W,!0);g=ca&&ca[N.name];var X=J;g&&g.identifier&&!0===N.bindToController&&(X=g.instance);r(J.$$isolateBindings=N.$$isolateBindings,function(a,d){var e=a.attrName,f=a.optional,g,k,h,l;switch(a.mode){case "@":Q.$observe(e,
function(a){X[d]=a});Q.$$observers[e].$$scope=c;Q[e]&&(X[d]=b(Q[e])(c));break;case "=":if(f&&!Q[e])break;k=O(Q[e]);l=k.literal?ma:function(a,b){return a===b||a!==a&&b!==b};h=k.assign||function(){g=X[d]=k(c);throw ia("nonassign",Q[e],N.name);};g=X[d]=k(c);f=function(a){l(a,X[d])||(l(a,g)?h(c,a=X[d]):X[d]=a);return g=a};f.$stateful=!0;f=a.collection?c.$watchCollection(Q[e],f):c.$watch(O(Q[e],f),null,k.literal);J.$on("$destroy",f);break;case "&":k=O(Q[e]),X[d]=function(a){return k(c,a)}}})}ca&&(r(ca,
function(a){a()}),ca=null);g=0;for(n=l.length;g<n;g++)p=l[g],$(p,p.isolateScope?J:c,W,Q,p.require&&K(p.directiveName,p.require,W,x),cb);var Wb=c;N&&(N.template||null===N.templateUrl)&&(Wb=J);a&&a(Wb,f.childNodes,t,k);for(g=s.length-1;0<=g;g--)p=s[g],$(p,p.isolateScope?J:c,W,Q,p.require&&K(p.directiveName,p.require,W,x),cb)}p=p||{};for(var J=-Number.MAX_VALUE,x,E=p.controllerDirectives,ca,N=p.newIsolateScopeDirective,ba=p.templateDirective,fa=p.nonTlbTranscludeDirective,A=!1,Oa=!1,F=p.hasElementTranscludeDirective,
Y=e.$$element=z(d),L,ga,v,Ha=f,R,S=0,Aa=a.length;S<Aa;S++){L=a[S];var yb=L.$$start,aa=L.$$end;yb&&(Y=X(d,yb,aa));v=t;if(J>L.priority)break;if(v=L.scope)L.templateUrl||(M(v)?(za("new/isolated scope",N||x,L,Y),N=L):za("new/isolated scope",N,L,Y)),x=x||L;ga=L.name;!L.templateUrl&&L.controller&&(v=L.controller,E=E||{},za("'"+ga+"' controller",E[ga],L,Y),E[ga]=L);if(v=L.transclude)A=!0,L.$$tlb||(za("transclusion",fa,L,Y),fa=L),"element"==v?(F=!0,J=L.priority,v=Y,Y=e.$$element=z(U.createComment(" "+ga+
": "+e[ga]+" ")),d=Y[0],zb(g,Ya.call(v,0),d),Ha=C(v,f,J,k&&k.name,{nonTlbTranscludeDirective:fa})):(v=z(Qb(d)).contents(),Y.empty(),Ha=C(v,f));if(L.template)if(Oa=!0,za("template",ba,L,Y),ba=L,v=u(L.template)?L.template(Y,e):L.template,v=Pc(v),L.replace){k=L;v=Ob.test(v)?Qc(T(L.templateNamespace,P(v))):[];d=v[0];if(1!=v.length||d.nodeType!==ka)throw ia("tplrt",ga,"");zb(g,Y,d);Aa={$attr:{}};v=W(d,[],Aa);var nf=a.splice(S+1,a.length-(S+1));N&&y(v);a=a.concat(v).concat(nf);w(e,Aa);Aa=a.length}else Y.html(v);
if(L.templateUrl)Oa=!0,za("template",ba,L,Y),ba=L,L.replace&&(k=L),I=mf(a.splice(S,a.length-S),Y,e,g,A&&Ha,l,s,{controllerDirectives:E,newIsolateScopeDirective:N,templateDirective:ba,nonTlbTranscludeDirective:fa}),Aa=a.length;else if(L.compile)try{R=L.compile(Y,e,Ha),u(R)?B(null,R,yb,aa):R&&B(R.pre,R.post,yb,aa)}catch(da){c(da,va(Y))}L.terminal&&(I.terminal=!0,J=Math.max(J,L.priority))}I.scope=x&&!0===x.scope;I.transcludeOnThisElement=A;I.elementTranscludeOnThisElement=F;I.templateOnThisElement=Oa;
I.transclude=Ha;p.hasElementTranscludeDirective=F;return I}function y(a){for(var b=0,c=a.length;b<c;b++)a[b]=mc(a[b],{$$isolateScope:!0})}function fa(b,e,f,g,k,h,l){if(e===k)return null;k=null;if(d.hasOwnProperty(e)){var q;e=a.get(e+"Directive");for(var s=0,B=e.length;s<B;s++)try{q=e[s],(g===t||g>q.priority)&&-1!=q.restrict.indexOf(f)&&(h&&(q=mc(q,{$$start:h,$$end:l})),b.push(q),k=q)}catch(O){c(O)}}return k}function w(a,b){var c=b.$attr,d=a.$attr,e=a.$$element;r(a,function(d,e){"$"!=e.charAt(0)&&
(b[e]&&b[e]!==d&&(d+=("style"===e?";":" ")+b[e]),a.$set(e,d,!0,c[e]))});r(b,function(b,f){"class"==f?(J(e,b),a["class"]=(a["class"]?a["class"]+" ":"")+b):"style"==f?(e.attr("style",e.attr("style")+";"+b),a.style=(a.style?a.style+";":"")+b):"$"==f.charAt(0)||a.hasOwnProperty(f)||(a[f]=b,d[f]=c[f])})}function mf(a,b,c,d,e,f,g,k){var h=[],l,q,p=b[0],n=a.shift(),B=F({},n,{templateUrl:null,transclude:null,replace:null,$$originalDirective:n}),O=u(n.templateUrl)?n.templateUrl(b,c):n.templateUrl,D=n.templateNamespace;
b.empty();s(K.getTrustedResourceUrl(O)).then(function(s){var I,K;s=Pc(s);if(n.replace){s=Ob.test(s)?Qc(T(D,P(s))):[];I=s[0];if(1!=s.length||I.nodeType!==ka)throw ia("tplrt",n.name,O);s={$attr:{}};zb(d,b,I);var x=W(I,[],s);M(n.scope)&&y(x);a=x.concat(a);w(c,s)}else I=p,b.html(s);a.unshift(B);l=ba(a,I,c,e,b,n,f,g,k);r(d,function(a,c){a==I&&(d[c]=b[0])});for(q=ca(b[0].childNodes,e);h.length;){s=h.shift();K=h.shift();var E=h.shift(),C=h.shift(),x=b[0];if(!s.$$destroyed){if(K!==p){var Q=K.className;k.hasElementTranscludeDirective&&
n.replace||(x=Qb(I));zb(E,z(K),x);J(z(x),Q)}K=l.transcludeOnThisElement?N(s,l.transclude,C):C;l(q,s,x,d,K)}}h=null});return function(a,b,c,d,e){a=e;b.$$destroyed||(h?(h.push(b),h.push(c),h.push(d),h.push(a)):(l.transcludeOnThisElement&&(a=N(b,l.transclude,e)),l(q,b,c,d,a)))}}function v(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function za(a,b,c,d){if(b)throw ia("multidir",b.name,c.name,a,va(d));}function Y(a,c){var d=b(c,!0);d&&a.push({priority:0,
compile:function(a){a=a.parent();var b=!!a.length;b&&C.$$addBindingClass(a);return function(a,c){var e=c.parent();b||C.$$addBindingClass(e);C.$$addBindingInfo(e,d.expressions);a.$watch(d,function(a){c[0].nodeValue=a})}}})}function T(a,b){a=R(a||"html");switch(a){case "svg":case "math":var c=U.createElement("div");c.innerHTML="<"+a+">"+b+"</"+a+">";return c.childNodes[0].childNodes;default:return b}}function Ha(a,b){if("srcdoc"==b)return K.HTML;var c=sa(a);if("xlinkHref"==b||"form"==c&&"action"==b||
"img"!=c&&("src"==b||"ngSrc"==b))return K.RESOURCE_URL}function S(a,c,d,e,f){var h=b(d,!0);if(h){if("multiple"===e&&"select"===sa(a))throw ia("selmulti",va(a));c.push({priority:100,compile:function(){return{pre:function(c,d,l){d=l.$$observers||(l.$$observers={});if(k.test(e))throw ia("nodomevents");l[e]&&(h=b(l[e],!0,Ha(a,e),g[e]||f))&&(l[e]=h(c),(d[e]||(d[e]=[])).$$inter=!0,(l.$$observers&&l.$$observers[e].$$scope||c).$watch(h,function(a,b){"class"===e&&a!=b?l.$updateClass(a,b):l.$set(e,a)}))}}}})}}
function zb(a,b,c){var d=b[0],e=b.length,f=d.parentNode,g,k;if(a)for(g=0,k=a.length;g<k;g++)if(a[g]==d){a[g++]=c;k=g+e-1;for(var h=a.length;g<h;g++,k++)k<h?a[g]=a[k]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=U.createDocumentFragment();a.appendChild(d);z(c).data(z(d).data());na?(Mb=!0,na.cleanData([d])):delete z.cache[d[z.expando]];d=1;for(e=b.length;d<e;d++)f=b[d],z(f).remove(),a.appendChild(f),delete b[d];b[0]=c;b.length=1}function Z(a,b){return F(function(){return a.apply(null,
arguments)},a,b)}function $(a,b,d,e,f,g){try{a(b,d,e,f,g)}catch(k){c(k,va(d))}}var V=function(a,b){if(b){var c=Object.keys(b),d,e,f;d=0;for(e=c.length;d<e;d++)f=c[d],this[f]=b[f]}else this.$attr={};this.$$element=a};V.prototype={$normalize:xa,$addClass:function(a){a&&0<a.length&&E.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&E.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=Rc(a,b);c&&c.length&&E.addClass(this.$$element,c);(c=Rc(b,a))&&c.length&&E.removeClass(this.$$element,
c)},$set:function(a,b,d,e){var f=this.$$element[0],g=Kc(f,a),k=ff(f,a),f=a;g?(this.$$element.prop(a,b),e=g):k&&(this[k]=b,f=k);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Lb(a,"-"));g=sa(this.$$element);if("a"===g&&"href"===a||"img"===g&&"src"===a)this[a]=b=I(b,"src"===a);else if("img"===g&&"srcset"===a){for(var g="",k=P(b),h=/(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/,h=/\s/.test(k)?h:/(,)/,k=k.split(h),h=Math.floor(k.length/2),l=0;l<h;l++)var q=2*l,g=g+I(P(k[q]),!0),g=g+(" "+P(k[q+
1]));k=P(k[2*l]).split(/\s/);g+=I(P(k[0]),!0);2===k.length&&(g+=" "+P(k[1]));this[a]=b=g}!1!==d&&(null===b||b===t?this.$$element.removeAttr(e):this.$$element.attr(e,b));(a=this.$$observers)&&r(a[f],function(a){try{a(b)}catch(d){c(d)}})},$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=oa()),e=d[a]||(d[a]=[]);e.push(b);x.$evalAsync(function(){!e.$$inter&&c.hasOwnProperty(a)&&b(c[a])});return function(){Wa(e,b)}}};var Oa=b.startSymbol(),ga=b.endSymbol(),Pc="{{"==Oa||"}}"==ga?la:function(a){return a.replace(/\{\{/g,
Oa).replace(/}}/g,ga)},Aa=/^ngAttr[A-Z]/;C.$$addBindingInfo=l?function(a,b){var c=a.data("$binding")||[];H(b)?c=c.concat(b):c.push(b);a.data("$binding",c)}:A;C.$$addBindingClass=l?function(a){J(a,"ng-binding")}:A;C.$$addScopeInfo=l?function(a,b,c,d){a.data(c?d?"$isolateScopeNoTemplate":"$isolateScope":"$scope",b)}:A;C.$$addScopeClass=l?function(a,b){J(a,b?"ng-isolate-scope":"ng-scope")}:A;return C}]}function xa(b){return ab(b.replace(of,""))}function Rc(b,a){var c="",d=b.split(/\s+/),e=a.split(/\s+/),
f=0;a:for(;f<d.length;f++){for(var g=d[f],h=0;h<e.length;h++)if(g==e[h])continue a;c+=(0<c.length?" ":"")+g}return c}function Qc(b){b=z(b);var a=b.length;if(1>=a)return b;for(;a--;)8===b[a].nodeType&&pf.call(b,a,1);return b}function Ce(){var b={},a=!1,c=/^(\S+)(\s+as\s+(\w+))?$/;this.register=function(a,c){Ma(a,"controller");M(a)?F(b,a):b[a]=c};this.allowGlobals=function(){a=!0};this.$get=["$injector","$window",function(d,e){function f(a,b,c,d){if(!a||!M(a.$scope))throw v("$controller")("noscp",d,
b);a.$scope[b]=c}return function(g,h,k,l){var m,p,q;k=!0===k;l&&G(l)&&(q=l);G(g)&&(l=g.match(c),p=l[1],q=q||l[3],g=b.hasOwnProperty(p)?b[p]:uc(h.$scope,p,!0)||(a?uc(e,p,!0):t),ob(g,p,!0));if(k)return k=function(){},k.prototype=(H(g)?g[g.length-1]:g).prototype,m=new k,q&&f(h,q,m,p||g.name),F(function(){d.invoke(g,m,h,p);return m},{instance:m,identifier:q});m=d.instantiate(g,h,p);q&&f(h,q,m,p||g.name);return m}}]}function De(){this.$get=["$window",function(b){return z(b.document)}]}function Ee(){this.$get=
["$log",function(b){return function(a,c){b.error.apply(b,arguments)}}]}function Xb(b,a){if(G(b)){b=b.replace(qf,"");var c=a("Content-Type");if(c&&0===c.indexOf(Sc)||rf.test(b)&&sf.test(b))b=pc(b)}return b}function Tc(b){var a={},c,d,e;if(!b)return a;r(b.split("\n"),function(b){e=b.indexOf(":");c=R(P(b.substr(0,e)));d=P(b.substr(e+1));c&&(a[c]=a[c]?a[c]+", "+d:d)});return a}function Uc(b){var a=M(b)?b:t;return function(c){a||(a=Tc(b));return c?a[R(c)]||null:a}}function Vc(b,a,c){if(u(c))return c(b,
a);r(c,function(c){b=c(b,a)});return b}function He(){var b=this.defaults={transformResponse:[Xb],transformRequest:[function(a){return M(a)&&"[object File]"!==Ka.call(a)&&"[object Blob]"!==Ka.call(a)?ua(a):a}],headers:{common:{Accept:"application/json, text/plain, */*"},post:ta(Yb),put:ta(Yb),patch:ta(Yb)},xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN"},a=!1;this.useApplyAsync=function(b){return y(b)?(a=!!b,this):a};var c=this.interceptors=[];this.$get=["$httpBackend","$browser","$cacheFactory",
"$rootScope","$q","$injector",function(d,e,f,g,h,k){function l(a){function c(a){var b=F({},a);b.data=a.data?Vc(a.data,a.headers,d.transformResponse):a.data;a=a.status;return 200<=a&&300>a?b:h.reject(b)}var d={method:"get",transformRequest:b.transformRequest,transformResponse:b.transformResponse},e=function(a){var c=b.headers,d=F({},a.headers),e,f,c=F({},c.common,c[R(a.method)]);a:for(e in c){a=R(e);for(f in d)if(R(f)===a)continue a;d[e]=c[e]}(function(a){var b;r(a,function(c,d){u(c)&&(b=c(),null!=
b?a[d]=b:delete a[d])})})(d);return d}(a);F(d,a);d.headers=e;d.method=qb(d.method);var f=[function(a){e=a.headers;var d=Vc(a.data,Uc(e),a.transformRequest);w(d)&&r(e,function(a,b){"content-type"===R(b)&&delete e[b]});w(a.withCredentials)&&!w(b.withCredentials)&&(a.withCredentials=b.withCredentials);return m(a,d,e).then(c,c)},t],g=h.when(d);for(r(n,function(a){(a.request||a.requestError)&&f.unshift(a.request,a.requestError);(a.response||a.responseError)&&f.push(a.response,a.responseError)});f.length;){a=
f.shift();var k=f.shift(),g=g.then(a,k)}g.success=function(a){g.then(function(b){a(b.data,b.status,b.headers,d)});return g};g.error=function(a){g.then(null,function(b){a(b.data,b.status,b.headers,d)});return g};return g}function m(c,f,k){function n(b,c,d,e){function f(){m(c,b,d,e)}J&&(200<=b&&300>b?J.put(r,[b,c,Tc(d),e]):J.remove(r));a?g.$applyAsync(f):(f(),g.$$phase||g.$apply())}function m(a,b,d,e){b=Math.max(b,0);(200<=b&&300>b?E.resolve:E.reject)({data:a,status:b,headers:Uc(d),config:c,statusText:e})}
function K(){var a=l.pendingRequests.indexOf(c);-1!==a&&l.pendingRequests.splice(a,1)}var E=h.defer(),I=E.promise,J,C,r=p(c.url,c.params);l.pendingRequests.push(c);I.then(K,K);!c.cache&&!b.cache||!1===c.cache||"GET"!==c.method&&"JSONP"!==c.method||(J=M(c.cache)?c.cache:M(b.cache)?b.cache:q);if(J)if(C=J.get(r),y(C)){if(C&&u(C.then))return C.then(K,K),C;H(C)?m(C[1],C[0],ta(C[2]),C[3]):m(C,200,{},"OK")}else J.put(r,I);w(C)&&((C=Wc(c.url)?e.cookies()[c.xsrfCookieName||b.xsrfCookieName]:t)&&(k[c.xsrfHeaderName||
b.xsrfHeaderName]=C),d(c.method,r,f,n,k,c.timeout,c.withCredentials,c.responseType));return I}function p(a,b){if(!b)return a;var c=[];Bd(b,function(a,b){null===a||w(a)||(H(a)||(a=[a]),r(a,function(a){M(a)&&(a=ea(a)?a.toISOString():ua(a));c.push(Ea(b)+"="+Ea(a))}))});0<c.length&&(a+=(-1==a.indexOf("?")?"?":"&")+c.join("&"));return a}var q=f("$http"),n=[];r(c,function(a){n.unshift(G(a)?k.get(a):k.invoke(a))});l.pendingRequests=[];(function(a){r(arguments,function(a){l[a]=function(b,c){return l(F(c||
{},{method:a,url:b}))}})})("get","delete","head","jsonp");(function(a){r(arguments,function(a){l[a]=function(b,c,d){return l(F(d||{},{method:a,url:b,data:c}))}})})("post","put","patch");l.defaults=b;return l}]}function tf(){return new T.XMLHttpRequest}function Ie(){this.$get=["$browser","$window","$document",function(b,a,c){return uf(b,tf,b.defer,a.angular.callbacks,c[0])}]}function uf(b,a,c,d,e){function f(a,b,c){var f=e.createElement("script"),m=null;f.type="text/javascript";f.src=a;f.async=!0;
m=function(a){f.removeEventListener("load",m,!1);f.removeEventListener("error",m,!1);e.body.removeChild(f);f=null;var g=-1,n="unknown";a&&("load"!==a.type||d[b].called||(a={type:"error"}),n=a.type,g="error"===a.type?404:200);c&&c(g,n)};f.addEventListener("load",m,!1);f.addEventListener("error",m,!1);e.body.appendChild(f);return m}return function(e,h,k,l,m,p,q,n){function s(){x&&x();B&&B.abort()}function O(a,d,e,f,g){E&&c.cancel(E);x=B=null;a(d,e,f,g);b.$$completeOutstandingRequest(A)}b.$$incOutstandingRequestCount();
h=h||b.url();if("jsonp"==R(e)){var D="_"+(d.counter++).toString(36);d[D]=function(a){d[D].data=a;d[D].called=!0};var x=f(h.replace("JSON_CALLBACK","angular.callbacks."+D),D,function(a,b){O(l,a,d[D].data,"",b);d[D]=A})}else{var B=a();B.open(e,h,!0);r(m,function(a,b){y(a)&&B.setRequestHeader(b,a)});B.onload=function(){var a=B.statusText||"",b="response"in B?B.response:B.responseText,c=1223===B.status?204:B.status;0===c&&(c=b?200:"file"==Ba(h).protocol?404:0);O(l,c,b,B.getAllResponseHeaders(),a)};e=
function(){O(l,-1,null,null,"")};B.onerror=e;B.onabort=e;q&&(B.withCredentials=!0);if(n)try{B.responseType=n}catch(K){if("json"!==n)throw K;}B.send(k||null)}if(0<p)var E=c(s,p);else p&&u(p.then)&&p.then(s)}}function Fe(){var b="{{",a="}}";this.startSymbol=function(a){return a?(b=a,this):b};this.endSymbol=function(b){return b?(a=b,this):a};this.$get=["$parse","$exceptionHandler","$sce",function(c,d,e){function f(a){return"\\\\\\"+a}function g(f,g,n,s){function O(c){return c.replace(l,b).replace(m,
a)}function D(a){try{var b;var c=n?e.getTrusted(n,a):e.valueOf(a);if(null==c)b="";else{switch(typeof c){case "string":break;case "number":c=""+c;break;default:c=ua(c)}b=c}return b}catch(g){a=Zb("interr",f,g.toString()),d(a)}}s=!!s;for(var x,B,K=0,E=[],I=[],J=f.length,C=[],r=[];K<J;)if(-1!=(x=f.indexOf(b,K))&&-1!=(B=f.indexOf(a,x+h)))K!==x&&C.push(O(f.substring(K,x))),K=f.substring(x+h,B),E.push(K),I.push(c(K,D)),K=B+k,r.push(C.length),C.push("");else{K!==J&&C.push(O(f.substring(K)));break}if(n&&1<
C.length)throw Zb("noconcat",f);if(!g||E.length){var N=function(a){for(var b=0,c=E.length;b<c;b++){if(s&&w(a[b]))return;C[r[b]]=a[b]}return C.join("")};return F(function(a){var b=0,c=E.length,e=Array(c);try{for(;b<c;b++)e[b]=I[b](a);return N(e)}catch(g){a=Zb("interr",f,g.toString()),d(a)}},{exp:f,expressions:E,$$watchDelegate:function(a,b,c){var d;return a.$watchGroup(I,function(c,e){var f=N(c);u(b)&&b.call(this,f,c!==e?d:f,a);d=f},c)}})}}var h=b.length,k=a.length,l=new RegExp(b.replace(/./g,f),"g"),
m=new RegExp(a.replace(/./g,f),"g");g.startSymbol=function(){return b};g.endSymbol=function(){return a};return g}]}function Ge(){this.$get=["$rootScope","$window","$q","$$q",function(b,a,c,d){function e(e,h,k,l){var m=a.setInterval,p=a.clearInterval,q=0,n=y(l)&&!l,s=(n?d:c).defer(),O=s.promise;k=y(k)?k:0;O.then(null,null,e);O.$$intervalId=m(function(){s.notify(q++);0<k&&q>=k&&(s.resolve(q),p(O.$$intervalId),delete f[O.$$intervalId]);n||b.$apply()},h);f[O.$$intervalId]=s;return O}var f={};e.cancel=
function(b){return b&&b.$$intervalId in f?(f[b.$$intervalId].reject("canceled"),a.clearInterval(b.$$intervalId),delete f[b.$$intervalId],!0):!1};return e}]}function Od(){this.$get=function(){return{id:"en-us",NUMBER_FORMATS:{DECIMAL_SEP:".",GROUP_SEP:",",PATTERNS:[{minInt:1,minFrac:0,maxFrac:3,posPre:"",posSuf:"",negPre:"-",negSuf:"",gSize:3,lgSize:3},{minInt:1,minFrac:2,maxFrac:2,posPre:"\u00a4",posSuf:"",negPre:"(\u00a4",negSuf:")",gSize:3,lgSize:3}],CURRENCY_SYM:"$"},DATETIME_FORMATS:{MONTH:"January February March April May June July August September October November December".split(" "),
SHORTMONTH:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),DAY:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),SHORTDAY:"Sun Mon Tue Wed Thu Fri Sat".split(" "),AMPMS:["AM","PM"],medium:"MMM d, y h:mm:ss a","short":"M/d/yy h:mm a",fullDate:"EEEE, MMMM d, y",longDate:"MMMM d, y",mediumDate:"MMM d, y",shortDate:"M/d/yy",mediumTime:"h:mm:ss a",shortTime:"h:mm a"},pluralCat:function(b){return 1===b?"one":"other"}}}}function $b(b){b=b.split("/");for(var a=b.length;a--;)b[a]=
mb(b[a]);return b.join("/")}function Xc(b,a,c){b=Ba(b,c);a.$$protocol=b.protocol;a.$$host=b.hostname;a.$$port=aa(b.port)||vf[b.protocol]||null}function Yc(b,a,c){var d="/"!==b.charAt(0);d&&(b="/"+b);b=Ba(b,c);a.$$path=decodeURIComponent(d&&"/"===b.pathname.charAt(0)?b.pathname.substring(1):b.pathname);a.$$search=rc(b.search);a.$$hash=decodeURIComponent(b.hash);a.$$path&&"/"!=a.$$path.charAt(0)&&(a.$$path="/"+a.$$path)}function ya(b,a){if(0===a.indexOf(b))return a.substr(b.length)}function Ga(b){var a=
b.indexOf("#");return-1==a?b:b.substr(0,a)}function ac(b){return b.substr(0,Ga(b).lastIndexOf("/")+1)}function bc(b,a){this.$$html5=!0;a=a||"";var c=ac(b);Xc(b,this,b);this.$$parse=function(a){var e=ya(c,a);if(!G(e))throw db("ipthprfx",a,c);Yc(e,this,b);this.$$path||(this.$$path="/");this.$$compose()};this.$$compose=function(){var a=Jb(this.$$search),b=this.$$hash?"#"+mb(this.$$hash):"";this.$$url=$b(this.$$path)+(a?"?"+a:"")+b;this.$$absUrl=c+this.$$url.substr(1)};this.$$parseLinkUrl=function(d,
e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,g;(f=ya(b,d))!==t?(g=f,g=(f=ya(a,f))!==t?c+(ya("/",f)||f):b+g):(f=ya(c,d))!==t?g=c+f:c==d+"/"&&(g=c);g&&this.$$parse(g);return!!g}}function cc(b,a){var c=ac(b);Xc(b,this,b);this.$$parse=function(d){var e=ya(b,d)||ya(c,d),e="#"==e.charAt(0)?ya(a,e):this.$$html5?e:"";if(!G(e))throw db("ihshprfx",d,a);Yc(e,this,b);d=this.$$path;var f=/^\/[A-Z]:(\/.*)/;0===e.indexOf(b)&&(e=e.replace(b,""));f.exec(e)||(d=(e=f.exec(d))?e[1]:d);this.$$path=d;this.$$compose()};
this.$$compose=function(){var c=Jb(this.$$search),e=this.$$hash?"#"+mb(this.$$hash):"";this.$$url=$b(this.$$path)+(c?"?"+c:"")+e;this.$$absUrl=b+(this.$$url?a+this.$$url:"")};this.$$parseLinkUrl=function(a,c){return Ga(b)==Ga(a)?(this.$$parse(a),!0):!1}}function Zc(b,a){this.$$html5=!0;cc.apply(this,arguments);var c=ac(b);this.$$parseLinkUrl=function(d,e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,g;b==Ga(d)?f=d:(g=ya(c,d))?f=b+a+g:c===d+"/"&&(f=c);f&&this.$$parse(f);return!!f};this.$$compose=
function(){var c=Jb(this.$$search),e=this.$$hash?"#"+mb(this.$$hash):"";this.$$url=$b(this.$$path)+(c?"?"+c:"")+e;this.$$absUrl=b+a+this.$$url}}function Ab(b){return function(){return this[b]}}function $c(b,a){return function(c){if(w(c))return this[b];this[b]=a(c);this.$$compose();return this}}function Je(){var b="",a={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(a){return y(a)?(b=a,this):b};this.html5Mode=function(b){return Va(b)?(a.enabled=b,this):M(b)?(Va(b.enabled)&&(a.enabled=
b.enabled),Va(b.requireBase)&&(a.requireBase=b.requireBase),Va(b.rewriteLinks)&&(a.rewriteLinks=b.rewriteLinks),this):a};this.$get=["$rootScope","$browser","$sniffer","$rootElement",function(c,d,e,f){function g(a,b,c){var e=k.url(),f=k.$$state;try{d.url(a,b,c),k.$$state=d.state()}catch(g){throw k.url(e),k.$$state=f,g;}}function h(a,b){c.$broadcast("$locationChangeSuccess",k.absUrl(),a,k.$$state,b)}var k,l;l=d.baseHref();var m=d.url(),p;if(a.enabled){if(!l&&a.requireBase)throw db("nobase");p=m.substring(0,
m.indexOf("/",m.indexOf("//")+2))+(l||"/");l=e.history?bc:Zc}else p=Ga(m),l=cc;k=new l(p,"#"+b);k.$$parseLinkUrl(m,m);k.$$state=d.state();var q=/^\s*(javascript|mailto):/i;f.on("click",function(b){if(a.rewriteLinks&&!b.ctrlKey&&!b.metaKey&&2!=b.which){for(var e=z(b.target);"a"!==sa(e[0]);)if(e[0]===f[0]||!(e=e.parent())[0])return;var g=e.prop("href"),h=e.attr("href")||e.attr("xlink:href");M(g)&&"[object SVGAnimatedString]"===g.toString()&&(g=Ba(g.animVal).href);q.test(g)||!g||e.attr("target")||b.isDefaultPrevented()||
!k.$$parseLinkUrl(g,h)||(b.preventDefault(),k.absUrl()!=d.url()&&(c.$apply(),T.angular["ff-684208-preventDefault"]=!0))}});k.absUrl()!=m&&d.url(k.absUrl(),!0);var n=!0;d.onUrlChange(function(a,b){c.$evalAsync(function(){var d=k.absUrl(),e=k.$$state;k.$$parse(a);k.$$state=b;c.$broadcast("$locationChangeStart",a,d,b,e).defaultPrevented?(k.$$parse(d),k.$$state=e,g(d,!1,e)):(n=!1,h(d,e))});c.$$phase||c.$digest()});c.$watch(function(){var a=d.url(),b=d.state(),f=k.$$replace,l=a!==k.absUrl()||k.$$html5&&
e.history&&b!==k.$$state;if(n||l)n=!1,c.$evalAsync(function(){c.$broadcast("$locationChangeStart",k.absUrl(),a,k.$$state,b).defaultPrevented?(k.$$parse(a),k.$$state=b):(l&&g(k.absUrl(),f,b===k.$$state?null:k.$$state),h(a,b))});k.$$replace=!1});return k}]}function Ke(){var b=!0,a=this;this.debugEnabled=function(a){return y(a)?(b=a,this):b};this.$get=["$window",function(c){function d(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?"Error: "+a.message+"\n"+a.stack:a.stack:
a.sourceURL&&(a=a.message+"\n"+a.sourceURL+":"+a.line));return a}function e(a){var b=c.console||{},e=b[a]||b.log||A;a=!1;try{a=!!e.apply}catch(k){}return a?function(){var a=[];r(arguments,function(b){a.push(d(b))});return e.apply(b,a)}:function(a,b){e(a,null==b?"":b)}}return{log:e("log"),info:e("info"),warn:e("warn"),error:e("error"),debug:function(){var c=e("debug");return function(){b&&c.apply(a,arguments)}}()}}]}function pa(b,a){if("__defineGetter__"===b||"__defineSetter__"===b||"__lookupGetter__"===
b||"__lookupSetter__"===b||"__proto__"===b)throw qa("isecfld",a);return b}function ra(b,a){if(b){if(b.constructor===b)throw qa("isecfn",a);if(b.window===b)throw qa("isecwindow",a);if(b.children&&(b.nodeName||b.prop&&b.attr&&b.find))throw qa("isecdom",a);if(b===Object)throw qa("isecobj",a);}return b}function dc(b){return b.constant}function Pa(b,a,c,d){ra(b,d);a=a.split(".");for(var e,f=0;1<a.length;f++){e=pa(a.shift(),d);var g=ra(b[e],d);g||(g={},b[e]=g);b=g}e=pa(a.shift(),d);ra(b[e],d);return b[e]=
c}function Qa(b){return"constructor"==b}function ad(b,a,c,d,e,f,g){pa(b,f);pa(a,f);pa(c,f);pa(d,f);pa(e,f);var h=function(a){return ra(a,f)},k=g||Qa(b)?h:la,l=g||Qa(a)?h:la,m=g||Qa(c)?h:la,p=g||Qa(d)?h:la,q=g||Qa(e)?h:la;return function(f,g){var h=g&&g.hasOwnProperty(b)?g:f;if(null==h)return h;h=k(h[b]);if(!a)return h;if(null==h)return t;h=l(h[a]);if(!c)return h;if(null==h)return t;h=m(h[c]);if(!d)return h;if(null==h)return t;h=p(h[d]);return e?null==h?t:h=q(h[e]):h}}function wf(b,a){return function(c,
d){return b(c,d,ra,a)}}function bd(b,a,c){var d=a.expensiveChecks,e=d?xf:yf,f=e[b];if(f)return f;var g=b.split("."),h=g.length;if(a.csp)f=6>h?ad(g[0],g[1],g[2],g[3],g[4],c,d):function(a,b){var e=0,f;do f=ad(g[e++],g[e++],g[e++],g[e++],g[e++],c,d)(a,b),b=t,a=f;while(e<h);return f};else{var k="";d&&(k+="s = eso(s, fe);\nl = eso(l, fe);\n");var l=d;r(g,function(a,b){pa(a,c);var e=(b?"s":'((l&&l.hasOwnProperty("'+a+'"))?l:s)')+"."+a;if(d||Qa(a))e="eso("+e+", fe)",l=!0;k+="if(s == null) return undefined;\ns="+
e+";\n"});k+="return s;";a=new Function("s","l","eso","fe",k);a.toString=da(k);l&&(a=wf(a,c));f=a}f.sharedGetter=!0;f.assign=function(a,c){return Pa(a,b,c,b)};return e[b]=f}function ec(b){return u(b.valueOf)?b.valueOf():zf.call(b)}function Le(){var b=oa(),a=oa();this.$get=["$filter","$sniffer",function(c,d){function e(a){var b=a;a.sharedGetter&&(b=function(b,c){return a(b,c)},b.literal=a.literal,b.constant=a.constant,b.assign=a.assign);return b}function f(a,b){for(var c=0,d=a.length;c<d;c++){var e=
a[c];e.constant||(e.inputs?f(e.inputs,b):-1===b.indexOf(e)&&b.push(e))}return b}function g(a,b){return null==a||null==b?a===b:"object"===typeof a&&(a=ec(a),"object"===typeof a)?!1:a===b||a!==a&&b!==b}function h(a,b,c,d){var e=d.$$inputs||(d.$$inputs=f(d.inputs,[])),k;if(1===e.length){var h=g,e=e[0];return a.$watch(function(a){var b=e(a);g(b,h)||(k=d(a),h=b&&ec(b));return k},b,c)}for(var l=[],q=0,n=e.length;q<n;q++)l[q]=g;return a.$watch(function(a){for(var b=!1,c=0,f=e.length;c<f;c++){var h=e[c](a);
if(b||(b=!g(h,l[c])))l[c]=h&&ec(h)}b&&(k=d(a));return k},b,c)}function k(a,b,c,d){var e,f;return e=a.$watch(function(a){return d(a)},function(a,c,d){f=a;u(b)&&b.apply(this,arguments);y(a)&&d.$$postDigest(function(){y(f)&&e()})},c)}function l(a,b,c,d){function e(a){var b=!0;r(a,function(a){y(a)||(b=!1)});return b}var f,g;return f=a.$watch(function(a){return d(a)},function(a,c,d){g=a;u(b)&&b.call(this,a,c,d);e(a)&&d.$$postDigest(function(){e(g)&&f()})},c)}function m(a,b,c,d){var e;return e=a.$watch(function(a){return d(a)},
function(a,c,d){u(b)&&b.apply(this,arguments);e()},c)}function p(a,b){if(!b)return a;var c=function(c,d){var e=a(c,d),f=b(e,c,d);return y(e)||b.$stateful?f:e};a.$$watchDelegate&&a.$$watchDelegate!==h?c.$$watchDelegate=a.$$watchDelegate:b.$stateful||(c.$$watchDelegate=h,c.inputs=[a]);return c}var q={csp:d.csp,expensiveChecks:!1},n={csp:d.csp,expensiveChecks:!0};return function(d,f,g){var r,B,K;switch(typeof d){case "string":K=d=d.trim();var E=g?a:b;r=E[K];r||(":"===d.charAt(0)&&":"===d.charAt(1)&&
(B=!0,d=d.substring(2)),g=g?n:q,r=new fc(g),r=(new eb(r,c,g)).parse(d),r.constant?r.$$watchDelegate=m:B?(r=e(r),r.$$watchDelegate=r.literal?l:k):r.inputs&&(r.$$watchDelegate=h),E[K]=r);return p(r,f);case "function":return p(d,f);default:return p(A,f)}}}]}function Ne(){this.$get=["$rootScope","$exceptionHandler",function(b,a){return cd(function(a){b.$evalAsync(a)},a)}]}function Oe(){this.$get=["$browser","$exceptionHandler",function(b,a){return cd(function(a){b.defer(a)},a)}]}function cd(b,a){function c(a,
b,c){function d(b){return function(c){e||(e=!0,b.call(a,c))}}var e=!1;return[d(b),d(c)]}function d(){this.$$state={status:0}}function e(a,b){return function(c){b.call(a,c)}}function f(c){!c.processScheduled&&c.pending&&(c.processScheduled=!0,b(function(){var b,d,e;e=c.pending;c.processScheduled=!1;c.pending=t;for(var f=0,g=e.length;f<g;++f){d=e[f][0];b=e[f][c.status];try{u(b)?d.resolve(b(c.value)):1===c.status?d.resolve(c.value):d.reject(c.value)}catch(k){d.reject(k),a(k)}}}))}function g(){this.promise=
new d;this.resolve=e(this,this.resolve);this.reject=e(this,this.reject);this.notify=e(this,this.notify)}var h=v("$q",TypeError);d.prototype={then:function(a,b,c){var d=new g;this.$$state.pending=this.$$state.pending||[];this.$$state.pending.push([d,a,b,c]);0<this.$$state.status&&f(this.$$state);return d.promise},"catch":function(a){return this.then(null,a)},"finally":function(a,b){return this.then(function(b){return l(b,!0,a)},function(b){return l(b,!1,a)},b)}};g.prototype={resolve:function(a){this.promise.$$state.status||
(a===this.promise?this.$$reject(h("qcycle",a)):this.$$resolve(a))},$$resolve:function(b){var d,e;e=c(this,this.$$resolve,this.$$reject);try{if(M(b)||u(b))d=b&&b.then;u(d)?(this.promise.$$state.status=-1,d.call(b,e[0],e[1],this.notify)):(this.promise.$$state.value=b,this.promise.$$state.status=1,f(this.promise.$$state))}catch(g){e[1](g),a(g)}},reject:function(a){this.promise.$$state.status||this.$$reject(a)},$$reject:function(a){this.promise.$$state.value=a;this.promise.$$state.status=2;f(this.promise.$$state)},
notify:function(c){var d=this.promise.$$state.pending;0>=this.promise.$$state.status&&d&&d.length&&b(function(){for(var b,e,f=0,g=d.length;f<g;f++){e=d[f][0];b=d[f][3];try{e.notify(u(b)?b(c):c)}catch(k){a(k)}}})}};var k=function(a,b){var c=new g;b?c.resolve(a):c.reject(a);return c.promise},l=function(a,b,c){var d=null;try{u(c)&&(d=c())}catch(e){return k(e,!1)}return d&&u(d.then)?d.then(function(){return k(a,b)},function(a){return k(a,!1)}):k(a,b)},m=function(a,b,c,d){var e=new g;e.resolve(a);return e.promise.then(b,
c,d)},p=function n(a){if(!u(a))throw h("norslvr",a);if(!(this instanceof n))return new n(a);var b=new g;a(function(a){b.resolve(a)},function(a){b.reject(a)});return b.promise};p.defer=function(){return new g};p.reject=function(a){var b=new g;b.reject(a);return b.promise};p.when=m;p.all=function(a){var b=new g,c=0,d=H(a)?[]:{};r(a,function(a,e){c++;m(a).then(function(a){d.hasOwnProperty(e)||(d[e]=a,--c||b.resolve(d))},function(a){d.hasOwnProperty(e)||b.reject(a)})});0===c&&b.resolve(d);return b.promise};
return p}function Xe(){this.$get=["$window","$timeout",function(b,a){var c=b.requestAnimationFrame||b.webkitRequestAnimationFrame||b.mozRequestAnimationFrame,d=b.cancelAnimationFrame||b.webkitCancelAnimationFrame||b.mozCancelAnimationFrame||b.webkitCancelRequestAnimationFrame,e=!!c,f=e?function(a){var b=c(a);return function(){d(b)}}:function(b){var c=a(b,16.66,!1);return function(){a.cancel(c)}};f.supported=e;return f}]}function Me(){var b=10,a=v("$rootScope"),c=null,d=null;this.digestTtl=function(a){arguments.length&&
(b=a);return b};this.$get=["$injector","$exceptionHandler","$parse","$browser",function(e,f,g,h){function k(){this.$id=++ib;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this.$root=this;this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$isolateBindings=null}function l(b){if(s.$$phase)throw a("inprog",s.$$phase);s.$$phase=b}function m(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];
while(a=a.$parent)}function p(){}function q(){for(;x.length;)try{x.shift()()}catch(a){f(a)}d=null}function n(){null===d&&(d=h.defer(function(){s.$apply(q)}))}k.prototype={constructor:k,$new:function(a,b){function c(){d.$$destroyed=!0}var d;b=b||this;a?(d=new k,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=function(){this.$$watchers=this.$$nextSibling=this.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$id=++ib;this.$$ChildScope=null},this.$$ChildScope.prototype=
this),d=new this.$$ChildScope);d.$parent=b;d.$$prevSibling=b.$$childTail;b.$$childHead?(b.$$childTail.$$nextSibling=d,b.$$childTail=d):b.$$childHead=b.$$childTail=d;(a||b!=this)&&d.$on("$destroy",c);return d},$watch:function(a,b,d){var e=g(a);if(e.$$watchDelegate)return e.$$watchDelegate(this,b,d,e);var f=this.$$watchers,k={fn:b,last:p,get:e,exp:a,eq:!!d};c=null;u(b)||(k.fn=A);f||(f=this.$$watchers=[]);f.unshift(k);return function(){Wa(f,k);c=null}},$watchGroup:function(a,b){function c(){k=!1;h?(h=
!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,k=!1,h=!0;if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});r(a,function(a,b){var h=g.$watch(a,function(a,f){e[b]=a;d[b]=f;k||(k=!0,g.$evalAsync(c))});f.push(h)});return function(){for(;f.length;)f.shift()()}},$watchCollection:function(a,b){function c(a){e=a;var b,d,g,k;if(!w(e)){if(M(e))if(Sa(e))for(f!==
p&&(f=p,s=f.length=0,l++),a=e.length,s!==a&&(l++,f.length=s=a),b=0;b<a;b++)k=f[b],g=e[b],d=k!==k&&g!==g,d||k===g||(l++,f[b]=g);else{f!==q&&(f=q={},s=0,l++);a=0;for(b in e)e.hasOwnProperty(b)&&(a++,g=e[b],k=f[b],b in f?(d=k!==k&&g!==g,d||k===g||(l++,f[b]=g)):(s++,f[b]=g,l++));if(s>a)for(b in l++,f)e.hasOwnProperty(b)||(s--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$stateful=!0;var d=this,e,f,k,h=1<b.length,l=0,m=g(a,c),p=[],q={},n=!0,s=0;return this.$watch(m,function(){n?(n=!1,b(e,e,d)):b(e,k,
d);if(h)if(M(e))if(Sa(e)){k=Array(e.length);for(var a=0;a<e.length;a++)k[a]=e[a]}else for(a in k={},e)Ib.call(e,a)&&(k[a]=e[a]);else k=e})},$digest:function(){var e,g,k,m,n,r,x=b,N,t=[],X,Q,y;l("$digest");h.$$checkUrlChange();this===s&&null!==d&&(h.defer.cancel(d),q());c=null;do{r=!1;for(N=this;O.length;){try{y=O.shift(),y.scope.$eval(y.expression)}catch(v){f(v)}c=null}a:do{if(m=N.$$watchers)for(n=m.length;n--;)try{if(e=m[n])if((g=e.get(N))!==(k=e.last)&&!(e.eq?ma(g,k):"number"===typeof g&&"number"===
typeof k&&isNaN(g)&&isNaN(k)))r=!0,c=e,e.last=e.eq?Da(g,null):g,e.fn(g,k===p?g:k,N),5>x&&(X=4-x,t[X]||(t[X]=[]),Q=u(e.exp)?"fn: "+(e.exp.name||e.exp.toString()):e.exp,Q+="; newVal: "+ua(g)+"; oldVal: "+ua(k),t[X].push(Q));else if(e===c){r=!1;break a}}catch(z){f(z)}if(!(m=N.$$childHead||N!==this&&N.$$nextSibling))for(;N!==this&&!(m=N.$$nextSibling);)N=N.$parent}while(N=m);if((r||O.length)&&!x--)throw s.$$phase=null,a("infdig",b,ua(t));}while(r||O.length);for(s.$$phase=null;D.length;)try{D.shift()()}catch(A){f(A)}},
$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast("$destroy");this.$$destroyed=!0;if(this!==s){for(var b in this.$$listenerCount)m(this,this.$$listenerCount[b],b);a.$$childHead==this&&(a.$$childHead=this.$$nextSibling);a.$$childTail==this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=
this.$applyAsync=A;this.$on=this.$watch=this.$watchGroup=function(){return A};this.$$listeners={};this.$parent=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=this.$root=this.$$watchers=null}}},$eval:function(a,b){return g(a)(this,b)},$evalAsync:function(a){s.$$phase||O.length||h.defer(function(){O.length&&s.$digest()});O.push({scope:this,expression:a})},$$postDigest:function(a){D.push(a)},$apply:function(a){try{return l("$apply"),this.$eval(a)}catch(b){f(b)}finally{s.$$phase=
null;try{s.$digest()}catch(c){throw f(c),c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&x.push(b);n()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(c[d]=null,m(e,1,a))}},$emit:function(a,b){var c=[],d,e=this,g=!1,k={name:a,targetScope:e,stopPropagation:function(){g=!0},preventDefault:function(){k.defaultPrevented=
!0},defaultPrevented:!1},h=kb([k],arguments,1),l,m;do{d=e.$$listeners[a]||c;k.currentScope=e;l=0;for(m=d.length;l<m;l++)if(d[l])try{d[l].apply(null,h)}catch(p){f(p)}else d.splice(l,1),l--,m--;if(g)return k.currentScope=null,k;e=e.$parent}while(e);k.currentScope=null;return k},$broadcast:function(a,b){var c=this,d=this,e={name:a,targetScope:this,preventDefault:function(){e.defaultPrevented=!0},defaultPrevented:!1};if(!this.$$listenerCount[a])return e;for(var g=kb([e],arguments,1),k,h;c=d;){e.currentScope=
c;d=c.$$listeners[a]||[];k=0;for(h=d.length;k<h;k++)if(d[k])try{d[k].apply(null,g)}catch(l){f(l)}else d.splice(k,1),k--,h--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=c.$$nextSibling);)c=c.$parent}e.currentScope=null;return e}};var s=new k,O=s.$$asyncQueue=[],D=s.$$postDigestQueue=[],x=s.$$applyAsyncQueue=[];return s}]}function Pd(){var b=/^\s*(https?|ftp|mailto|tel|file):/,a=/^\s*((https?|ftp|file|blob):|data:image\/)/;this.aHrefSanitizationWhitelist=
function(a){return y(a)?(b=a,this):b};this.imgSrcSanitizationWhitelist=function(b){return y(b)?(a=b,this):a};this.$get=function(){return function(c,d){var e=d?a:b,f;f=Ba(c).href;return""===f||f.match(e)?c:"unsafe:"+f}}}function Af(b){if("self"===b)return b;if(G(b)){if(-1<b.indexOf("***"))throw Ca("iwcard",b);b=dd(b).replace("\\*\\*",".*").replace("\\*","[^:/.?&;]*");return new RegExp("^"+b+"$")}if(jb(b))return new RegExp("^"+b.source+"$");throw Ca("imatcher");}function ed(b){var a=[];y(b)&&r(b,function(b){a.push(Af(b))});
return a}function Qe(){this.SCE_CONTEXTS=ja;var b=["self"],a=[];this.resourceUrlWhitelist=function(a){arguments.length&&(b=ed(a));return b};this.resourceUrlBlacklist=function(b){arguments.length&&(a=ed(b));return a};this.$get=["$injector",function(c){function d(a,b){return"self"===a?Wc(b):!!a.exec(b.href)}function e(a){var b=function(a){this.$$unwrapTrustedValue=function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};
return b}var f=function(a){throw Ca("unsafe");};c.has("$sanitize")&&(f=c.get("$sanitize"));var g=e(),h={};h[ja.HTML]=e(g);h[ja.CSS]=e(g);h[ja.URL]=e(g);h[ja.JS]=e(g);h[ja.RESOURCE_URL]=e(h[ja.URL]);return{trustAs:function(a,b){var c=h.hasOwnProperty(a)?h[a]:null;if(!c)throw Ca("icontext",a,b);if(null===b||b===t||""===b)return b;if("string"!==typeof b)throw Ca("itype",a);return new c(b)},getTrusted:function(c,e){if(null===e||e===t||""===e)return e;var g=h.hasOwnProperty(c)?h[c]:null;if(g&&e instanceof
g)return e.$$unwrapTrustedValue();if(c===ja.RESOURCE_URL){var g=Ba(e.toString()),p,q,n=!1;p=0;for(q=b.length;p<q;p++)if(d(b[p],g)){n=!0;break}if(n)for(p=0,q=a.length;p<q;p++)if(d(a[p],g)){n=!1;break}if(n)return e;throw Ca("insecurl",e.toString());}if(c===ja.HTML)return f(e);throw Ca("unsafe");},valueOf:function(a){return a instanceof g?a.$$unwrapTrustedValue():a}}}]}function Pe(){var b=!0;this.enabled=function(a){arguments.length&&(b=!!a);return b};this.$get=["$parse","$sceDelegate",function(a,c){if(b&&
8>Ia)throw Ca("iequirks");var d=ta(ja);d.isEnabled=function(){return b};d.trustAs=c.trustAs;d.getTrusted=c.getTrusted;d.valueOf=c.valueOf;b||(d.trustAs=d.getTrusted=function(a,b){return b},d.valueOf=la);d.parseAs=function(b,c){var e=a(c);return e.literal&&e.constant?e:a(c,function(a){return d.getTrusted(b,a)})};var e=d.parseAs,f=d.getTrusted,g=d.trustAs;r(ja,function(a,b){var c=R(b);d[ab("parse_as_"+c)]=function(b){return e(a,b)};d[ab("get_trusted_"+c)]=function(b){return f(a,b)};d[ab("trust_as_"+
c)]=function(b){return g(a,b)}});return d}]}function Re(){this.$get=["$window","$document",function(b,a){var c={},d=aa((/android (\d+)/.exec(R((b.navigator||{}).userAgent))||[])[1]),e=/Boxee/i.test((b.navigator||{}).userAgent),f=a[0]||{},g,h=/^(Moz|webkit|ms)(?=[A-Z])/,k=f.body&&f.body.style,l=!1,m=!1;if(k){for(var p in k)if(l=h.exec(p)){g=l[0];g=g.substr(0,1).toUpperCase()+g.substr(1);break}g||(g="WebkitOpacity"in k&&"webkit");l=!!("transition"in k||g+"Transition"in k);m=!!("animation"in k||g+"Animation"in
k);!d||l&&m||(l=G(f.body.style.webkitTransition),m=G(f.body.style.webkitAnimation))}return{history:!(!b.history||!b.history.pushState||4>d||e),hasEvent:function(a){if("input"==a&&9==Ia)return!1;if(w(c[a])){var b=f.createElement("div");c[a]="on"+a in b}return c[a]},csp:Za(),vendorPrefix:g,transitions:l,animations:m,android:d}}]}function Te(){this.$get=["$templateCache","$http","$q",function(b,a,c){function d(e,f){d.totalPendingRequests++;var g=a.defaults&&a.defaults.transformResponse;if(H(g))for(var h=
g,g=[],k=0;k<h.length;++k){var l=h[k];l!==Xb&&g.push(l)}else g===Xb&&(g=null);return a.get(e,{cache:b,transformResponse:g}).then(function(a){a=a.data;d.totalPendingRequests--;b.put(e,a);return a},function(){d.totalPendingRequests--;if(!f)throw ia("tpload",e);return c.reject()})}d.totalPendingRequests=0;return d}]}function Ue(){this.$get=["$rootScope","$browser","$location",function(b,a,c){return{findBindings:function(a,b,c){a=a.getElementsByClassName("ng-binding");var g=[];r(a,function(a){var d=wa.element(a).data("$binding");
d&&r(d,function(d){c?(new RegExp("(^|\\s)"+dd(b)+"(\\s|\\||$)")).test(d)&&g.push(a):-1!=d.indexOf(b)&&g.push(a)})});return g},findModels:function(a,b,c){for(var g=["ng-","data-ng-","ng\\:"],h=0;h<g.length;++h){var k=a.querySelectorAll("["+g[h]+"model"+(c?"=":"*=")+'"'+b+'"]');if(k.length)return k}},getLocation:function(){return c.url()},setLocation:function(a){a!==c.url()&&(c.url(a),b.$digest())},whenStable:function(b){a.notifyWhenNoOutstandingRequests(b)}}}]}function Ve(){this.$get=["$rootScope",
"$browser","$q","$$q","$exceptionHandler",function(b,a,c,d,e){function f(f,k,l){var m=y(l)&&!l,p=(m?d:c).defer(),q=p.promise;k=a.defer(function(){try{p.resolve(f())}catch(a){p.reject(a),e(a)}finally{delete g[q.$$timeoutId]}m||b.$apply()},k);q.$$timeoutId=k;g[k]=p;return q}var g={};f.cancel=function(b){return b&&b.$$timeoutId in g?(g[b.$$timeoutId].reject("canceled"),delete g[b.$$timeoutId],a.defer.cancel(b.$$timeoutId)):!1};return f}]}function Ba(b,a){var c=b;Ia&&(Z.setAttribute("href",c),c=Z.href);
Z.setAttribute("href",c);return{href:Z.href,protocol:Z.protocol?Z.protocol.replace(/:$/,""):"",host:Z.host,search:Z.search?Z.search.replace(/^\?/,""):"",hash:Z.hash?Z.hash.replace(/^#/,""):"",hostname:Z.hostname,port:Z.port,pathname:"/"===Z.pathname.charAt(0)?Z.pathname:"/"+Z.pathname}}function Wc(b){b=G(b)?Ba(b):b;return b.protocol===fd.protocol&&b.host===fd.host}function We(){this.$get=da(T)}function Cc(b){function a(c,d){if(M(c)){var e={};r(c,function(b,c){e[c]=a(c,b)});return e}return b.factory(c+
"Filter",d)}this.register=a;this.$get=["$injector",function(a){return function(b){return a.get(b+"Filter")}}];a("currency",gd);a("date",hd);a("filter",Bf);a("json",Cf);a("limitTo",Df);a("lowercase",Ef);a("number",id);a("orderBy",jd);a("uppercase",Ff)}function Bf(){return function(b,a,c){if(!H(b))return b;var d=typeof c,e=[];e.check=function(a,b){for(var c=0;c<e.length;c++)if(!e[c](a,b))return!1;return!0};"function"!==d&&(c="boolean"===d&&c?function(a,b){return wa.equals(a,b)}:function(a,b){if(a&&
b&&"object"===typeof a&&"object"===typeof b){for(var d in a)if("$"!==d.charAt(0)&&Ib.call(a,d)&&c(a[d],b[d]))return!0;return!1}b=(""+b).toLowerCase();return-1<(""+a).toLowerCase().indexOf(b)});var f=function(a,b){if("string"===typeof b&&"!"===b.charAt(0))return!f(a,b.substr(1));switch(typeof a){case "boolean":case "number":case "string":return c(a,b);case "object":switch(typeof b){case "object":return c(a,b);default:for(var d in a)if("$"!==d.charAt(0)&&f(a[d],b))return!0}return!1;case "array":for(d=
0;d<a.length;d++)if(f(a[d],b))return!0;return!1;default:return!1}};switch(typeof a){case "boolean":case "number":case "string":a={$:a};case "object":for(var g in a)(function(b){"undefined"!==typeof a[b]&&e.push(function(c){return f("$"==b?c:c&&c[b],a[b])})})(g);break;case "function":e.push(a);break;default:return b}d=[];for(g=0;g<b.length;g++){var h=b[g];e.check(h,g)&&d.push(h)}return d}}function gd(b){var a=b.NUMBER_FORMATS;return function(b,d,e){w(d)&&(d=a.CURRENCY_SYM);w(e)&&(e=2);return null==
b?b:kd(b,a.PATTERNS[1],a.GROUP_SEP,a.DECIMAL_SEP,e).replace(/\u00A4/g,d)}}function id(b){var a=b.NUMBER_FORMATS;return function(b,d){return null==b?b:kd(b,a.PATTERNS[0],a.GROUP_SEP,a.DECIMAL_SEP,d)}}function kd(b,a,c,d,e){if(!isFinite(b)||M(b))return"";var f=0>b;b=Math.abs(b);var g=b+"",h="",k=[],l=!1;if(-1!==g.indexOf("e")){var m=g.match(/([\d\.]+)e(-?)(\d+)/);m&&"-"==m[2]&&m[3]>e+1?(g="0",b=0):(h=g,l=!0)}if(l)0<e&&-1<b&&1>b&&(h=b.toFixed(e));else{g=(g.split(ld)[1]||"").length;w(e)&&(e=Math.min(Math.max(a.minFrac,
g),a.maxFrac));b=+(Math.round(+(b.toString()+"e"+e)).toString()+"e"+-e);0===b&&(f=!1);b=(""+b).split(ld);g=b[0];b=b[1]||"";var m=0,p=a.lgSize,q=a.gSize;if(g.length>=p+q)for(m=g.length-p,l=0;l<m;l++)0===(m-l)%q&&0!==l&&(h+=c),h+=g.charAt(l);for(l=m;l<g.length;l++)0===(g.length-l)%p&&0!==l&&(h+=c),h+=g.charAt(l);for(;b.length<e;)b+="0";e&&"0"!==e&&(h+=d+b.substr(0,e))}k.push(f?a.negPre:a.posPre);k.push(h);k.push(f?a.negSuf:a.posSuf);return k.join("")}function Bb(b,a,c){var d="";0>b&&(d="-",b=-b);for(b=
""+b;b.length<a;)b="0"+b;c&&(b=b.substr(b.length-a));return d+b}function $(b,a,c,d){c=c||0;return function(e){e=e["get"+b]();if(0<c||e>-c)e+=c;0===e&&-12==c&&(e=12);return Bb(e,a,d)}}function Cb(b,a){return function(c,d){var e=c["get"+b](),f=qb(a?"SHORT"+b:b);return d[f][e]}}function md(b){var a=(new Date(b,0,1)).getDay();return new Date(b,0,(4>=a?5:12)-a)}function nd(b){return function(a){var c=md(a.getFullYear());a=+new Date(a.getFullYear(),a.getMonth(),a.getDate()+(4-a.getDay()))-+c;a=1+Math.round(a/
6048E5);return Bb(a,b)}}function hd(b){function a(a){var b;if(b=a.match(c)){a=new Date(0);var f=0,g=0,h=b[8]?a.setUTCFullYear:a.setFullYear,k=b[8]?a.setUTCHours:a.setHours;b[9]&&(f=aa(b[9]+b[10]),g=aa(b[9]+b[11]));h.call(a,aa(b[1]),aa(b[2])-1,aa(b[3]));f=aa(b[4]||0)-f;g=aa(b[5]||0)-g;h=aa(b[6]||0);b=Math.round(1E3*parseFloat("0."+(b[7]||0)));k.call(a,f,g,h,b)}return a}var c=/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;return function(c,e,f){var g=
"",h=[],k,l;e=e||"mediumDate";e=b.DATETIME_FORMATS[e]||e;G(c)&&(c=Gf.test(c)?aa(c):a(c));V(c)&&(c=new Date(c));if(!ea(c))return c;for(;e;)(l=Hf.exec(e))?(h=kb(h,l,1),e=h.pop()):(h.push(e),e=null);f&&"UTC"===f&&(c=new Date(c.getTime()),c.setMinutes(c.getMinutes()+c.getTimezoneOffset()));r(h,function(a){k=If[a];g+=k?k(c,b.DATETIME_FORMATS):a.replace(/(^'|'$)/g,"").replace(/''/g,"'")});return g}}function Cf(){return function(b){return ua(b,!0)}}function Df(){return function(b,a){V(b)&&(b=b.toString());
if(!H(b)&&!G(b))return b;a=Infinity===Math.abs(Number(a))?Number(a):aa(a);if(G(b))return a?0<=a?b.slice(0,a):b.slice(a,b.length):"";var c=[],d,e;a>b.length?a=b.length:a<-b.length&&(a=-b.length);0<a?(d=0,e=a):(d=b.length+a,e=b.length);for(;d<e;d++)c.push(b[d]);return c}}function jd(b){return function(a,c,d){function e(a,b){return b?function(b,c){return a(c,b)}:a}function f(a,b){var c=typeof a,d=typeof b;return c==d?(ea(a)&&ea(b)&&(a=a.valueOf(),b=b.valueOf()),"string"==c&&(a=a.toLowerCase(),b=b.toLowerCase()),
a===b?0:a<b?-1:1):c<d?-1:1}if(!Sa(a))return a;c=H(c)?c:[c];0===c.length&&(c=["+"]);c=c.map(function(a){var c=!1,d=a||la;if(G(a)){if("+"==a.charAt(0)||"-"==a.charAt(0))c="-"==a.charAt(0),a=a.substring(1);if(""===a)return e(function(a,b){return f(a,b)},c);d=b(a);if(d.constant){var g=d();return e(function(a,b){return f(a[g],b[g])},c)}}return e(function(a,b){return f(d(a),d(b))},c)});for(var g=[],h=0;h<a.length;h++)g.push(a[h]);return g.sort(e(function(a,b){for(var d=0;d<c.length;d++){var e=c[d](a,b);
if(0!==e)return e}return 0},d))}}function Ja(b){u(b)&&(b={link:b});b.restrict=b.restrict||"AC";return da(b)}function od(b,a,c,d,e){var f=this,g=[],h=f.$$parentForm=b.parent().controller("form")||Db;f.$error={};f.$$success={};f.$pending=t;f.$name=e(a.name||a.ngForm||"")(c);f.$dirty=!1;f.$pristine=!0;f.$valid=!0;f.$invalid=!1;f.$submitted=!1;h.$addControl(f);f.$rollbackViewValue=function(){r(g,function(a){a.$rollbackViewValue()})};f.$commitViewValue=function(){r(g,function(a){a.$commitViewValue()})};
f.$addControl=function(a){Ma(a.$name,"input");g.push(a);a.$name&&(f[a.$name]=a)};f.$$renameControl=function(a,b){var c=a.$name;f[c]===a&&delete f[c];f[b]=a;a.$name=b};f.$removeControl=function(a){a.$name&&f[a.$name]===a&&delete f[a.$name];r(f.$pending,function(b,c){f.$setValidity(c,null,a)});r(f.$error,function(b,c){f.$setValidity(c,null,a)});Wa(g,a)};pd({ctrl:this,$element:b,set:function(a,b,c){var d=a[b];d?-1===d.indexOf(c)&&d.push(c):a[b]=[c]},unset:function(a,b,c){var d=a[b];d&&(Wa(d,c),0===d.length&&
delete a[b])},parentForm:h,$animate:d});f.$setDirty=function(){d.removeClass(b,Ra);d.addClass(b,Eb);f.$dirty=!0;f.$pristine=!1;h.$setDirty()};f.$setPristine=function(){d.setClass(b,Ra,Eb+" ng-submitted");f.$dirty=!1;f.$pristine=!0;f.$submitted=!1;r(g,function(a){a.$setPristine()})};f.$setUntouched=function(){r(g,function(a){a.$setUntouched()})};f.$setSubmitted=function(){d.addClass(b,"ng-submitted");f.$submitted=!0;h.$setSubmitted()}}function gc(b){b.$formatters.push(function(a){return b.$isEmpty(a)?
a:a.toString()})}function fb(b,a,c,d,e,f){var g=a[0].placeholder,h={},k=R(a[0].type);if(!e.android){var l=!1;a.on("compositionstart",function(a){l=!0});a.on("compositionend",function(){l=!1;m()})}var m=function(b){if(!l){var e=a.val(),f=b&&b.type;Ia&&"input"===(b||h).type&&a[0].placeholder!==g?g=a[0].placeholder:("password"===k||c.ngTrim&&"false"===c.ngTrim||(e=P(e)),(d.$viewValue!==e||""===e&&d.$$hasNativeValidators)&&d.$setViewValue(e,f))}};if(e.hasEvent("input"))a.on("input",m);else{var p,q=function(a){p||
(p=f.defer(function(){m(a);p=null}))};a.on("keydown",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||q(a)});if(e.hasEvent("paste"))a.on("paste cut",q)}a.on("change",m);d.$render=function(){a.val(d.$isEmpty(d.$modelValue)?"":d.$viewValue)}}function Fb(b,a){return function(c,d){var e,f;if(ea(c))return c;if(G(c)){'"'==c.charAt(0)&&'"'==c.charAt(c.length-1)&&(c=c.substring(1,c.length-1));if(Jf.test(c))return new Date(c);b.lastIndex=0;if(e=b.exec(c))return e.shift(),f=d?{yyyy:d.getFullYear(),
MM:d.getMonth()+1,dd:d.getDate(),HH:d.getHours(),mm:d.getMinutes(),ss:d.getSeconds(),sss:d.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},r(e,function(b,c){c<a.length&&(f[a[c]]=+b)}),new Date(f.yyyy,f.MM-1,f.dd,f.HH,f.mm,f.ss||0,1E3*f.sss||0)}return NaN}}function gb(b,a,c,d){return function(e,f,g,h,k,l,m){function p(a){return y(a)?ea(a)?a:c(a):t}qd(e,f,g,h);fb(e,f,g,h,k,l);var q=h&&h.$options&&h.$options.timezone,n;h.$$parserName=b;h.$parsers.push(function(b){return h.$isEmpty(b)?
null:a.test(b)?(b=c(b,n),"UTC"===q&&b.setMinutes(b.getMinutes()-b.getTimezoneOffset()),b):t});h.$formatters.push(function(a){if(h.$isEmpty(a))n=null;else{if(!ea(a))throw Gb("datefmt",a);if((n=a)&&"UTC"===q){var b=6E4*n.getTimezoneOffset();n=new Date(n.getTime()+b)}return m("date")(a,d,q)}return""});if(y(g.min)||g.ngMin){var s;h.$validators.min=function(a){return h.$isEmpty(a)||w(s)||c(a)>=s};g.$observe("min",function(a){s=p(a);h.$validate()})}if(y(g.max)||g.ngMax){var r;h.$validators.max=function(a){return h.$isEmpty(a)||
w(r)||c(a)<=r};g.$observe("max",function(a){r=p(a);h.$validate()})}h.$isEmpty=function(a){return!a||a.getTime&&a.getTime()!==a.getTime()}}}function qd(b,a,c,d){(d.$$hasNativeValidators=M(a[0].validity))&&d.$parsers.push(function(b){var c=a.prop("validity")||{};return c.badInput&&!c.typeMismatch?t:b})}function rd(b,a,c,d,e){if(y(d)){b=b(d);if(!b.constant)throw v("ngModel")("constexpr",c,d);return b(a)}return e}function pd(b){function a(a,b){b&&!f[a]?(l.addClass(e,a),f[a]=!0):!b&&f[a]&&(l.removeClass(e,
a),f[a]=!1)}function c(b,c){b=b?"-"+Lb(b,"-"):"";a(hb+b,!0===c);a(sd+b,!1===c)}var d=b.ctrl,e=b.$element,f={},g=b.set,h=b.unset,k=b.parentForm,l=b.$animate;f[sd]=!(f[hb]=e.hasClass(hb));d.$setValidity=function(b,e,f){e===t?(d.$pending||(d.$pending={}),g(d.$pending,b,f)):(d.$pending&&h(d.$pending,b,f),td(d.$pending)&&(d.$pending=t));Va(e)?e?(h(d.$error,b,f),g(d.$$success,b,f)):(g(d.$error,b,f),h(d.$$success,b,f)):(h(d.$error,b,f),h(d.$$success,b,f));d.$pending?(a(ud,!0),d.$valid=d.$invalid=t,c("",
null)):(a(ud,!1),d.$valid=td(d.$error),d.$invalid=!d.$valid,c("",d.$valid));e=d.$pending&&d.$pending[b]?t:d.$error[b]?!1:d.$$success[b]?!0:null;c(b,e);k.$setValidity(b,e,d)}}function td(b){if(b)for(var a in b)return!1;return!0}function hc(b,a){b="ngClass"+b;return["$animate",function(c){function d(a,b){var c=[],d=0;a:for(;d<a.length;d++){for(var e=a[d],m=0;m<b.length;m++)if(e==b[m])continue a;c.push(e)}return c}function e(a){if(!H(a)){if(G(a))return a.split(" ");if(M(a)){var b=[];r(a,function(a,c){a&&
(b=b.concat(c.split(" ")))});return b}}return a}return{restrict:"AC",link:function(f,g,h){function k(a,b){var c=g.data("$classCounts")||{},d=[];r(a,function(a){if(0<b||c[a])c[a]=(c[a]||0)+b,c[a]===+(0<b)&&d.push(a)});g.data("$classCounts",c);return d.join(" ")}function l(b){if(!0===a||f.$index%2===a){var l=e(b||[]);if(!m){var n=k(l,1);h.$addClass(n)}else if(!ma(b,m)){var s=e(m),n=d(l,s),l=d(s,l),n=k(n,1),l=k(l,-1);n&&n.length&&c.addClass(g,n);l&&l.length&&c.removeClass(g,l)}}m=ta(b)}var m;f.$watch(h[b],
l,!0);h.$observe("class",function(a){l(f.$eval(h[b]))});"ngClass"!==b&&f.$watch("$index",function(c,d){var g=c&1;if(g!==(d&1)){var l=e(f.$eval(h[b]));g===a?(g=k(l,1),h.$addClass(g)):(g=k(l,-1),h.$removeClass(g))}})}}}]}var Kf=/^\/(.+)\/([a-z]*)$/,R=function(b){return G(b)?b.toLowerCase():b},Ib=Object.prototype.hasOwnProperty,qb=function(b){return G(b)?b.toUpperCase():b},Ia,z,na,Ya=[].slice,pf=[].splice,Lf=[].push,Ka=Object.prototype.toString,Xa=v("ng"),wa=T.angular||(T.angular={}),$a,ib=0;Ia=U.documentMode;
A.$inject=[];la.$inject=[];var H=Array.isArray,P=function(b){return G(b)?b.trim():b},dd=function(b){return b.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")},Za=function(){if(y(Za.isActive_))return Za.isActive_;var b=!(!U.querySelector("[ng-csp]")&&!U.querySelector("[data-ng-csp]"));if(!b)try{new Function("")}catch(a){b=!0}return Za.isActive_=b},nb=["ng-","data-ng-","ng:","x-ng-"],Jd=/[A-Z]/g,tc=!1,Mb,ka=1,lb=3,Nd={full:"1.3.2",major:1,minor:3,dot:2,codeName:"cardiovasculatory-magnification"};
S.expando="ng339";var vb=S.cache={},df=1;S._data=function(b){return this.cache[b[this.expando]]||{}};var Ze=/([\:\-\_]+(.))/g,$e=/^moz([A-Z])/,Mf={mouseleave:"mouseout",mouseenter:"mouseover"},Pb=v("jqLite"),cf=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,Ob=/<|&#?\w+;/,af=/<([\w:]+)/,bf=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ha={option:[1,'<select multiple="multiple">',"</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>",
"</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ha.optgroup=ha.option;ha.tbody=ha.tfoot=ha.colgroup=ha.caption=ha.thead;ha.th=ha.td;var La=S.prototype={ready:function(b){function a(){c||(c=!0,b())}var c=!1;"complete"===U.readyState?setTimeout(a):(this.on("DOMContentLoaded",a),S(T).on("load",a))},toString:function(){var b=[];r(this,function(a){b.push(""+a)});return"["+b.join(", ")+"]"},eq:function(b){return 0<=b?z(this[b]):z(this[this.length+b])},length:0,
push:Lf,sort:[].sort,splice:[].splice},xb={};r("multiple selected checked disabled readOnly required open".split(" "),function(b){xb[R(b)]=b});var Lc={};r("input select option textarea button form details".split(" "),function(b){Lc[b]=!0});var Mc={ngMinlength:"minlength",ngMaxlength:"maxlength",ngMin:"min",ngMax:"max",ngPattern:"pattern"};r({data:Rb,removeData:tb},function(b,a){S[a]=b});r({data:Rb,inheritedData:wb,scope:function(b){return z.data(b,"$scope")||wb(b.parentNode||b,["$isolateScope","$scope"])},
isolateScope:function(b){return z.data(b,"$isolateScope")||z.data(b,"$isolateScopeNoTemplate")},controller:Hc,injector:function(b){return wb(b,"$injector")},removeAttr:function(b,a){b.removeAttribute(a)},hasClass:Sb,css:function(b,a,c){a=ab(a);if(y(c))b.style[a]=c;else return b.style[a]},attr:function(b,a,c){var d=R(a);if(xb[d])if(y(c))c?(b[a]=!0,b.setAttribute(a,d)):(b[a]=!1,b.removeAttribute(d));else return b[a]||(b.attributes.getNamedItem(a)||A).specified?d:t;else if(y(c))b.setAttribute(a,c);else if(b.getAttribute)return b=
b.getAttribute(a,2),null===b?t:b},prop:function(b,a,c){if(y(c))b[a]=c;else return b[a]},text:function(){function b(a,b){if(w(b)){var d=a.nodeType;return d===ka||d===lb?a.textContent:""}a.textContent=b}b.$dv="";return b}(),val:function(b,a){if(w(a)){if(b.multiple&&"select"===sa(b)){var c=[];r(b.options,function(a){a.selected&&c.push(a.value||a.text)});return 0===c.length?null:c}return b.value}b.value=a},html:function(b,a){if(w(a))return b.innerHTML;sb(b,!0);b.innerHTML=a},empty:Ic},function(b,a){S.prototype[a]=
function(a,d){var e,f,g=this.length;if(b!==Ic&&(2==b.length&&b!==Sb&&b!==Hc?a:d)===t){if(M(a)){for(e=0;e<g;e++)if(b===Rb)b(this[e],a);else for(f in a)b(this[e],f,a[f]);return this}e=b.$dv;g=e===t?Math.min(g,1):g;for(f=0;f<g;f++){var h=b(this[f],a,d);e=e?e+h:h}return e}for(e=0;e<g;e++)b(this[e],a,d);return this}});r({removeData:tb,on:function a(c,d,e,f){if(y(f))throw Pb("onargs");if(Dc(c)){var g=ub(c,!0);f=g.events;var h=g.handle;h||(h=g.handle=gf(c,f));for(var g=0<=d.indexOf(" ")?d.split(" "):[d],
k=g.length;k--;){d=g[k];var l=f[d];l||(f[d]=[],"mouseenter"===d||"mouseleave"===d?a(c,Mf[d],function(a){var c=a.relatedTarget;c&&(c===this||this.contains(c))||h(a,d)}):"$destroy"!==d&&c.addEventListener(d,h,!1),l=f[d]);l.push(e)}}},off:Gc,one:function(a,c,d){a=z(a);a.on(c,function f(){a.off(c,d);a.off(c,f)});a.on(c,d)},replaceWith:function(a,c){var d,e=a.parentNode;sb(a);r(new S(c),function(c){d?e.insertBefore(c,d.nextSibling):e.replaceChild(c,a);d=c})},children:function(a){var c=[];r(a.childNodes,
function(a){a.nodeType===ka&&c.push(a)});return c},contents:function(a){return a.contentDocument||a.childNodes||[]},append:function(a,c){var d=a.nodeType;if(d===ka||11===d){c=new S(c);for(var d=0,e=c.length;d<e;d++)a.appendChild(c[d])}},prepend:function(a,c){if(a.nodeType===ka){var d=a.firstChild;r(new S(c),function(c){a.insertBefore(c,d)})}},wrap:function(a,c){c=z(c).eq(0).clone()[0];var d=a.parentNode;d&&d.replaceChild(c,a);c.appendChild(a)},remove:Jc,detach:function(a){Jc(a,!0)},after:function(a,
c){var d=a,e=a.parentNode;c=new S(c);for(var f=0,g=c.length;f<g;f++){var h=c[f];e.insertBefore(h,d.nextSibling);d=h}},addClass:Ub,removeClass:Tb,toggleClass:function(a,c,d){c&&r(c.split(" "),function(c){var f=d;w(f)&&(f=!Sb(a,c));(f?Ub:Tb)(a,c)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,c){return a.getElementsByTagName?a.getElementsByTagName(c):[]},clone:Qb,triggerHandler:function(a,c,d){var e,f,g=c.type||c,h=
ub(a);if(h=(h=h&&h.events)&&h[g])e={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===this.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:A,type:g,target:a},c.type&&(e=F(e,c)),c=ta(h),f=d?[e].concat(d):[e],r(c,function(c){e.isImmediatePropagationStopped()||c.apply(a,f)})}},function(a,c){S.prototype[c]=function(c,
e,f){for(var g,h=0,k=this.length;h<k;h++)w(g)?(g=a(this[h],c,e,f),y(g)&&(g=z(g))):Fc(g,a(this[h],c,e,f));return y(g)?g:this};S.prototype.bind=S.prototype.on;S.prototype.unbind=S.prototype.off});bb.prototype={put:function(a,c){this[Na(a,this.nextUid)]=c},get:function(a){return this[Na(a,this.nextUid)]},remove:function(a){var c=this[a=Na(a,this.nextUid)];delete this[a];return c}};var Oc=/^function\s*[^\(]*\(\s*([^\)]*)\)/m,jf=/,/,kf=/^\s*(_?)(\S+?)\1\s*$/,Nc=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,Fa=v("$injector");
Kb.$$annotate=Vb;var Nf=v("$animate"),ze=["$provide",function(a){this.$$selectors={};this.register=function(c,d){var e=c+"-animation";if(c&&"."!=c.charAt(0))throw Nf("notcsel",c);this.$$selectors[c.substr(1)]=e;a.factory(e,d)};this.classNameFilter=function(a){1===arguments.length&&(this.$$classNameFilter=a instanceof RegExp?a:null);return this.$$classNameFilter};this.$get=["$$q","$$asyncCallback","$rootScope",function(a,d,e){function f(d){var f,g=a.defer();g.promise.$$cancelFn=function(){f&&f()};
e.$$postDigest(function(){f=d(function(){g.resolve()})});return g.promise}function g(a,c){var d=[],e=[],f=oa();r((a.attr("class")||"").split(/\s+/),function(a){f[a]=!0});r(c,function(a,c){var g=f[c];!1===a&&g?e.push(c):!0!==a||g||d.push(c)});return 0<d.length+e.length&&[d.length?d:null,e.length?e:null]}function h(a,c,d){for(var e=0,f=c.length;e<f;++e)a[c[e]]=d}function k(){m||(m=a.defer(),d(function(){m.resolve();m=null}));return m.promise}function l(a,c){if(wa.isObject(c)){var d=F(c.from||{},c.to||
{});a.css(d)}}var m;return{animate:function(a,c,d){l(a,{from:c,to:d});return k()},enter:function(a,c,d,e){l(a,e);d?d.after(a):c.prepend(a);return k()},leave:function(a,c){a.remove();return k()},move:function(a,c,d,e){return this.enter(a,c,d,e)},addClass:function(a,c,d){return this.setClass(a,c,[],d)},$$addClassImmediately:function(a,c,d){a=z(a);c=G(c)?c:H(c)?c.join(" "):"";r(a,function(a){Ub(a,c)});l(a,d);return k()},removeClass:function(a,c,d){return this.setClass(a,[],c,d)},$$removeClassImmediately:function(a,
c,d){a=z(a);c=G(c)?c:H(c)?c.join(" "):"";r(a,function(a){Tb(a,c)});l(a,d);return k()},setClass:function(a,c,d,e){var k=this,l=!1;a=z(a);var m=a.data("$$animateClasses");m?e&&m.options&&(m.options=wa.extend(m.options||{},e)):(m={classes:{},options:e},l=!0);e=m.classes;c=H(c)?c:c.split(" ");d=H(d)?d:d.split(" ");h(e,c,!0);h(e,d,!1);l&&(m.promise=f(function(c){var d=a.data("$$animateClasses");a.removeData("$$animateClasses");if(d){var e=g(a,d.classes);e&&k.$$setClassImmediately(a,e[0],e[1],d.options)}c()}),
a.data("$$animateClasses",m));return m.promise},$$setClassImmediately:function(a,c,d,e){c&&this.$$addClassImmediately(a,c);d&&this.$$removeClassImmediately(a,d);l(a,e);return k()},enabled:A,cancel:A}}]}],ia=v("$compile");vc.$inject=["$provide","$$sanitizeUriProvider"];var of=/^((?:x|data)[\:\-_])/i,Sc="application/json",Yb={"Content-Type":Sc+";charset=utf-8"},rf=/^\s*(\[|\{[^\{])/,sf=/[\}\]]\s*$/,qf=/^\)\]\}',?\n/,Zb=v("$interpolate"),Of=/^([^\?#]*)(\?([^#]*))?(#(.*))?$/,vf={http:80,https:443,ftp:21},
db=v("$location"),Pf={$$html5:!1,$$replace:!1,absUrl:Ab("$$absUrl"),url:function(a){if(w(a))return this.$$url;a=Of.exec(a);a[1]&&this.path(decodeURIComponent(a[1]));(a[2]||a[1])&&this.search(a[3]||"");this.hash(a[5]||"");return this},protocol:Ab("$$protocol"),host:Ab("$$host"),port:Ab("$$port"),path:$c("$$path",function(a){a=null!==a?a.toString():"";return"/"==a.charAt(0)?a:"/"+a}),search:function(a,c){switch(arguments.length){case 0:return this.$$search;case 1:if(G(a)||V(a))a=a.toString(),this.$$search=
rc(a);else if(M(a))a=Da(a,{}),r(a,function(c,e){null==c&&delete a[e]}),this.$$search=a;else throw db("isrcharg");break;default:w(c)||null===c?delete this.$$search[a]:this.$$search[a]=c}this.$$compose();return this},hash:$c("$$hash",function(a){return null!==a?a.toString():""}),replace:function(){this.$$replace=!0;return this}};r([Zc,cc,bc],function(a){a.prototype=Object.create(Pf);a.prototype.state=function(c){if(!arguments.length)return this.$$state;if(a!==bc||!this.$$html5)throw db("nostate");this.$$state=
w(c)?null:c;return this}});var qa=v("$parse"),Qf=Function.prototype.call,Rf=Function.prototype.apply,Sf=Function.prototype.bind,Hb=oa();r({"null":function(){return null},"true":function(){return!0},"false":function(){return!1},undefined:function(){}},function(a,c){a.constant=a.literal=a.sharedGetter=!0;Hb[c]=a});Hb["this"]=function(a){return a};Hb["this"].sharedGetter=!0;var ic=F(oa(),{"+":function(a,c,d,e){d=d(a,c);e=e(a,c);return y(d)?y(e)?d+e:d:y(e)?e:t},"-":function(a,c,d,e){d=d(a,c);e=e(a,c);
return(y(d)?d:0)-(y(e)?e:0)},"*":function(a,c,d,e){return d(a,c)*e(a,c)},"/":function(a,c,d,e){return d(a,c)/e(a,c)},"%":function(a,c,d,e){return d(a,c)%e(a,c)},"===":function(a,c,d,e){return d(a,c)===e(a,c)},"!==":function(a,c,d,e){return d(a,c)!==e(a,c)},"==":function(a,c,d,e){return d(a,c)==e(a,c)},"!=":function(a,c,d,e){return d(a,c)!=e(a,c)},"<":function(a,c,d,e){return d(a,c)<e(a,c)},">":function(a,c,d,e){return d(a,c)>e(a,c)},"<=":function(a,c,d,e){return d(a,c)<=e(a,c)},">=":function(a,c,
d,e){return d(a,c)>=e(a,c)},"&&":function(a,c,d,e){return d(a,c)&&e(a,c)},"||":function(a,c,d,e){return d(a,c)||e(a,c)},"!":function(a,c,d){return!d(a,c)},"=":!0,"|":!0}),Tf={n:"\n",f:"\f",r:"\r",t:"\t",v:"\v","'":"'",'"':'"'},fc=function(a){this.options=a};fc.prototype={constructor:fc,lex:function(a){this.text=a;this.index=0;this.ch=t;for(this.tokens=[];this.index<this.text.length;)if(this.ch=this.text.charAt(this.index),this.is("\"'"))this.readString(this.ch);else if(this.isNumber(this.ch)||this.is(".")&&
this.isNumber(this.peek()))this.readNumber();else if(this.isIdent(this.ch))this.readIdent();else if(this.is("(){}[].,;:?"))this.tokens.push({index:this.index,text:this.ch}),this.index++;else if(this.isWhitespace(this.ch))this.index++;else{a=this.ch+this.peek();var c=a+this.peek(2),d=ic[this.ch],e=ic[a],f=ic[c];f?(this.tokens.push({index:this.index,text:c,fn:f}),this.index+=3):e?(this.tokens.push({index:this.index,text:a,fn:e}),this.index+=2):d?(this.tokens.push({index:this.index,text:this.ch,fn:d}),
this.index+=1):this.throwError("Unexpected next character ",this.index,this.index+1)}return this.tokens},is:function(a){return-1!==a.indexOf(this.ch)},peek:function(a){a=a||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return"0"<=a&&"9">=a},isWhitespace:function(a){return" "===a||"\r"===a||"\t"===a||"\n"===a||"\v"===a||"\u00a0"===a},isIdent:function(a){return"a"<=a&&"z">=a||"A"<=a&&"Z">=a||"_"===a||"$"===a},isExpOperator:function(a){return"-"===a||
"+"===a||this.isNumber(a)},throwError:function(a,c,d){d=d||this.index;c=y(c)?"s "+c+"-"+this.index+" ["+this.text.substring(c,d)+"]":" "+d;throw qa("lexerr",a,c,this.text);},readNumber:function(){for(var a="",c=this.index;this.index<this.text.length;){var d=R(this.text.charAt(this.index));if("."==d||this.isNumber(d))a+=d;else{var e=this.peek();if("e"==d&&this.isExpOperator(e))a+=d;else if(this.isExpOperator(d)&&e&&this.isNumber(e)&&"e"==a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||e&&
this.isNumber(e)||"e"!=a.charAt(a.length-1))break;else this.throwError("Invalid exponent")}this.index++}a*=1;this.tokens.push({index:c,text:a,constant:!0,fn:function(){return a}})},readIdent:function(){for(var a=this.text,c="",d=this.index,e,f,g,h;this.index<this.text.length;){h=this.text.charAt(this.index);if("."===h||this.isIdent(h)||this.isNumber(h))"."===h&&(e=this.index),c+=h;else break;this.index++}e&&"."===c[c.length-1]&&(this.index--,c=c.slice(0,-1),e=c.lastIndexOf("."),-1===e&&(e=t));if(e)for(f=
this.index;f<this.text.length;){h=this.text.charAt(f);if("("===h){g=c.substr(e-d+1);c=c.substr(0,e-d);this.index=f;break}if(this.isWhitespace(h))f++;else break}this.tokens.push({index:d,text:c,fn:Hb[c]||bd(c,this.options,a)});g&&(this.tokens.push({index:e,text:"."}),this.tokens.push({index:e+1,text:g}))},readString:function(a){var c=this.index;this.index++;for(var d="",e=a,f=!1;this.index<this.text.length;){var g=this.text.charAt(this.index),e=e+g;if(f)"u"===g?(f=this.text.substring(this.index+1,
this.index+5),f.match(/[\da-f]{4}/i)||this.throwError("Invalid unicode escape [\\u"+f+"]"),this.index+=4,d+=String.fromCharCode(parseInt(f,16))):d+=Tf[g]||g,f=!1;else if("\\"===g)f=!0;else{if(g===a){this.index++;this.tokens.push({index:c,text:e,string:d,constant:!0,fn:function(){return d}});return}d+=g}this.index++}this.throwError("Unterminated quote",c)}};var eb=function(a,c,d){this.lexer=a;this.$filter=c;this.options=d};eb.ZERO=F(function(){return 0},{sharedGetter:!0,constant:!0});eb.prototype=
{constructor:eb,parse:function(a){this.text=a;this.tokens=this.lexer.lex(a);a=this.statements();0!==this.tokens.length&&this.throwError("is an unexpected token",this.tokens[0]);a.literal=!!a.literal;a.constant=!!a.constant;return a},primary:function(){var a;if(this.expect("("))a=this.filterChain(),this.consume(")");else if(this.expect("["))a=this.arrayDeclaration();else if(this.expect("{"))a=this.object();else{var c=this.expect();(a=c.fn)||this.throwError("not a primary expression",c);c.constant&&
(a.constant=!0,a.literal=!0)}for(var d;c=this.expect("(","[",".");)"("===c.text?(a=this.functionCall(a,d),d=null):"["===c.text?(d=a,a=this.objectIndex(a)):"."===c.text?(d=a,a=this.fieldAccess(a)):this.throwError("IMPOSSIBLE");return a},throwError:function(a,c){throw qa("syntax",c.text,a,c.index+1,this.text,this.text.substring(c.index));},peekToken:function(){if(0===this.tokens.length)throw qa("ueoe",this.text);return this.tokens[0]},peek:function(a,c,d,e){if(0<this.tokens.length){var f=this.tokens[0],
g=f.text;if(g===a||g===c||g===d||g===e||!(a||c||d||e))return f}return!1},expect:function(a,c,d,e){return(a=this.peek(a,c,d,e))?(this.tokens.shift(),a):!1},consume:function(a){this.expect(a)||this.throwError("is unexpected, expecting ["+a+"]",this.peek())},unaryFn:function(a,c){return F(function(d,e){return a(d,e,c)},{constant:c.constant,inputs:[c]})},binaryFn:function(a,c,d,e){return F(function(e,g){return c(e,g,a,d)},{constant:a.constant&&d.constant,inputs:!e&&[a,d]})},statements:function(){for(var a=
[];;)if(0<this.tokens.length&&!this.peek("}",")",";","]")&&a.push(this.filterChain()),!this.expect(";"))return 1===a.length?a[0]:function(c,d){for(var e,f=0,g=a.length;f<g;f++)e=a[f](c,d);return e}},filterChain:function(){for(var a=this.expression();this.expect("|");)a=this.filter(a);return a},filter:function(a){var c=this.expect(),d=this.$filter(c.text),e,f;if(this.peek(":"))for(e=[],f=[];this.expect(":");)e.push(this.expression());c=[a].concat(e||[]);return F(function(c,h){var k=a(c,h);if(f){f[0]=
k;for(k=e.length;k--;)f[k+1]=e[k](c,h);return d.apply(t,f)}return d(k)},{constant:!d.$stateful&&c.every(dc),inputs:!d.$stateful&&c})},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary(),c,d;return(d=this.expect("="))?(a.assign||this.throwError("implies assignment but ["+this.text.substring(0,d.index)+"] can not be assigned to",d),c=this.ternary(),F(function(d,f){return a.assign(d,c(d,f),f)},{inputs:[a,c]})):a},ternary:function(){var a=this.logicalOR(),c,d;if(d=
this.expect("?")){c=this.assignment();if(d=this.expect(":")){var e=this.assignment();return F(function(d,g){return a(d,g)?c(d,g):e(d,g)},{constant:a.constant&&c.constant&&e.constant})}this.throwError("expected :",d)}return a},logicalOR:function(){for(var a=this.logicalAND(),c;c=this.expect("||");)a=this.binaryFn(a,c.fn,this.logicalAND(),!0);return a},logicalAND:function(){var a=this.equality(),c;if(c=this.expect("&&"))a=this.binaryFn(a,c.fn,this.logicalAND(),!0);return a},equality:function(){var a=
this.relational(),c;if(c=this.expect("==","!=","===","!=="))a=this.binaryFn(a,c.fn,this.equality());return a},relational:function(){var a=this.additive(),c;if(c=this.expect("<",">","<=",">="))a=this.binaryFn(a,c.fn,this.relational());return a},additive:function(){for(var a=this.multiplicative(),c;c=this.expect("+","-");)a=this.binaryFn(a,c.fn,this.multiplicative());return a},multiplicative:function(){for(var a=this.unary(),c;c=this.expect("*","/","%");)a=this.binaryFn(a,c.fn,this.unary());return a},
unary:function(){var a;return this.expect("+")?this.primary():(a=this.expect("-"))?this.binaryFn(eb.ZERO,a.fn,this.unary()):(a=this.expect("!"))?this.unaryFn(a.fn,this.unary()):this.primary()},fieldAccess:function(a){var c=this.text,d=this.expect().text,e=bd(d,this.options,c);return F(function(c,d,h){return e(h||a(c,d))},{assign:function(e,g,h){(h=a(e,h))||a.assign(e,h={});return Pa(h,d,g,c)}})},objectIndex:function(a){var c=this.text,d=this.expression();this.consume("]");return F(function(e,f){var g=
a(e,f),h=d(e,f);pa(h,c);return g?ra(g[h],c):t},{assign:function(e,f,g){var h=pa(d(e,g),c);(g=ra(a(e,g),c))||a.assign(e,g={});return g[h]=f}})},functionCall:function(a,c){var d=[];if(")"!==this.peekToken().text){do d.push(this.expression());while(this.expect(","))}this.consume(")");var e=this.text,f=d.length?[]:null;return function(g,h){var k=c?c(g,h):g,l=a(g,h,k)||A;if(f)for(var m=d.length;m--;)f[m]=ra(d[m](g,h),e);ra(k,e);if(l){if(l.constructor===l)throw qa("isecfn",e);if(l===Qf||l===Rf||l===Sf)throw qa("isecff",
e);}k=l.apply?l.apply(k,f):l(f[0],f[1],f[2],f[3],f[4]);return ra(k,e)}},arrayDeclaration:function(){var a=[];if("]"!==this.peekToken().text){do{if(this.peek("]"))break;var c=this.expression();a.push(c)}while(this.expect(","))}this.consume("]");return F(function(c,e){for(var f=[],g=0,h=a.length;g<h;g++)f.push(a[g](c,e));return f},{literal:!0,constant:a.every(dc),inputs:a})},object:function(){var a=[],c=[];if("}"!==this.peekToken().text){do{if(this.peek("}"))break;var d=this.expect();a.push(d.string||
d.text);this.consume(":");d=this.expression();c.push(d)}while(this.expect(","))}this.consume("}");return F(function(d,f){for(var g={},h=0,k=c.length;h<k;h++)g[a[h]]=c[h](d,f);return g},{literal:!0,constant:c.every(dc),inputs:c})}};var yf=oa(),xf=oa(),zf=Object.prototype.valueOf,Ca=v("$sce"),ja={HTML:"html",CSS:"css",URL:"url",RESOURCE_URL:"resourceUrl",JS:"js"},ia=v("$compile"),Z=U.createElement("a"),fd=Ba(T.location.href,!0);Cc.$inject=["$provide"];gd.$inject=["$locale"];id.$inject=["$locale"];var ld=
".",If={yyyy:$("FullYear",4),yy:$("FullYear",2,0,!0),y:$("FullYear",1),MMMM:Cb("Month"),MMM:Cb("Month",!0),MM:$("Month",2,1),M:$("Month",1,1),dd:$("Date",2),d:$("Date",1),HH:$("Hours",2),H:$("Hours",1),hh:$("Hours",2,-12),h:$("Hours",1,-12),mm:$("Minutes",2),m:$("Minutes",1),ss:$("Seconds",2),s:$("Seconds",1),sss:$("Milliseconds",3),EEEE:Cb("Day"),EEE:Cb("Day",!0),a:function(a,c){return 12>a.getHours()?c.AMPMS[0]:c.AMPMS[1]},Z:function(a){a=-1*a.getTimezoneOffset();return a=(0<=a?"+":"")+(Bb(Math[0<
a?"floor":"ceil"](a/60),2)+Bb(Math.abs(a%60),2))},ww:nd(2),w:nd(1)},Hf=/((?:[^yMdHhmsaZEw']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|w+))(.*)/,Gf=/^\-?\d+$/;hd.$inject=["$locale"];var Ef=da(R),Ff=da(qb);jd.$inject=["$parse"];var Qd=da({restrict:"E",compile:function(a,c){if(!c.href&&!c.xlinkHref&&!c.name)return function(a,c){var f="[object SVGAnimatedString]"===Ka.call(c.prop("href"))?"xlink:href":"href";c.on("click",function(a){c.attr(f)||a.preventDefault()})}}}),rb={};r(xb,function(a,
c){if("multiple"!=a){var d=xa("ng-"+c);rb[d]=function(){return{restrict:"A",priority:100,link:function(a,f,g){a.$watch(g[d],function(a){g.$set(c,!!a)})}}}}});r(Mc,function(a,c){rb[c]=function(){return{priority:100,link:function(a,e,f){if("ngPattern"===c&&"/"==f.ngPattern.charAt(0)&&(e=f.ngPattern.match(Kf))){f.$set("ngPattern",new RegExp(e[1],e[2]));return}a.$watch(f[c],function(a){f.$set(c,a)})}}}});r(["src","srcset","href"],function(a){var c=xa("ng-"+a);rb[c]=function(){return{priority:99,link:function(d,
e,f){var g=a,h=a;"href"===a&&"[object SVGAnimatedString]"===Ka.call(e.prop("href"))&&(h="xlinkHref",f.$attr[h]="xlink:href",g=null);f.$observe(c,function(c){c?(f.$set(h,c),Ia&&g&&e.prop(g,f[h])):"href"===a&&f.$set(h,null)})}}}});var Db={$addControl:A,$$renameControl:function(a,c){a.$name=c},$removeControl:A,$setValidity:A,$setDirty:A,$setPristine:A,$setSubmitted:A};od.$inject=["$element","$attrs","$scope","$animate","$interpolate"];var vd=function(a){return["$timeout",function(c){return{name:"form",
restrict:a?"EAC":"E",controller:od,compile:function(a){a.addClass(Ra).addClass(hb);return{pre:function(a,d,g,h){if(!("action"in g)){var k=function(c){a.$apply(function(){h.$commitViewValue();h.$setSubmitted()});c.preventDefault?c.preventDefault():c.returnValue=!1};d[0].addEventListener("submit",k,!1);d.on("$destroy",function(){c(function(){d[0].removeEventListener("submit",k,!1)},0,!1)})}var l=h.$$parentForm,m=h.$name;m&&(Pa(a,m,h,m),g.$observe(g.name?"name":"ngForm",function(c){m!==c&&(Pa(a,m,t,
m),m=c,Pa(a,m,h,m),l.$$renameControl(h,m))}));d.on("$destroy",function(){l.$removeControl(h);m&&Pa(a,m,t,m);F(h,Db)})}}}}}]},Rd=vd(),de=vd(!0),Jf=/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/,Uf=/^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/,Vf=/^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,Wf=/^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/,wd=/^(\d{4})-(\d{2})-(\d{2})$/,xd=/^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,
jc=/^(\d{4})-W(\d\d)$/,yd=/^(\d{4})-(\d\d)$/,zd=/^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,Xf=/(\s+|^)default(\s+|$)/,Gb=new v("ngModel"),Ad={text:function(a,c,d,e,f,g){fb(a,c,d,e,f,g);gc(e)},date:gb("date",wd,Fb(wd,["yyyy","MM","dd"]),"yyyy-MM-dd"),"datetime-local":gb("datetimelocal",xd,Fb(xd,"yyyy MM dd HH mm ss sss".split(" ")),"yyyy-MM-ddTHH:mm:ss.sss"),time:gb("time",zd,Fb(zd,["HH","mm","ss","sss"]),"HH:mm:ss.sss"),week:gb("week",jc,function(a,c){if(ea(a))return a;if(G(a)){jc.lastIndex=0;var d=
jc.exec(a);if(d){var e=+d[1],f=+d[2],g=d=0,h=0,k=0,l=md(e),f=7*(f-1);c&&(d=c.getHours(),g=c.getMinutes(),h=c.getSeconds(),k=c.getMilliseconds());return new Date(e,0,l.getDate()+f,d,g,h,k)}}return NaN},"yyyy-Www"),month:gb("month",yd,Fb(yd,["yyyy","MM"]),"yyyy-MM"),number:function(a,c,d,e,f,g){qd(a,c,d,e);fb(a,c,d,e,f,g);e.$$parserName="number";e.$parsers.push(function(a){return e.$isEmpty(a)?null:Wf.test(a)?parseFloat(a):t});e.$formatters.push(function(a){if(!e.$isEmpty(a)){if(!V(a))throw Gb("numfmt",
a);a=a.toString()}return a});if(d.min||d.ngMin){var h;e.$validators.min=function(a){return e.$isEmpty(a)||w(h)||a>=h};d.$observe("min",function(a){y(a)&&!V(a)&&(a=parseFloat(a,10));h=V(a)&&!isNaN(a)?a:t;e.$validate()})}if(d.max||d.ngMax){var k;e.$validators.max=function(a){return e.$isEmpty(a)||w(k)||a<=k};d.$observe("max",function(a){y(a)&&!V(a)&&(a=parseFloat(a,10));k=V(a)&&!isNaN(a)?a:t;e.$validate()})}},url:function(a,c,d,e,f,g){fb(a,c,d,e,f,g);gc(e);e.$$parserName="url";e.$validators.url=function(a){return e.$isEmpty(a)||
Uf.test(a)}},email:function(a,c,d,e,f,g){fb(a,c,d,e,f,g);gc(e);e.$$parserName="email";e.$validators.email=function(a){return e.$isEmpty(a)||Vf.test(a)}},radio:function(a,c,d,e){w(d.name)&&c.attr("name",++ib);c.on("click",function(a){c[0].checked&&e.$setViewValue(d.value,a&&a.type)});e.$render=function(){c[0].checked=d.value==e.$viewValue};d.$observe("value",e.$render)},checkbox:function(a,c,d,e,f,g,h,k){var l=rd(k,a,"ngTrueValue",d.ngTrueValue,!0),m=rd(k,a,"ngFalseValue",d.ngFalseValue,!1);c.on("click",
function(a){e.$setViewValue(c[0].checked,a&&a.type)});e.$render=function(){c[0].checked=e.$viewValue};e.$isEmpty=function(a){return a!==l};e.$formatters.push(function(a){return ma(a,l)});e.$parsers.push(function(a){return a?l:m})},hidden:A,button:A,submit:A,reset:A,file:A},wc=["$browser","$sniffer","$filter","$parse",function(a,c,d,e){return{restrict:"E",require:["?ngModel"],link:{pre:function(f,g,h,k){k[0]&&(Ad[R(h.type)]||Ad.text)(f,g,h,k[0],c,a,d,e)}}}}],hb="ng-valid",sd="ng-invalid",Ra="ng-pristine",
Eb="ng-dirty",ud="ng-pending",Yf=["$scope","$exceptionHandler","$attrs","$element","$parse","$animate","$timeout","$rootScope","$q","$interpolate",function(a,c,d,e,f,g,h,k,l,m){this.$modelValue=this.$viewValue=Number.NaN;this.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=t;this.$name=m(d.name||
"",!1)(a);var p=f(d.ngModel),q=null,n=this,s=function(){var c=p(a);n.$options&&n.$options.getterSetter&&u(c)&&(c=c());return c},O=function(c){var d;n.$options&&n.$options.getterSetter&&u(d=p(a))?d(n.$modelValue):p.assign(a,n.$modelValue)};this.$$setOptions=function(a){n.$options=a;if(!(p.assign||a&&a.getterSetter))throw Gb("nonassign",d.ngModel,va(e));};this.$render=A;this.$isEmpty=function(a){return w(a)||""===a||null===a||a!==a};var D=e.inheritedData("$formController")||Db,x=0;pd({ctrl:this,$element:e,
set:function(a,c){a[c]=!0},unset:function(a,c){delete a[c]},parentForm:D,$animate:g});this.$setPristine=function(){n.$dirty=!1;n.$pristine=!0;g.removeClass(e,Eb);g.addClass(e,Ra)};this.$setUntouched=function(){n.$touched=!1;n.$untouched=!0;g.setClass(e,"ng-untouched","ng-touched")};this.$setTouched=function(){n.$touched=!0;n.$untouched=!1;g.setClass(e,"ng-touched","ng-untouched")};this.$rollbackViewValue=function(){h.cancel(q);n.$viewValue=n.$$lastCommittedViewValue;n.$render()};this.$validate=function(){V(n.$modelValue)&&
isNaN(n.$modelValue)||this.$$parseAndValidate()};this.$$runValidators=function(a,c,d,e){function f(){var a=!0;r(n.$validators,function(e,f){var g=e(c,d);a=a&&g;h(f,g)});return a?!0:(r(n.$asyncValidators,function(a,c){h(c,null)}),!1)}function g(){var a=[],e=!0;r(n.$asyncValidators,function(f,g){var k=f(c,d);if(!k||!u(k.then))throw Gb("$asyncValidators",k);h(g,t);a.push(k.then(function(){h(g,!0)},function(a){e=!1;h(g,!1)}))});a.length?l.all(a).then(function(){k(e)},A):k(!0)}function h(a,c){m===x&&n.$setValidity(a,
c)}function k(a){m===x&&e(a)}x++;var m=x;(function(a){var c=n.$$parserName||"parse";if(a===t)h(c,null);else if(h(c,a),!a)return r(n.$validators,function(a,c){h(c,null)}),r(n.$asyncValidators,function(a,c){h(c,null)}),!1;return!0})(a)?f()?g():k(!1):k(!1)};this.$commitViewValue=function(){var a=n.$viewValue;h.cancel(q);if(n.$$lastCommittedViewValue!==a||""===a&&n.$$hasNativeValidators)n.$$lastCommittedViewValue=a,n.$pristine&&(n.$dirty=!0,n.$pristine=!1,g.removeClass(e,Ra),g.addClass(e,Eb),D.$setDirty()),
this.$$parseAndValidate()};this.$$parseAndValidate=function(){var a=n.$$lastCommittedViewValue,c=a,d=w(c)?t:!0;if(d)for(var e=0;e<n.$parsers.length;e++)if(c=n.$parsers[e](c),w(c)){d=!1;break}V(n.$modelValue)&&isNaN(n.$modelValue)&&(n.$modelValue=s());var f=n.$modelValue,g=n.$options&&n.$options.allowInvalid;g&&(n.$modelValue=c,n.$modelValue!==f&&n.$$writeModelToScope());n.$$runValidators(d,c,a,function(a){g||(n.$modelValue=a?c:t,n.$modelValue!==f&&n.$$writeModelToScope())})};this.$$writeModelToScope=
function(){O(n.$modelValue);r(n.$viewChangeListeners,function(a){try{a()}catch(d){c(d)}})};this.$setViewValue=function(a,c){n.$viewValue=a;n.$options&&!n.$options.updateOnDefault||n.$$debounceViewValueCommit(c)};this.$$debounceViewValueCommit=function(c){var d=0,e=n.$options;e&&y(e.debounce)&&(e=e.debounce,V(e)?d=e:V(e[c])?d=e[c]:V(e["default"])&&(d=e["default"]));h.cancel(q);d?q=h(function(){n.$commitViewValue()},d):k.$$phase?n.$commitViewValue():a.$apply(function(){n.$commitViewValue()})};a.$watch(function(){var a=
s();if(a!==n.$modelValue){n.$modelValue=a;for(var c=n.$formatters,d=c.length,e=a;d--;)e=c[d](e);n.$viewValue!==e&&(n.$viewValue=n.$$lastCommittedViewValue=e,n.$render(),n.$$runValidators(t,a,e,A))}return a})}],se=function(){return{restrict:"A",require:["ngModel","^?form","^?ngModelOptions"],controller:Yf,priority:1,compile:function(a){a.addClass(Ra).addClass("ng-untouched").addClass(hb);return{pre:function(a,d,e,f){var g=f[0],h=f[1]||Db;g.$$setOptions(f[2]&&f[2].$options);h.$addControl(g);e.$observe("name",
function(a){g.$name!==a&&h.$$renameControl(g,a)});a.$on("$destroy",function(){h.$removeControl(g)})},post:function(a,d,e,f){var g=f[0];if(g.$options&&g.$options.updateOn)d.on(g.$options.updateOn,function(a){g.$$debounceViewValueCommit(a&&a.type)});d.on("blur",function(d){g.$touched||a.$apply(function(){g.$setTouched()})})}}}}},ue=da({restrict:"A",require:"ngModel",link:function(a,c,d,e){e.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),yc=function(){return{restrict:"A",require:"?ngModel",
link:function(a,c,d,e){e&&(d.required=!0,e.$validators.required=function(a){return!d.required||!e.$isEmpty(a)},d.$observe("required",function(){e.$validate()}))}}},xc=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){if(e){var f,g=d.ngPattern||d.pattern;d.$observe("pattern",function(a){G(a)&&0<a.length&&(a=new RegExp(a));if(a&&!a.test)throw v("ngPattern")("noregexp",g,a,va(c));f=a||t;e.$validate()});e.$validators.pattern=function(a){return e.$isEmpty(a)||w(f)||f.test(a)}}}}},
Ac=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){if(e){var f=0;d.$observe("maxlength",function(a){f=aa(a)||0;e.$validate()});e.$validators.maxlength=function(a,c){return e.$isEmpty(a)||c.length<=f}}}}},zc=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){if(e){var f=0;d.$observe("minlength",function(a){f=aa(a)||0;e.$validate()});e.$validators.minlength=function(a,c){return e.$isEmpty(a)||c.length>=f}}}}},te=function(){return{restrict:"A",priority:100,
require:"ngModel",link:function(a,c,d,e){var f=c.attr(d.$attr.ngList)||", ",g="false"!==d.ngTrim,h=g?P(f):f;e.$parsers.push(function(a){if(!w(a)){var c=[];a&&r(a.split(h),function(a){a&&c.push(g?P(a):a)});return c}});e.$formatters.push(function(a){return H(a)?a.join(f):t});e.$isEmpty=function(a){return!a||!a.length}}}},Zf=/^(true|false|\d+)$/,ve=function(){return{restrict:"A",priority:100,compile:function(a,c){return Zf.test(c.ngValue)?function(a,c,f){f.$set("value",a.$eval(f.ngValue))}:function(a,
c,f){a.$watch(f.ngValue,function(a){f.$set("value",a)})}}}},we=function(){return{restrict:"A",controller:["$scope","$attrs",function(a,c){var d=this;this.$options=a.$eval(c.ngModelOptions);this.$options.updateOn!==t?(this.$options.updateOnDefault=!1,this.$options.updateOn=P(this.$options.updateOn.replace(Xf,function(){d.$options.updateOnDefault=!0;return" "}))):this.$options.updateOnDefault=!0}]}},Wd=["$compile",function(a){return{restrict:"AC",compile:function(c){a.$$addBindingClass(c);return function(c,
e,f){a.$$addBindingInfo(e,f.ngBind);e=e[0];c.$watch(f.ngBind,function(a){e.textContent=a===t?"":a})}}}}],Yd=["$interpolate","$compile",function(a,c){return{compile:function(d){c.$$addBindingClass(d);return function(d,f,g){d=a(f.attr(g.$attr.ngBindTemplate));c.$$addBindingInfo(f,d.expressions);f=f[0];g.$observe("ngBindTemplate",function(a){f.textContent=a===t?"":a})}}}}],Xd=["$sce","$parse","$compile",function(a,c,d){return{restrict:"A",compile:function(e,f){var g=c(f.ngBindHtml),h=c(f.ngBindHtml,
function(a){return(a||"").toString()});d.$$addBindingClass(e);return function(c,e,f){d.$$addBindingInfo(e,f.ngBindHtml);c.$watch(h,function(){e.html(a.getTrustedHtml(g(c))||"")})}}}}],Zd=hc("",!0),ae=hc("Odd",0),$d=hc("Even",1),be=Ja({compile:function(a,c){c.$set("ngCloak",t);a.removeClass("ng-cloak")}}),ce=[function(){return{restrict:"A",scope:!0,controller:"@",priority:500}}],Bc={},$f={blur:!0,focus:!0};r("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),
function(a){var c=xa("ng-"+a);Bc[c]=["$parse","$rootScope",function(d,e){return{restrict:"A",compile:function(f,g){var h=d(g[c],null,!0);return function(c,d){d.on(a,function(d){var f=function(){h(c,{$event:d})};$f[a]&&e.$$phase?c.$evalAsync(f):c.$apply(f)})}}}}]});var fe=["$animate",function(a){return{multiElement:!0,transclude:"element",priority:600,terminal:!0,restrict:"A",$$tlb:!0,link:function(c,d,e,f,g){var h,k,l;c.$watch(e.ngIf,function(c){c?k||g(function(c,f){k=f;c[c.length++]=U.createComment(" end ngIf: "+
e.ngIf+" ");h={clone:c};a.enter(c,d.parent(),d)}):(l&&(l.remove(),l=null),k&&(k.$destroy(),k=null),h&&(l=pb(h.clone),a.leave(l).then(function(){l=null}),h=null))})}}}],ge=["$templateRequest","$anchorScroll","$animate","$sce",function(a,c,d,e){return{restrict:"ECA",priority:400,terminal:!0,transclude:"element",controller:wa.noop,compile:function(f,g){var h=g.ngInclude||g.src,k=g.onload||"",l=g.autoscroll;return function(f,g,q,n,r){var t=0,D,x,B,v=function(){x&&(x.remove(),x=null);D&&(D.$destroy(),
D=null);B&&(d.leave(B).then(function(){x=null}),x=B,B=null)};f.$watch(e.parseAsResourceUrl(h),function(e){var h=function(){!y(l)||l&&!f.$eval(l)||c()},q=++t;e?(a(e,!0).then(function(a){if(q===t){var c=f.$new();n.template=a;a=r(c,function(a){v();d.enter(a,null,g).then(h)});D=c;B=a;D.$emit("$includeContentLoaded",e);f.$eval(k)}},function(){q===t&&(v(),f.$emit("$includeContentError",e))}),f.$emit("$includeContentRequested",e)):(v(),n.template=null)})}}}}],xe=["$compile",function(a){return{restrict:"ECA",
priority:-400,require:"ngInclude",link:function(c,d,e,f){/SVG/.test(d[0].toString())?(d.empty(),a(Ec(f.template,U).childNodes)(c,function(a){d.append(a)},{futureParentElement:d})):(d.html(f.template),a(d.contents())(c))}}}],he=Ja({priority:450,compile:function(){return{pre:function(a,c,d){a.$eval(d.ngInit)}}}}),ie=Ja({terminal:!0,priority:1E3}),je=["$locale","$interpolate",function(a,c){var d=/{}/g;return{restrict:"EA",link:function(e,f,g){var h=g.count,k=g.$attr.when&&f.attr(g.$attr.when),l=g.offset||
0,m=e.$eval(k)||{},p={},q=c.startSymbol(),n=c.endSymbol(),s=/^when(Minus)?(.+)$/;r(g,function(a,c){s.test(c)&&(m[R(c.replace("when","").replace("Minus","-"))]=f.attr(g.$attr[c]))});r(m,function(a,e){p[e]=c(a.replace(d,q+h+"-"+l+n))});e.$watch(function(){var c=parseFloat(e.$eval(h));if(isNaN(c))return"";c in m||(c=a.pluralCat(c-l));return p[c](e)},function(a){f.text(a)})}}}],ke=["$parse","$animate",function(a,c){var d=v("ngRepeat"),e=function(a,c,d,e,l,m,p){a[d]=e;l&&(a[l]=m);a.$index=c;a.$first=0===
c;a.$last=c===p-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(c&1))};return{restrict:"A",multiElement:!0,transclude:"element",priority:1E3,terminal:!0,$$tlb:!0,compile:function(f,g){var h=g.ngRepeat,k=U.createComment(" end ngRepeat: "+h+" "),l=h.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);if(!l)throw d("iexp",h);var m=l[1],p=l[2],q=l[3],n=l[4],l=m.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);if(!l)throw d("iidexp",m);var s=
l[3]||l[1],y=l[2];if(q&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(q)||/^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent)$/.test(q)))throw d("badident",q);var v,x,B,K,E={$id:Na};n?v=a(n):(B=function(a,c){return Na(c)},K=function(a){return a});return function(a,f,g,l,n){v&&(x=function(c,d,e){y&&(E[y]=c);E[s]=d;E.$index=e;return v(a,E)});var m=oa();a.$watchCollection(p,function(g){var l,p,C=f[0],v,E=oa(),A,D,w,F,H,u,G;q&&(a[q]=g);if(Sa(g))H=g,p=x||B;else{p=x||K;H=[];for(G in g)g.hasOwnProperty(G)&&
"$"!=G.charAt(0)&&H.push(G);H.sort()}A=H.length;G=Array(A);for(l=0;l<A;l++)if(D=g===H?l:H[l],w=g[D],F=p(D,w,l),m[F])u=m[F],delete m[F],E[F]=u,G[l]=u;else{if(E[F])throw r(G,function(a){a&&a.scope&&(m[a.id]=a)}),d("dupes",h,F,ua(w));G[l]={id:F,scope:t,clone:t};E[F]=!0}for(v in m){u=m[v];F=pb(u.clone);c.leave(F);if(F[0].parentNode)for(l=0,p=F.length;l<p;l++)F[l].$$NG_REMOVED=!0;u.scope.$destroy()}for(l=0;l<A;l++)if(D=g===H?l:H[l],w=g[D],u=G[l],u.scope){v=C;do v=v.nextSibling;while(v&&v.$$NG_REMOVED);
u.clone[0]!=v&&c.move(pb(u.clone),null,z(C));C=u.clone[u.clone.length-1];e(u.scope,l,s,w,y,D,A)}else n(function(a,d){u.scope=d;var f=k.cloneNode(!1);a[a.length++]=f;c.enter(a,null,z(C));C=f;u.clone=a;E[u.id]=u;e(u.scope,l,s,w,y,D,A)});m=E})}}}}],le=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(c,d,e){c.$watch(e.ngShow,function(c){a[c?"removeClass":"addClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],ee=["$animate",function(a){return{restrict:"A",multiElement:!0,
link:function(c,d,e){c.$watch(e.ngHide,function(c){a[c?"addClass":"removeClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],me=Ja(function(a,c,d){a.$watch(d.ngStyle,function(a,d){d&&a!==d&&r(d,function(a,d){c.css(d,"")});a&&c.css(a)},!0)}),ne=["$animate",function(a){return{restrict:"EA",require:"ngSwitch",controller:["$scope",function(){this.cases={}}],link:function(c,d,e,f){var g=[],h=[],k=[],l=[],m=function(a,c){return function(){a.splice(c,1)}};c.$watch(e.ngSwitch||e.on,function(c){var d,
e;d=0;for(e=k.length;d<e;++d)a.cancel(k[d]);d=k.length=0;for(e=l.length;d<e;++d){var s=pb(h[d].clone);l[d].$destroy();(k[d]=a.leave(s)).then(m(k,d))}h.length=0;l.length=0;(g=f.cases["!"+c]||f.cases["?"])&&r(g,function(c){c.transclude(function(d,e){l.push(e);var f=c.element;d[d.length++]=U.createComment(" end ngSwitchWhen: ");h.push({clone:d});a.enter(d,f.parent(),f)})})})}}}],oe=Ja({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,c,d,e,f){e.cases["!"+d.ngSwitchWhen]=
e.cases["!"+d.ngSwitchWhen]||[];e.cases["!"+d.ngSwitchWhen].push({transclude:f,element:c})}}),pe=Ja({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,c,d,e,f){e.cases["?"]=e.cases["?"]||[];e.cases["?"].push({transclude:f,element:c})}}),re=Ja({restrict:"EAC",link:function(a,c,d,e,f){if(!f)throw v("ngTransclude")("orphan",va(c));f(function(a){c.empty();c.append(a)})}}),Sd=["$templateCache",function(a){return{restrict:"E",terminal:!0,compile:function(c,d){"text/ng-template"==
d.type&&a.put(d.id,c[0].text)}}}],ag=v("ngOptions"),qe=da({restrict:"A",terminal:!0}),Td=["$compile","$parse",function(a,c){var d=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,e={$setViewValue:A};return{restrict:"E",require:["select","?ngModel"],controller:["$element","$scope","$attrs",function(a,c,d){var k=this,l={},m=e,p;k.databound=d.ngModel;
k.init=function(a,c,d){m=a;p=d};k.addOption=function(c,d){Ma(c,'"option value"');l[c]=!0;m.$viewValue==c&&(a.val(c),p.parent()&&p.remove());d&&d[0].hasAttribute("selected")&&(d[0].selected=!0)};k.removeOption=function(a){this.hasOption(a)&&(delete l[a],m.$viewValue==a&&this.renderUnknownOption(a))};k.renderUnknownOption=function(c){c="? "+Na(c)+" ?";p.val(c);a.prepend(p);a.val(c);p.prop("selected",!0)};k.hasOption=function(a){return l.hasOwnProperty(a)};c.$on("$destroy",function(){k.renderUnknownOption=
A})}],link:function(e,g,h,k){function l(a,c,d,e){d.$render=function(){var a=d.$viewValue;e.hasOption(a)?(E.parent()&&E.remove(),c.val(a),""===a&&u.prop("selected",!0)):w(a)&&u?c.val(""):e.renderUnknownOption(a)};c.on("change",function(){a.$apply(function(){E.parent()&&E.remove();d.$setViewValue(c.val())})})}function m(a,c,d){var e;d.$render=function(){var a=new bb(d.$viewValue);r(c.find("option"),function(c){c.selected=y(a.get(c.value))})};a.$watch(function(){ma(e,d.$viewValue)||(e=ta(d.$viewValue),
d.$render())});c.on("change",function(){a.$apply(function(){var a=[];r(c.find("option"),function(c){c.selected&&a.push(c.value)});d.$setViewValue(a)})})}function p(e,f,g){function h(a,c,d){T[A]=d;G&&(T[G]=c);return a(e,T)}function k(a){var c;if(n)if(M&&H(a)){c=new bb([]);for(var d=0;d<a.length;d++)c.put(h(M,null,a[d]),!0)}else c=new bb(a);else M&&(a=h(M,null,a));return function(d,e){var f;f=M?M:w?w:D;return n?y(c.remove(h(f,d,e))):a===h(f,d,e)}}function l(){x||(e.$$postDigest(p),x=!0)}function m(a,
c,d){a[c]=a[c]||0;a[c]+=d?1:-1}function p(){x=!1;var a={"":[]},c=[""],d,l,s,t,u;s=g.$viewValue;t=J(e)||[];var A=G?Object.keys(t).sort():t,w,z,H,D,Q={};u=k(s);var P=!1,U,V;S={};for(D=0;H=A.length,D<H;D++){w=D;if(G&&(w=A[D],"$"===w.charAt(0)))continue;z=t[w];d=h(I,w,z)||"";(l=a[d])||(l=a[d]=[],c.push(d));d=u(w,z);P=P||d;z=h(E,w,z);z=y(z)?z:"";V=M?M(e,T):G?A[D]:D;M&&(S[V]=w);l.push({id:V,label:z,selected:d})}n||(v||null===s?a[""].unshift({id:"",label:"",selected:!P}):P||a[""].unshift({id:"?",label:"",
selected:!0}));w=0;for(A=c.length;w<A;w++){d=c[w];l=a[d];R.length<=w?(s={element:F.clone().attr("label",d),label:l.label},t=[s],R.push(t),f.append(s.element)):(t=R[w],s=t[0],s.label!=d&&s.element.attr("label",s.label=d));P=null;D=0;for(H=l.length;D<H;D++)d=l[D],(u=t[D+1])?(P=u.element,u.label!==d.label&&(m(Q,u.label,!1),m(Q,d.label,!0),P.text(u.label=d.label)),u.id!==d.id&&P.val(u.id=d.id),P[0].selected!==d.selected&&(P.prop("selected",u.selected=d.selected),Ia&&P.prop("selected",u.selected))):(""===
d.id&&v?U=v:(U=B.clone()).val(d.id).prop("selected",d.selected).attr("selected",d.selected).text(d.label),t.push(u={element:U,label:d.label,id:d.id,selected:d.selected}),m(Q,d.label,!0),P?P.after(U):s.element.append(U),P=U);for(D++;t.length>D;)d=t.pop(),m(Q,d.label,!1),d.element.remove();r(Q,function(a,c){0<a?q.addOption(c):0>a&&q.removeOption(c)})}for(;R.length>w;)R.pop()[0].element.remove()}var u;if(!(u=s.match(d)))throw ag("iexp",s,va(f));var E=c(u[2]||u[1]),A=u[4]||u[6],z=/ as /.test(u[0])&&u[1],
w=z?c(z):null,G=u[5],I=c(u[3]||""),D=c(u[2]?u[1]:A),J=c(u[7]),M=u[8]?c(u[8]):null,S={},R=[[{element:f,label:""}]],T={};v&&(a(v)(e),v.removeClass("ng-scope"),v.remove());f.empty();f.on("change",function(){e.$apply(function(){var a=J(e)||[],c;if(n)c=[],r(f.val(),function(d){d=M?S[d]:d;c.push("?"===d?t:""===d?null:h(w?w:D,d,a[d]))});else{var d=M?S[f.val()]:f.val();c="?"===d?t:""===d?null:h(w?w:D,d,a[d])}g.$setViewValue(c);p()})});g.$render=p;e.$watchCollection(J,l);e.$watchCollection(function(){var a=
J(e),c;if(a&&H(a)){c=Array(a.length);for(var d=0,f=a.length;d<f;d++)c[d]=h(E,d,a[d])}else if(a)for(d in c={},a)a.hasOwnProperty(d)&&(c[d]=h(E,d,a[d]));return c},l);n&&e.$watchCollection(function(){return g.$modelValue},l)}if(k[1]){var q=k[0];k=k[1];var n=h.multiple,s=h.ngOptions,v=!1,u,x=!1,B=z(U.createElement("option")),F=z(U.createElement("optgroup")),E=B.clone();h=0;for(var A=g.children(),G=A.length;h<G;h++)if(""===A[h].value){u=v=A.eq(h);break}q.init(k,v,E);n&&(k.$isEmpty=function(a){return!a||
0===a.length});s?p(e,g,k):n?m(e,g,k):l(e,g,k,q)}}}}],Vd=["$interpolate",function(a){var c={addOption:A,removeOption:A};return{restrict:"E",priority:100,compile:function(d,e){if(w(e.value)){var f=a(d.text(),!0);f||e.$set("value",d.text())}return function(a,d,e){var l=d.parent(),m=l.data("$selectController")||l.parent().data("$selectController");m&&m.databound||(m=c);f?a.$watch(f,function(a,c){e.$set("value",a);c!==a&&m.removeOption(c);m.addOption(a,d)}):m.addOption(e.value,d);d.on("$destroy",function(){m.removeOption(e.value)})}}}}],
Ud=da({restrict:"E",terminal:!1});T.angular.bootstrap?console.log("WARNING: Tried to load angular more than once."):(Kd(),Md(wa),z(U).ready(function(){Gd(U,sc)}))})(window,document);!window.angular.$$csp()&&window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}</style>');
//# sourceMappingURL=angular.min.js.map

/**
 * @license AngularJS v1.5.5
 * (c) 2010-2016 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

/* jshint ignore:start */
var noop        = angular.noop;
var copy        = angular.copy;
var extend      = angular.extend;
var jqLite      = angular.element;
var forEach     = angular.forEach;
var isArray     = angular.isArray;
var isString    = angular.isString;
var isObject    = angular.isObject;
var isUndefined = angular.isUndefined;
var isDefined   = angular.isDefined;
var isFunction  = angular.isFunction;
var isElement   = angular.isElement;

var ELEMENT_NODE = 1;
var COMMENT_NODE = 8;

var ADD_CLASS_SUFFIX = '-add';
var REMOVE_CLASS_SUFFIX = '-remove';
var EVENT_CLASS_PREFIX = 'ng-';
var ACTIVE_CLASS_SUFFIX = '-active';
var PREPARE_CLASS_SUFFIX = '-prepare';

var NG_ANIMATE_CLASSNAME = 'ng-animate';
var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';

// Detect proper transitionend/animationend event names.
var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;

// If unprefixed events are not supported but webkit-prefixed are, use the latter.
// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
// Register both events in case `window.onanimationend` is not supported because of that,
// do the same for `transitionend` as Safari is likely to exhibit similar behavior.
// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
// therefore there is no reason to test anymore for other vendor prefixes:
// http://caniuse.com/#search=transition
if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
  CSS_PREFIX = '-webkit-';
  TRANSITION_PROP = 'WebkitTransition';
  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
} else {
  TRANSITION_PROP = 'transition';
  TRANSITIONEND_EVENT = 'transitionend';
}

if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
  CSS_PREFIX = '-webkit-';
  ANIMATION_PROP = 'WebkitAnimation';
  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
} else {
  ANIMATION_PROP = 'animation';
  ANIMATIONEND_EVENT = 'animationend';
}

var DURATION_KEY = 'Duration';
var PROPERTY_KEY = 'Property';
var DELAY_KEY = 'Delay';
var TIMING_KEY = 'TimingFunction';
var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
var ANIMATION_PLAYSTATE_KEY = 'PlayState';
var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;

var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;

var isPromiseLike = function(p) {
  return p && p.then ? true : false;
};

var ngMinErr = angular.$$minErr('ng');
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
  }
  return arg;
}

function mergeClasses(a,b) {
  if (!a && !b) return '';
  if (!a) return b;
  if (!b) return a;
  if (isArray(a)) a = a.join(' ');
  if (isArray(b)) b = b.join(' ');
  return a + ' ' + b;
}

function packageStyles(options) {
  var styles = {};
  if (options && (options.to || options.from)) {
    styles.to = options.to;
    styles.from = options.from;
  }
  return styles;
}

function pendClasses(classes, fix, isPrefix) {
  var className = '';
  classes = isArray(classes)
      ? classes
      : classes && isString(classes) && classes.length
          ? classes.split(/\s+/)
          : [];
  forEach(classes, function(klass, i) {
    if (klass && klass.length > 0) {
      className += (i > 0) ? ' ' : '';
      className += isPrefix ? fix + klass
                            : klass + fix;
    }
  });
  return className;
}

function removeFromArray(arr, val) {
  var index = arr.indexOf(val);
  if (val >= 0) {
    arr.splice(index, 1);
  }
}

function stripCommentsFromElement(element) {
  if (element instanceof jqLite) {
    switch (element.length) {
      case 0:
        return [];
        break;

      case 1:
        // there is no point of stripping anything if the element
        // is the only element within the jqLite wrapper.
        // (it's important that we retain the element instance.)
        if (element[0].nodeType === ELEMENT_NODE) {
          return element;
        }
        break;

      default:
        return jqLite(extractElementNode(element));
        break;
    }
  }

  if (element.nodeType === ELEMENT_NODE) {
    return jqLite(element);
  }
}

function extractElementNode(element) {
  if (!element[0]) return element;
  for (var i = 0; i < element.length; i++) {
    var elm = element[i];
    if (elm.nodeType == ELEMENT_NODE) {
      return elm;
    }
  }
}

function $$addClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.addClass(elm, className);
  });
}

function $$removeClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.removeClass(elm, className);
  });
}

function applyAnimationClassesFactory($$jqLite) {
  return function(element, options) {
    if (options.addClass) {
      $$addClass($$jqLite, element, options.addClass);
      options.addClass = null;
    }
    if (options.removeClass) {
      $$removeClass($$jqLite, element, options.removeClass);
      options.removeClass = null;
    }
  }
}

function prepareAnimationOptions(options) {
  options = options || {};
  if (!options.$$prepared) {
    var domOperation = options.domOperation || noop;
    options.domOperation = function() {
      options.$$domOperationFired = true;
      domOperation();
      domOperation = noop;
    };
    options.$$prepared = true;
  }
  return options;
}

function applyAnimationStyles(element, options) {
  applyAnimationFromStyles(element, options);
  applyAnimationToStyles(element, options);
}

function applyAnimationFromStyles(element, options) {
  if (options.from) {
    element.css(options.from);
    options.from = null;
  }
}

function applyAnimationToStyles(element, options) {
  if (options.to) {
    element.css(options.to);
    options.to = null;
  }
}

function mergeAnimationDetails(element, oldAnimation, newAnimation) {
  var target = oldAnimation.options || {};
  var newOptions = newAnimation.options || {};

  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);

  if (newOptions.preparationClasses) {
    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
    delete newOptions.preparationClasses;
  }

  // noop is basically when there is no callback; otherwise something has been set
  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;

  extend(target, newOptions);

  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.
  if (realDomOperation) {
    target.domOperation = realDomOperation;
  }

  if (classes.addClass) {
    target.addClass = classes.addClass;
  } else {
    target.addClass = null;
  }

  if (classes.removeClass) {
    target.removeClass = classes.removeClass;
  } else {
    target.removeClass = null;
  }

  oldAnimation.addClass = target.addClass;
  oldAnimation.removeClass = target.removeClass;

  return target;
}

function resolveElementClasses(existing, toAdd, toRemove) {
  var ADD_CLASS = 1;
  var REMOVE_CLASS = -1;

  var flags = {};
  existing = splitClassesToLookup(existing);

  toAdd = splitClassesToLookup(toAdd);
  forEach(toAdd, function(value, key) {
    flags[key] = ADD_CLASS;
  });

  toRemove = splitClassesToLookup(toRemove);
  forEach(toRemove, function(value, key) {
    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
  });

  var classes = {
    addClass: '',
    removeClass: ''
  };

  forEach(flags, function(val, klass) {
    var prop, allow;
    if (val === ADD_CLASS) {
      prop = 'addClass';
      allow = !existing[klass];
    } else if (val === REMOVE_CLASS) {
      prop = 'removeClass';
      allow = existing[klass];
    }
    if (allow) {
      if (classes[prop].length) {
        classes[prop] += ' ';
      }
      classes[prop] += klass;
    }
  });

  function splitClassesToLookup(classes) {
    if (isString(classes)) {
      classes = classes.split(' ');
    }

    var obj = {};
    forEach(classes, function(klass) {
      // sometimes the split leaves empty string values
      // incase extra spaces were applied to the options
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }

  return classes;
}

function getDomNode(element) {
  return (element instanceof angular.element) ? element[0] : element;
}

function applyGeneratedPreparationClasses(element, event, options) {
  var classes = '';
  if (event) {
    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
  }
  if (options.addClass) {
    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
  }
  if (options.removeClass) {
    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
  }
  if (classes.length) {
    options.preparationClasses = classes;
    element.addClass(classes);
  }
}

function clearGeneratedClasses(element, options) {
  if (options.preparationClasses) {
    element.removeClass(options.preparationClasses);
    options.preparationClasses = null;
  }
  if (options.activeClasses) {
    element.removeClass(options.activeClasses);
    options.activeClasses = null;
  }
}

function blockTransitions(node, duration) {
  // we use a negative delay value since it performs blocking
  // yet it doesn't kill any existing transitions running on the
  // same element which makes this safe for class-based animations
  var value = duration ? '-' + duration + 's' : '';
  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
  return [TRANSITION_DELAY_PROP, value];
}

function blockKeyframeAnimations(node, applyBlock) {
  var value = applyBlock ? 'paused' : '';
  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
  applyInlineStyle(node, [key, value]);
  return [key, value];
}

function applyInlineStyle(node, styleTuple) {
  var prop = styleTuple[0];
  var value = styleTuple[1];
  node.style[prop] = value;
}

function concatWithSpace(a,b) {
  if (!a) return b;
  if (!b) return a;
  return a + ' ' + b;
}

var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
  var queue, cancelFn;

  function scheduler(tasks) {
    // we make a copy since RAFScheduler mutates the state
    // of the passed in array variable and this would be difficult
    // to track down on the outside code
    queue = queue.concat(tasks);
    nextTick();
  }

  queue = scheduler.queue = [];

  /* waitUntilQuiet does two things:
   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through
   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.
   *
   * The motivation here is that animation code can request more time from the scheduler
   * before the next wave runs. This allows for certain DOM properties such as classes to
   * be resolved in time for the next animation to run.
   */
  scheduler.waitUntilQuiet = function(fn) {
    if (cancelFn) cancelFn();

    cancelFn = $$rAF(function() {
      cancelFn = null;
      fn();
      nextTick();
    });
  };

  return scheduler;

  function nextTick() {
    if (!queue.length) return;

    var items = queue.shift();
    for (var i = 0; i < items.length; i++) {
      items[i]();
    }

    if (!cancelFn) {
      $$rAF(function() {
        if (!cancelFn) nextTick();
      });
    }
  }
}];

/**
 * @ngdoc directive
 * @name ngAnimateChildren
 * @restrict AE
 * @element ANY
 *
 * @description
 *
 * ngAnimateChildren allows you to specify that children of this element should animate even if any
 * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`
 * (structural) animation, child elements that also have an active structural animation are not animated.
 *
 * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).
 *
 *
 * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,
 *     then child animations are allowed. If the value is `false`, child animations are not allowed.
 *
 * @example
 * <example module="ngAnimateChildren" name="ngAnimateChildren" deps="angular-animate.js" animations="true">
     <file name="index.html">
       <div ng-controller="mainController as main">
         <label>Show container? <input type="checkbox" ng-model="main.enterElement" /></label>
         <label>Animate children? <input type="checkbox" ng-model="main.animateChildren" /></label>
         <hr>
         <div ng-animate-children="{{main.animateChildren}}">
           <div ng-if="main.enterElement" class="container">
             List of items:
             <div ng-repeat="item in [0, 1, 2, 3]" class="item">Item {{item}}</div>
           </div>
         </div>
       </div>
     </file>
     <file name="animations.css">

      .container.ng-enter,
      .container.ng-leave {
        transition: all ease 1.5s;
      }

      .container.ng-enter,
      .container.ng-leave-active {
        opacity: 0;
      }

      .container.ng-leave,
      .container.ng-enter-active {
        opacity: 1;
      }

      .item {
        background: firebrick;
        color: #FFF;
        margin-bottom: 10px;
      }

      .item.ng-enter,
      .item.ng-leave {
        transition: transform 1.5s ease;
      }

      .item.ng-enter {
        transform: translateX(50px);
      }

      .item.ng-enter-active {
        transform: translateX(0);
      }
    </file>
    <file name="script.js">
      angular.module('ngAnimateChildren', ['ngAnimate'])
        .controller('mainController', function() {
          this.animateChildren = false;
          this.enterElement = false;
        });
    </file>
  </example>
 */
var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
  return {
    link: function(scope, element, attrs) {
      var val = attrs.ngAnimateChildren;
      if (angular.isString(val) && val.length === 0) { //empty attribute
        element.data(NG_ANIMATE_CHILDREN_DATA, true);
      } else {
        // Interpolate and set the value, so that it is available to
        // animations that run right after compilation
        setData($interpolate(val)(scope));
        attrs.$observe('ngAnimateChildren', setData);
      }

      function setData(value) {
        value = value === 'on' || value === 'true';
        element.data(NG_ANIMATE_CHILDREN_DATA, value);
      }
    }
  };
}];

var ANIMATE_TIMER_KEY = '$$animateCss';

/**
 * @ngdoc service
 * @name $animateCss
 * @kind object
 *
 * @description
 * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes
 * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT
 * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or
 * directives to create more complex animations that can be purely driven using CSS code.
 *
 * Note that only browsers that support CSS transitions and/or keyframe animations are capable of
 * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).
 *
 * ## Usage
 * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that
 * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,
 * any automatic control over cancelling animations and/or preventing animations from being run on
 * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to
 * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger
 * the CSS animation.
 *
 * The example below shows how we can create a folding animation on an element using `ng-if`:
 *
 * ```html
 * <!-- notice the `fold-animation` CSS class -->
 * <div ng-if="onOff" class="fold-animation">
 *   This element will go BOOM
 * </div>
 * <button ng-click="onOff=true">Fold In</button>
 * ```
 *
 * Now we create the **JavaScript animation** that will trigger the CSS transition:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * ## More Advanced Uses
 *
 * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks
 * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.
 *
 * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,
 * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with
 * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order
 * to provide a working animation that will run in CSS.
 *
 * The example below showcases a more advanced version of the `.fold-animation` from the example above:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         addClass: 'red large-text pulse-twice',
 *         easing: 'ease-out',
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * Since we're adding/removing CSS classes then the CSS transition will also pick those up:
 *
 * ```css
 * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,
 * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/
 * .red { background:red; }
 * .large-text { font-size:20px; }
 *
 * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/
 * .pulse-twice {
 *   animation: 0.5s pulse linear 2;
 *   -webkit-animation: 0.5s pulse linear 2;
 * }
 *
 * @keyframes pulse {
 *   from { transform: scale(0.5); }
 *   to { transform: scale(1.5); }
 * }
 *
 * @-webkit-keyframes pulse {
 *   from { -webkit-transform: scale(0.5); }
 *   to { -webkit-transform: scale(1.5); }
 * }
 * ```
 *
 * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.
 *
 * ## How the Options are handled
 *
 * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation
 * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline
 * styles using the `from` and `to` properties.
 *
 * ```js
 * var animator = $animateCss(element, {
 *   from: { background:'red' },
 *   to: { background:'blue' }
 * });
 * animator.start();
 * ```
 *
 * ```css
 * .rotating-animation {
 *   animation:0.5s rotate linear;
 *   -webkit-animation:0.5s rotate linear;
 * }
 *
 * @keyframes rotate {
 *   from { transform: rotate(0deg); }
 *   to { transform: rotate(360deg); }
 * }
 *
 * @-webkit-keyframes rotate {
 *   from { -webkit-transform: rotate(0deg); }
 *   to { -webkit-transform: rotate(360deg); }
 * }
 * ```
 *
 * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is
 * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition
 * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition
 * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied
 * and spread across the transition and keyframe animation.
 *
 * ## What is returned
 *
 * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually
 * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are
 * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:
 *
 * ```js
 * var animator = $animateCss(element, { ... });
 * ```
 *
 * Now what do the contents of our `animator` variable look like:
 *
 * ```js
 * {
 *   // starts the animation
 *   start: Function,
 *
 *   // ends (aborts) the animation
 *   end: Function
 * }
 * ```
 *
 * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.
 * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been
 * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties
 * and that changing them will not reconfigure the parameters of the animation.
 *
 * ### runner.done() vs runner.then()
 * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the
 * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.
 * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`
 * unless you really need a digest to kick off afterwards.
 *
 * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss
 * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).
 * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.
 *
 * @param {DOMElement} element the element that will be animated
 * @param {object} options the animation-related options that will be applied during the animation
 *
 * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied
 * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)
 * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and
 * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.
 * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).
 * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).
 * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).
 * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.
 * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.
 * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.
 * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.
 * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`
 * is provided then the animation will be skipped entirely.
 * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is
 * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value
 * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same
 * CSS delay value.
 * * `stagger` - A numeric time value representing the delay between successively animated elements
 * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})
 * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a
 *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)
 * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)
 * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once
 *    the animation is closed. This is useful for when the styles are used purely for the sake of
 *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).
 *    By default this value is set to `false`.
 *
 * @return {object} an object with start and end methods and details about the animation.
 *
 * * `start` - The method to start the animation. This will return a `Promise` when called.
 * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.
 */
var ONE_SECOND = 1000;
var BASE_TEN = 10;

var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
var CLOSING_TIME_BUFFER = 1.5;

var DETECT_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP,
  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
};

var DETECT_STAGGER_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP
};

function getCssKeyframeDurationStyle(duration) {
  return [ANIMATION_DURATION_PROP, duration + 's'];
}

function getCssDelayStyle(delay, isKeyframeAnimation) {
  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
  return [prop, delay + 's'];
}

function computeCssStyles($window, element, properties) {
  var styles = Object.create(null);
  var detectedStyles = $window.getComputedStyle(element) || {};
  forEach(properties, function(formalStyleName, actualStyleName) {
    var val = detectedStyles[formalStyleName];
    if (val) {
      var c = val.charAt(0);

      // only numerical-based values have a negative sign or digit as the first value
      if (c === '-' || c === '+' || c >= 0) {
        val = parseMaxTime(val);
      }

      // by setting this to null in the event that the delay is not set or is set directly as 0
      // then we can still allow for negative values to be used later on and not mistake this
      // value for being greater than any other negative value.
      if (val === 0) {
        val = null;
      }
      styles[actualStyleName] = val;
    }
  });

  return styles;
}

function parseMaxTime(str) {
  var maxValue = 0;
  var values = str.split(/\s*,\s*/);
  forEach(values, function(value) {
    // it's always safe to consider only second values and omit `ms` values since
    // getComputedStyle will always handle the conversion for us
    if (value.charAt(value.length - 1) == 's') {
      value = value.substring(0, value.length - 1);
    }
    value = parseFloat(value) || 0;
    maxValue = maxValue ? Math.max(value, maxValue) : value;
  });
  return maxValue;
}

function truthyTimingValue(val) {
  return val === 0 || val != null;
}

function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
  var style = TRANSITION_PROP;
  var value = duration + 's';
  if (applyOnlyDuration) {
    style += DURATION_KEY;
  } else {
    value += ' linear all';
  }
  return [style, value];
}

function createLocalCacheLookup() {
  var cache = Object.create(null);
  return {
    flush: function() {
      cache = Object.create(null);
    },

    count: function(key) {
      var entry = cache[key];
      return entry ? entry.total : 0;
    },

    get: function(key) {
      var entry = cache[key];
      return entry && entry.value;
    },

    put: function(key, value) {
      if (!cache[key]) {
        cache[key] = { total: 1, value: value };
      } else {
        cache[key].total++;
      }
    }
  };
}

// we do not reassign an already present style value since
// if we detect the style property value again we may be
// detecting styles that were added via the `from` styles.
// We make use of `isDefined` here since an empty string
// or null value (which is what getPropertyValue will return
// for a non-existing style) will still be marked as a valid
// value for the style (a falsy value implies that the style
// is to be removed at the end of the animation). If we had a simple
// "OR" statement then it would not be enough to catch that.
function registerRestorableStyles(backup, node, properties) {
  forEach(properties, function(prop) {
    backup[prop] = isDefined(backup[prop])
        ? backup[prop]
        : node.style.getPropertyValue(prop);
  });
}

var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
  var gcsLookup = createLocalCacheLookup();
  var gcsStaggerLookup = createLocalCacheLookup();

  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',
               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',
       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,
                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    var parentCounter = 0;
    function gcsHashFn(node, extraClasses) {
      var KEY = "$$ngAnimateParentKey";
      var parentNode = node.parentNode;
      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
    }

    function computeCachedCssStyles(node, className, cacheKey, properties) {
      var timings = gcsLookup.get(cacheKey);

      if (!timings) {
        timings = computeCssStyles($window, node, properties);
        if (timings.animationIterationCount === 'infinite') {
          timings.animationIterationCount = 1;
        }
      }

      // we keep putting this in multiple times even though the value and the cacheKey are the same
      // because we're keeping an internal tally of how many duplicate animations are detected.
      gcsLookup.put(cacheKey, timings);
      return timings;
    }

    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
      var stagger;

      // if we have one or more existing matches of matching elements
      // containing the same parent + CSS styles (which is how cacheKey works)
      // then staggering is possible
      if (gcsLookup.count(cacheKey) > 0) {
        stagger = gcsStaggerLookup.get(cacheKey);

        if (!stagger) {
          var staggerClassName = pendClasses(className, '-stagger');

          $$jqLite.addClass(node, staggerClassName);

          stagger = computeCssStyles($window, node, properties);

          // force the conversion of a null value to zero incase not set
          stagger.animationDuration = Math.max(stagger.animationDuration, 0);
          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);

          $$jqLite.removeClass(node, staggerClassName);

          gcsStaggerLookup.put(cacheKey, stagger);
        }
      }

      return stagger || {};
    }

    var cancelLastRAFRequest;
    var rafWaitQueue = [];
    function waitUntilQuiet(callback) {
      rafWaitQueue.push(callback);
      $$rAFScheduler.waitUntilQuiet(function() {
        gcsLookup.flush();
        gcsStaggerLookup.flush();

        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.
        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.
        var pageWidth = $$forceReflow();

        // we use a for loop to ensure that if the queue is changed
        // during this looping then it will consider new requests
        for (var i = 0; i < rafWaitQueue.length; i++) {
          rafWaitQueue[i](pageWidth);
        }
        rafWaitQueue.length = 0;
      });
    }

    function computeTimings(node, className, cacheKey) {
      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
      var aD = timings.animationDelay;
      var tD = timings.transitionDelay;
      timings.maxDelay = aD && tD
          ? Math.max(aD, tD)
          : (aD || tD);
      timings.maxDuration = Math.max(
          timings.animationDuration * timings.animationIterationCount,
          timings.transitionDuration);

      return timings;
    }

    return function init(element, initialOptions) {
      // all of the animation functions should create
      // a copy of the options data, however, if a
      // parent service has already created a copy then
      // we should stick to using that
      var options = initialOptions || {};
      if (!options.$$prepared) {
        options = prepareAnimationOptions(copy(options));
      }

      var restoreStyles = {};
      var node = getDomNode(element);
      if (!node
          || !node.parentNode
          || !$$animateQueue.enabled()) {
        return closeAndReturnNoopAnimator();
      }

      var temporaryStyles = [];
      var classes = element.attr('class');
      var styles = packageStyles(options);
      var animationClosed;
      var animationPaused;
      var animationCompleted;
      var runner;
      var runnerHost;
      var maxDelay;
      var maxDelayTime;
      var maxDuration;
      var maxDurationTime;
      var startTime;
      var events = [];

      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
        return closeAndReturnNoopAnimator();
      }

      var method = options.event && isArray(options.event)
            ? options.event.join(' ')
            : options.event;

      var isStructural = method && options.structural;
      var structuralClassName = '';
      var addRemoveClassName = '';

      if (isStructural) {
        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
      } else if (method) {
        structuralClassName = method;
      }

      if (options.addClass) {
        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
      }

      if (options.removeClass) {
        if (addRemoveClassName.length) {
          addRemoveClassName += ' ';
        }
        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
      }

      // there may be a situation where a structural animation is combined together
      // with CSS classes that need to resolve before the animation is computed.
      // However this means that there is no explicit CSS code to block the animation
      // from happening (by setting 0s none in the class name). If this is the case
      // we need to apply the classes before the first rAF so we know to continue if
      // there actually is a detected transition or keyframe animation
      if (options.applyClassesEarly && addRemoveClassName.length) {
        applyAnimationClasses(element, options);
      }

      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
      var fullClassName = classes + ' ' + preparationClasses;
      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;

      // there is no way we can trigger an animation if no styles and
      // no classes are being applied which would then trigger a transition,
      // unless there a is raw keyframe value that is applied to the element.
      if (!containsKeyframeAnimation
           && !hasToStyles
           && !preparationClasses) {
        return closeAndReturnNoopAnimator();
      }

      var cacheKey, stagger;
      if (options.stagger > 0) {
        var staggerVal = parseFloat(options.stagger);
        stagger = {
          transitionDelay: staggerVal,
          animationDelay: staggerVal,
          transitionDuration: 0,
          animationDuration: 0
        };
      } else {
        cacheKey = gcsHashFn(node, fullClassName);
        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
      }

      if (!options.$$skipPreparationClasses) {
        $$jqLite.addClass(element, preparationClasses);
      }

      var applyOnlyDuration;

      if (options.transitionStyle) {
        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
        applyInlineStyle(node, transitionStyle);
        temporaryStyles.push(transitionStyle);
      }

      if (options.duration >= 0) {
        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);

        // we set the duration so that it will be picked up by getComputedStyle later
        applyInlineStyle(node, durationStyle);
        temporaryStyles.push(durationStyle);
      }

      if (options.keyframeStyle) {
        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
        applyInlineStyle(node, keyframeStyle);
        temporaryStyles.push(keyframeStyle);
      }

      var itemIndex = stagger
          ? options.staggerIndex >= 0
              ? options.staggerIndex
              : gcsLookup.count(cacheKey)
          : 0;

      var isFirst = itemIndex === 0;

      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY
      // without causing any combination of transitions to kick in. By adding a negative delay value
      // it forces the setup class' transition to end immediately. We later then remove the negative
      // transition delay to allow for the transition to naturally do it's thing. The beauty here is
      // that if there is no transition defined then nothing will happen and this will also allow
      // other transitions to be stacked on top of each other without any chopping them out.
      if (isFirst && !options.skipBlocking) {
        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
      }

      var timings = computeTimings(node, fullClassName, cacheKey);
      var relativeDelay = timings.maxDelay;
      maxDelay = Math.max(relativeDelay, 0);
      maxDuration = timings.maxDuration;

      var flags = {};
      flags.hasTransitions          = timings.transitionDuration > 0;
      flags.hasAnimations           = timings.animationDuration > 0;
      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';
      flags.applyTransitionDuration = hasToStyles && (
                                        (flags.hasTransitions && !flags.hasTransitionAll)
                                         || (flags.hasAnimations && !flags.hasTransitions));
      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;
      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;
      flags.recalculateTimingStyles = addRemoveClassName.length > 0;

      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;

        if (flags.applyTransitionDuration) {
          flags.hasTransitions = true;
          timings.transitionDuration = maxDuration;
          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
        }

        if (flags.applyAnimationDuration) {
          flags.hasAnimations = true;
          timings.animationDuration = maxDuration;
          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
        }
      }

      if (maxDuration === 0 && !flags.recalculateTimingStyles) {
        return closeAndReturnNoopAnimator();
      }

      if (options.delay != null) {
        var delayStyle;
        if (typeof options.delay !== "boolean") {
          delayStyle = parseFloat(options.delay);
          // number in options.delay means we have to recalculate the delay for the closing timeout
          maxDelay = Math.max(delayStyle, 0);
        }

        if (flags.applyTransitionDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle));
        }

        if (flags.applyAnimationDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle, true));
        }
      }

      // we need to recalculate the delay value since we used a pre-emptive negative
      // delay value and the delay value is required for the final event checking. This
      // property will ensure that this will happen after the RAF phase has passed.
      if (options.duration == null && timings.transitionDuration > 0) {
        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
      }

      maxDelayTime = maxDelay * ONE_SECOND;
      maxDurationTime = maxDuration * ONE_SECOND;
      if (!options.skipBlocking) {
        flags.blockTransition = timings.transitionDuration > 0;
        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&
                                       stagger.animationDelay > 0 &&
                                       stagger.animationDuration === 0;
      }

      if (options.from) {
        if (options.cleanupStyles) {
          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
        }
        applyAnimationFromStyles(element, options);
      }

      if (flags.blockTransition || flags.blockKeyframeAnimation) {
        applyBlocking(maxDuration);
      } else if (!options.skipBlocking) {
        blockTransitions(node, false);
      }

      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging
      return {
        $$willAnimate: true,
        end: endFn,
        start: function() {
          if (animationClosed) return;

          runnerHost = {
            end: endFn,
            cancel: cancelFn,
            resume: null, //this will be set during the start() phase
            pause: null
          };

          runner = new $$AnimateRunner(runnerHost);

          waitUntilQuiet(start);

          // we don't have access to pause/resume the animation
          // since it hasn't run yet. AnimateRunner will therefore
          // set noop functions for resume and pause and they will
          // later be overridden once the animation is triggered
          return runner;
        }
      };

      function endFn() {
        close();
      }

      function cancelFn() {
        close(true);
      }

      function close(rejected) { // jshint ignore:line
        // if the promise has been called already then we shouldn't close
        // the animation again
        if (animationClosed || (animationCompleted && animationPaused)) return;
        animationClosed = true;
        animationPaused = false;

        if (!options.$$skipPreparationClasses) {
          $$jqLite.removeClass(element, preparationClasses);
        }
        $$jqLite.removeClass(element, activeClasses);

        blockKeyframeAnimations(node, false);
        blockTransitions(node, false);

        forEach(temporaryStyles, function(entry) {
          // There is only one way to remove inline style properties entirely from elements.
          // By using `removeProperty` this works, but we need to convert camel-cased CSS
          // styles down to hyphenated values.
          node.style[entry[0]] = '';
        });

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);

        if (Object.keys(restoreStyles).length) {
          forEach(restoreStyles, function(value, prop) {
            value ? node.style.setProperty(prop, value)
                  : node.style.removeProperty(prop);
          });
        }

        // the reason why we have this option is to allow a synchronous closing callback
        // that is fired as SOON as the animation ends (when the CSS is removed) or if
        // the animation never takes off at all. A good example is a leave animation since
        // the element must be removed just after the animation is over or else the element
        // will appear on screen for one animation frame causing an overbearing flicker.
        if (options.onDone) {
          options.onDone();
        }

        if (events && events.length) {
          // Remove the transitionend / animationend listener(s)
          element.off(events.join(' '), onAnimationProgress);
        }

        //Cancel the fallback closing timeout and remove the timer data
        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
        if (animationTimerData) {
          $timeout.cancel(animationTimerData[0].timer);
          element.removeData(ANIMATE_TIMER_KEY);
        }

        // if the preparation function fails then the promise is not setup
        if (runner) {
          runner.complete(!rejected);
        }
      }

      function applyBlocking(duration) {
        if (flags.blockTransition) {
          blockTransitions(node, duration);
        }

        if (flags.blockKeyframeAnimation) {
          blockKeyframeAnimations(node, !!duration);
        }
      }

      function closeAndReturnNoopAnimator() {
        runner = new $$AnimateRunner({
          end: endFn,
          cancel: cancelFn
        });

        // should flush the cache animation
        waitUntilQuiet(noop);
        close();

        return {
          $$willAnimate: false,
          start: function() {
            return runner;
          },
          end: endFn
        };
      }

      function onAnimationProgress(event) {
        event.stopPropagation();
        var ev = event.originalEvent || event;

        // we now always use `Date.now()` due to the recent changes with
        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)
        var timeStamp = ev.$manualTimeStamp || Date.now();

        /* Firefox (or possibly just Gecko) likes to not round values up
         * when a ms measurement is used for the animation */
        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));

        /* $manualTimeStamp is a mocked timeStamp value which is set
         * within browserTrigger(). This is only here so that tests can
         * mock animations properly. Real events fallback to event.timeStamp,
         * or, if they don't, then a timeStamp is automatically created for them.
         * We're checking to see if the timeStamp surpasses the expected delay,
         * but we're using elapsedTime instead of the timeStamp on the 2nd
         * pre-condition since animationPauseds sometimes close off early */
        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
          // we set this flag to ensure that if the transition is paused then, when resumed,
          // the animation will automatically close itself since transitions cannot be paused.
          animationCompleted = true;
          close();
        }
      }

      function start() {
        if (animationClosed) return;
        if (!node.parentNode) {
          close();
          return;
        }

        // even though we only pause keyframe animations here the pause flag
        // will still happen when transitions are used. Only the transition will
        // not be paused since that is not possible. If the animation ends when
        // paused then it will not complete until unpaused or cancelled.
        var playPause = function(playAnimation) {
          if (!animationCompleted) {
            animationPaused = !playAnimation;
            if (timings.animationDuration) {
              var value = blockKeyframeAnimations(node, animationPaused);
              animationPaused
                  ? temporaryStyles.push(value)
                  : removeFromArray(temporaryStyles, value);
            }
          } else if (animationPaused && playAnimation) {
            animationPaused = false;
            close();
          }
        };

        // checking the stagger duration prevents an accidentally cascade of the CSS delay style
        // being inherited from the parent. If the transition duration is zero then we can safely
        // rely that the delay value is an intentional stagger delay style.
        var maxStagger = itemIndex > 0
                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||
                            (timings.animationDuration && stagger.animationDuration === 0))
                         && Math.max(stagger.animationDelay, stagger.transitionDelay);
        if (maxStagger) {
          $timeout(triggerAnimationStart,
                   Math.floor(maxStagger * itemIndex * ONE_SECOND),
                   false);
        } else {
          triggerAnimationStart();
        }

        // this will decorate the existing promise runner with pause/resume methods
        runnerHost.resume = function() {
          playPause(true);
        };

        runnerHost.pause = function() {
          playPause(false);
        };

        function triggerAnimationStart() {
          // just incase a stagger animation kicks in when the animation
          // itself was cancelled entirely
          if (animationClosed) return;

          applyBlocking(false);

          forEach(temporaryStyles, function(entry) {
            var key = entry[0];
            var value = entry[1];
            node.style[key] = value;
          });

          applyAnimationClasses(element, options);
          $$jqLite.addClass(element, activeClasses);

          if (flags.recalculateTimingStyles) {
            fullClassName = node.className + ' ' + preparationClasses;
            cacheKey = gcsHashFn(node, fullClassName);

            timings = computeTimings(node, fullClassName, cacheKey);
            relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;

            if (maxDuration === 0) {
              close();
              return;
            }

            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
          }

          if (flags.applyAnimationDelay) {
            relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay)
                  ? parseFloat(options.delay)
                  : relativeDelay;

            maxDelay = Math.max(relativeDelay, 0);
            timings.animationDelay = relativeDelay;
            delayStyle = getCssDelayStyle(relativeDelay, true);
            temporaryStyles.push(delayStyle);
            node.style[delayStyle[0]] = delayStyle[1];
          }

          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;

          if (options.easing) {
            var easeProp, easeVal = options.easing;
            if (flags.hasTransitions) {
              easeProp = TRANSITION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
            if (flags.hasAnimations) {
              easeProp = ANIMATION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
          }

          if (timings.transitionDuration) {
            events.push(TRANSITIONEND_EVENT);
          }

          if (timings.animationDuration) {
            events.push(ANIMATIONEND_EVENT);
          }

          startTime = Date.now();
          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
          var endTime = startTime + timerTime;

          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
          var setupFallbackTimer = true;
          if (animationsData.length) {
            var currentTimerData = animationsData[0];
            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
            if (setupFallbackTimer) {
              $timeout.cancel(currentTimerData.timer);
            } else {
              animationsData.push(close);
            }
          }

          if (setupFallbackTimer) {
            var timer = $timeout(onAnimationExpired, timerTime, false);
            animationsData[0] = {
              timer: timer,
              expectedEndTime: endTime
            };
            animationsData.push(close);
            element.data(ANIMATE_TIMER_KEY, animationsData);
          }

          if (events.length) {
            element.on(events.join(' '), onAnimationProgress);
          }

          if (options.to) {
            if (options.cleanupStyles) {
              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
            }
            applyAnimationToStyles(element, options);
          }
        }

        function onAnimationExpired() {
          var animationsData = element.data(ANIMATE_TIMER_KEY);

          // this will be false in the event that the element was
          // removed from the DOM (via a leave animation or something
          // similar)
          if (animationsData) {
            for (var i = 1; i < animationsData.length; i++) {
              animationsData[i]();
            }
            element.removeData(ANIMATE_TIMER_KEY);
          }
        }
      }
    };
  }];
}];

var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateCssDriver');

  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';

  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';

  function isDocumentFragment(node) {
    return node.parentNode && node.parentNode.nodeType === 11;
  }

  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',
       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {

    // only browsers that support these properties can render animations
    if (!$sniffer.animations && !$sniffer.transitions) return noop;

    var bodyNode = $document[0].body;
    var rootNode = getDomNode($rootElement);

    var rootBodyElement = jqLite(
      // this is to avoid using something that exists outside of the body
      // we also special case the doc fragment case because our unit test code
      // appends the $rootElement to the body after the app has been bootstrapped
      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
    );

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    return function initDriverFn(animationDetails) {
      return animationDetails.from && animationDetails.to
          ? prepareFromToAnchorAnimation(animationDetails.from,
                                         animationDetails.to,
                                         animationDetails.classes,
                                         animationDetails.anchors)
          : prepareRegularAnimation(animationDetails);
    };

    function filterCssClasses(classes) {
      //remove all the `ng-` stuff
      return classes.replace(/\bng-\S+\b/g, '');
    }

    function getUniqueValues(a, b) {
      if (isString(a)) a = a.split(' ');
      if (isString(b)) b = b.split(' ');
      return a.filter(function(val) {
        return b.indexOf(val) === -1;
      }).join(' ');
    }

    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
      var startingClasses = filterCssClasses(getClassVal(clone));

      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);

      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);

      rootBodyElement.append(clone);

      var animatorIn, animatorOut = prepareOutAnimation();

      // the user may not end up using the `out` animation and
      // only making use of the `in` animation or vice-versa.
      // In either case we should allow this and not assume the
      // animation is over unless both animations are not used.
      if (!animatorOut) {
        animatorIn = prepareInAnimation();
        if (!animatorIn) {
          return end();
        }
      }

      var startingAnimator = animatorOut || animatorIn;

      return {
        start: function() {
          var runner;

          var currentAnimation = startingAnimator.start();
          currentAnimation.done(function() {
            currentAnimation = null;
            if (!animatorIn) {
              animatorIn = prepareInAnimation();
              if (animatorIn) {
                currentAnimation = animatorIn.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  end();
                  runner.complete();
                });
                return currentAnimation;
              }
            }
            // in the event that there is no `in` animation
            end();
            runner.complete();
          });

          runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn
          });

          return runner;

          function endFn() {
            if (currentAnimation) {
              currentAnimation.end();
            }
          }
        }
      };

      function calculateAnchorStyles(anchor) {
        var styles = {};

        var coords = getDomNode(anchor).getBoundingClientRect();

        // we iterate directly since safari messes up and doesn't return
        // all the keys for the coords object when iterated
        forEach(['width','height','top','left'], function(key) {
          var value = coords[key];
          switch (key) {
            case 'top':
              value += bodyNode.scrollTop;
              break;
            case 'left':
              value += bodyNode.scrollLeft;
              break;
          }
          styles[key] = Math.floor(value) + 'px';
        });
        return styles;
      }

      function prepareOutAnimation() {
        var animator = $animateCss(clone, {
          addClass: NG_OUT_ANCHOR_CLASS_NAME,
          delay: true,
          from: calculateAnchorStyles(outAnchor)
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function getClassVal(element) {
        return element.attr('class') || '';
      }

      function prepareInAnimation() {
        var endingClasses = filterCssClasses(getClassVal(inAnchor));
        var toAdd = getUniqueValues(endingClasses, startingClasses);
        var toRemove = getUniqueValues(startingClasses, endingClasses);

        var animator = $animateCss(clone, {
          to: calculateAnchorStyles(inAnchor),
          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
          delay: true
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function end() {
        clone.remove();
        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
      }
    }

    function prepareFromToAnchorAnimation(from, to, classes, anchors) {
      var fromAnimation = prepareRegularAnimation(from, noop);
      var toAnimation = prepareRegularAnimation(to, noop);

      var anchorAnimations = [];
      forEach(anchors, function(anchor) {
        var outElement = anchor['out'];
        var inElement = anchor['in'];
        var animator = prepareAnchoredAnimation(classes, outElement, inElement);
        if (animator) {
          anchorAnimations.push(animator);
        }
      });

      // no point in doing anything when there are no elements to animate
      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;

      return {
        start: function() {
          var animationRunners = [];

          if (fromAnimation) {
            animationRunners.push(fromAnimation.start());
          }

          if (toAnimation) {
            animationRunners.push(toAnimation.start());
          }

          forEach(anchorAnimations, function(animation) {
            animationRunners.push(animation.start());
          });

          var runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn // CSS-driven animations cannot be cancelled, only ended
          });

          $$AnimateRunner.all(animationRunners, function(status) {
            runner.complete(status);
          });

          return runner;

          function endFn() {
            forEach(animationRunners, function(runner) {
              runner.end();
            });
          }
        }
      };
    }

    function prepareRegularAnimation(animationDetails) {
      var element = animationDetails.element;
      var options = animationDetails.options || {};

      if (animationDetails.structural) {
        options.event = animationDetails.event;
        options.structural = true;
        options.applyClassesEarly = true;

        // we special case the leave animation since we want to ensure that
        // the element is removed as soon as the animation is over. Otherwise
        // a flicker might appear or the element may not be removed at all
        if (animationDetails.event === 'leave') {
          options.onDone = options.domOperation;
        }
      }

      // We assign the preparationClasses as the actual animation event since
      // the internals of $animateCss will just suffix the event token values
      // with `-active` to trigger the animation.
      if (options.preparationClasses) {
        options.event = concatWithSpace(options.event, options.preparationClasses);
      }

      var animator = $animateCss(element, options);

      // the driver lookup code inside of $$animation attempts to spawn a
      // driver one by one until a driver returns a.$$willAnimate animator object.
      // $animateCss will always return an object, however, it will pass in
      // a flag as a hint as to whether an animation was detected or not
      return animator.$$willAnimate ? animator : null;
    }
  }];
}];

// TODO(matsko): use caching here to speed things up for detection
// TODO(matsko): add documentation
//  by the time...

var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',
       function($injector,   $$AnimateRunner,   $$jqLite) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
         // $animateJs(element, 'enter');
    return function(element, event, classes, options) {
      var animationClosed = false;

      // the `classes` argument is optional and if it is not used
      // then the classes will be resolved from the element's className
      // property as well as options.addClass/options.removeClass.
      if (arguments.length === 3 && isObject(classes)) {
        options = classes;
        classes = null;
      }

      options = prepareAnimationOptions(options);
      if (!classes) {
        classes = element.attr('class') || '';
        if (options.addClass) {
          classes += ' ' + options.addClass;
        }
        if (options.removeClass) {
          classes += ' ' + options.removeClass;
        }
      }

      var classesToAdd = options.addClass;
      var classesToRemove = options.removeClass;

      // the lookupAnimations function returns a series of animation objects that are
      // matched up with one or more of the CSS classes. These animation objects are
      // defined via the module.animation factory function. If nothing is detected then
      // we don't return anything which then makes $animation query the next driver.
      var animations = lookupAnimations(classes);
      var before, after;
      if (animations.length) {
        var afterFn, beforeFn;
        if (event == 'leave') {
          beforeFn = 'leave';
          afterFn = 'afterLeave'; // TODO(matsko): get rid of this
        } else {
          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
          afterFn = event;
        }

        if (event !== 'enter' && event !== 'move') {
          before = packageAnimations(element, event, options, animations, beforeFn);
        }
        after  = packageAnimations(element, event, options, animations, afterFn);
      }

      // no matching animations
      if (!before && !after) return;

      function applyOptions() {
        options.domOperation();
        applyAnimationClasses(element, options);
      }

      function close() {
        animationClosed = true;
        applyOptions();
        applyAnimationStyles(element, options);
      }

      var runner;

      return {
        $$willAnimate: true,
        end: function() {
          if (runner) {
            runner.end();
          } else {
            close();
            runner = new $$AnimateRunner();
            runner.complete(true);
          }
          return runner;
        },
        start: function() {
          if (runner) {
            return runner;
          }

          runner = new $$AnimateRunner();
          var closeActiveAnimations;
          var chain = [];

          if (before) {
            chain.push(function(fn) {
              closeActiveAnimations = before(fn);
            });
          }

          if (chain.length) {
            chain.push(function(fn) {
              applyOptions();
              fn(true);
            });
          } else {
            applyOptions();
          }

          if (after) {
            chain.push(function(fn) {
              closeActiveAnimations = after(fn);
            });
          }

          runner.setHost({
            end: function() {
              endAnimations();
            },
            cancel: function() {
              endAnimations(true);
            }
          });

          $$AnimateRunner.chain(chain, onComplete);
          return runner;

          function onComplete(success) {
            close(success);
            runner.complete(success);
          }

          function endAnimations(cancelled) {
            if (!animationClosed) {
              (closeActiveAnimations || noop)(cancelled);
              onComplete(cancelled);
            }
          }
        }
      };

      function executeAnimationFn(fn, element, event, options, onDone) {
        var args;
        switch (event) {
          case 'animate':
            args = [element, options.from, options.to, onDone];
            break;

          case 'setClass':
            args = [element, classesToAdd, classesToRemove, onDone];
            break;

          case 'addClass':
            args = [element, classesToAdd, onDone];
            break;

          case 'removeClass':
            args = [element, classesToRemove, onDone];
            break;

          default:
            args = [element, onDone];
            break;
        }

        args.push(options);

        var value = fn.apply(fn, args);
        if (value) {
          if (isFunction(value.start)) {
            value = value.start();
          }

          if (value instanceof $$AnimateRunner) {
            value.done(onDone);
          } else if (isFunction(value)) {
            // optional onEnd / onCancel callback
            return value;
          }
        }

        return noop;
      }

      function groupEventedAnimations(element, event, options, animations, fnName) {
        var operations = [];
        forEach(animations, function(ani) {
          var animation = ani[fnName];
          if (!animation) return;

          // note that all of these animations will run in parallel
          operations.push(function() {
            var runner;
            var endProgressCb;

            var resolved = false;
            var onAnimationComplete = function(rejected) {
              if (!resolved) {
                resolved = true;
                (endProgressCb || noop)(rejected);
                runner.complete(!rejected);
              }
            };

            runner = new $$AnimateRunner({
              end: function() {
                onAnimationComplete();
              },
              cancel: function() {
                onAnimationComplete(true);
              }
            });

            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
              var cancelled = result === false;
              onAnimationComplete(cancelled);
            });

            return runner;
          });
        });

        return operations;
      }

      function packageAnimations(element, event, options, animations, fnName) {
        var operations = groupEventedAnimations(element, event, options, animations, fnName);
        if (operations.length === 0) {
          var a,b;
          if (fnName === 'beforeSetClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
          } else if (fnName === 'setClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
          }

          if (a) {
            operations = operations.concat(a);
          }
          if (b) {
            operations = operations.concat(b);
          }
        }

        if (operations.length === 0) return;

        // TODO(matsko): add documentation
        return function startAnimation(callback) {
          var runners = [];
          if (operations.length) {
            forEach(operations, function(animateFn) {
              runners.push(animateFn());
            });
          }

          runners.length ? $$AnimateRunner.all(runners, callback) : callback();

          return function endFn(reject) {
            forEach(runners, function(runner) {
              reject ? runner.cancel() : runner.end();
            });
          };
        };
      }
    };

    function lookupAnimations(classes) {
      classes = isArray(classes) ? classes : classes.split(' ');
      var matches = [], flagMap = {};
      for (var i=0; i < classes.length; i++) {
        var klass = classes[i],
            animationFactory = $animateProvider.$$registeredAnimations[klass];
        if (animationFactory && !flagMap[klass]) {
          matches.push($injector.get(animationFactory));
          flagMap[klass] = true;
        }
      }
      return matches;
    }
  }];
}];

var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateJsDriver');
  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
    return function initDriverFn(animationDetails) {
      if (animationDetails.from && animationDetails.to) {
        var fromAnimation = prepareAnimation(animationDetails.from);
        var toAnimation = prepareAnimation(animationDetails.to);
        if (!fromAnimation && !toAnimation) return;

        return {
          start: function() {
            var animationRunners = [];

            if (fromAnimation) {
              animationRunners.push(fromAnimation.start());
            }

            if (toAnimation) {
              animationRunners.push(toAnimation.start());
            }

            $$AnimateRunner.all(animationRunners, done);

            var runner = new $$AnimateRunner({
              end: endFnFactory(),
              cancel: endFnFactory()
            });

            return runner;

            function endFnFactory() {
              return function() {
                forEach(animationRunners, function(runner) {
                  // at this point we cannot cancel animations for groups just yet. 1.5+
                  runner.end();
                });
              };
            }

            function done(status) {
              runner.complete(status);
            }
          }
        };
      } else {
        return prepareAnimation(animationDetails);
      }
    };

    function prepareAnimation(animationDetails) {
      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations
      var element = animationDetails.element;
      var event = animationDetails.event;
      var options = animationDetails.options;
      var classes = animationDetails.classes;
      return $$animateJs(element, event, classes, options);
    }
  }];
}];

var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
  var PRE_DIGEST_STATE = 1;
  var RUNNING_STATE = 2;
  var ONE_SPACE = ' ';

  var rules = this.rules = {
    skip: [],
    cancel: [],
    join: []
  };

  function makeTruthyCssClassMap(classString) {
    if (!classString) {
      return null;
    }

    var keys = classString.split(ONE_SPACE);
    var map = Object.create(null);

    forEach(keys, function(key) {
      map[key] = true;
    });
    return map;
  }

  function hasMatchingClasses(newClassString, currentClassString) {
    if (newClassString && currentClassString) {
      var currentClassMap = makeTruthyCssClassMap(currentClassString);
      return newClassString.split(ONE_SPACE).some(function(className) {
        return currentClassMap[className];
      });
    }
  }

  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
    return rules[ruleType].some(function(fn) {
      return fn(element, currentAnimation, previousAnimation);
    });
  }

  function hasAnimationClasses(animation, and) {
    var a = (animation.addClass || '').length > 0;
    var b = (animation.removeClass || '').length > 0;
    return and ? a && b : a || b;
  }

  rules.join.push(function(element, newAnimation, currentAnimation) {
    // if the new animation is class-based then we can just tack that on
    return !newAnimation.structural && hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // there is no need to animate anything if no classes are being added and
    // there is no structural animation that will be triggered
    return !newAnimation.structural && !hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // why should we trigger a new structural animation if the element will
    // be removed from the DOM anyway?
    return currentAnimation.event == 'leave' && newAnimation.structural;
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // if there is an ongoing current animation then don't even bother running the class-based animation
    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // there can never be two structural animations running at the same time
    return currentAnimation.structural && newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // if the previous animation is already running, but the new animation will
    // be triggered, but the new animation is structural
    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // cancel the animation if classes added / removed in both animation cancel each other out,
    // but only if the current animation isn't structural

    if (currentAnimation.structural) return false;

    var nA = newAnimation.addClass;
    var nR = newAnimation.removeClass;
    var cA = currentAnimation.addClass;
    var cR = currentAnimation.removeClass;

    // early detection to save the global CPU shortage :)
    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
      return false;
    }

    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
  });

  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',
               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',
       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,
                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {

    var activeAnimationsLookup = new $$HashMap();
    var disabledElementsLookup = new $$HashMap();
    var animationsEnabled = null;

    function postDigestTaskFactory() {
      var postDigestCalled = false;
      return function(fn) {
        // we only issue a call to postDigest before
        // it has first passed. This prevents any callbacks
        // from not firing once the animation has completed
        // since it will be out of the digest cycle.
        if (postDigestCalled) {
          fn();
        } else {
          $rootScope.$$postDigest(function() {
            postDigestCalled = true;
            fn();
          });
        }
      };
    }

    // Wait until all directive and route-related templates are downloaded and
    // compiled. The $templateRequest.totalPendingRequests variable keeps track of
    // all of the remote templates being currently downloaded. If there are no
    // templates currently downloading then the watcher will still fire anyway.
    var deregisterWatch = $rootScope.$watch(
      function() { return $templateRequest.totalPendingRequests === 0; },
      function(isEmpty) {
        if (!isEmpty) return;
        deregisterWatch();

        // Now that all templates have been downloaded, $animate will wait until
        // the post digest queue is empty before enabling animations. By having two
        // calls to $postDigest calls we can ensure that the flag is enabled at the
        // very end of the post digest queue. Since all of the animations in $animate
        // use $postDigest, it's important that the code below executes at the end.
        // This basically means that the page is fully downloaded and compiled before
        // any animations are triggered.
        $rootScope.$$postDigest(function() {
          $rootScope.$$postDigest(function() {
            // we check for null directly in the event that the application already called
            // .enabled() with whatever arguments that it provided it with
            if (animationsEnabled === null) {
              animationsEnabled = true;
            }
          });
        });
      }
    );

    var callbackRegistry = {};

    // remember that the classNameFilter is set during the provider/config
    // stage therefore we can optimize here and setup a helper function
    var classNameFilter = $animateProvider.classNameFilter();
    var isAnimatableClassName = !classNameFilter
              ? function() { return true; }
              : function(className) {
                return classNameFilter.test(className);
              };

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function normalizeAnimationDetails(element, animation) {
      return mergeAnimationDetails(element, animation, {});
    }

    // IE9-11 has no method "contains" in SVG element and in Node.prototype. Bug #10259.
    var contains = window.Node.prototype.contains || function(arg) {
      // jshint bitwise: false
      return this === arg || !!(this.compareDocumentPosition(arg) & 16);
      // jshint bitwise: true
    };

    function findCallbacks(parent, element, event) {
      var targetNode = getDomNode(element);
      var targetParentNode = getDomNode(parent);

      var matches = [];
      var entries = callbackRegistry[event];
      if (entries) {
        forEach(entries, function(entry) {
          if (contains.call(entry.node, targetNode)) {
            matches.push(entry.callback);
          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
            matches.push(entry.callback);
          }
        });
      }

      return matches;
    }

    function filterFromRegistry(list, matchContainer, matchCallback) {
      var containerNode = extractElementNode(matchContainer);
      return list.filter(function(entry) {
        var isMatch = entry.node === containerNode &&
                        (!matchCallback || entry.callback === matchCallback);
        return !isMatch;
      });
    }

    function cleanupEventListeners(phase, element) {
      if (phase === 'close' && !element[0].parentNode) {
        // If the element is not attached to a parentNode, it has been removed by
        // the domOperation, and we can safely remove the event callbacks
        $animate.off(element);
      }
    }

    var $animate = {
      on: function(event, container, callback) {
        var node = extractElementNode(container);
        callbackRegistry[event] = callbackRegistry[event] || [];
        callbackRegistry[event].push({
          node: node,
          callback: callback
        });

        // Remove the callback when the element is removed from the DOM
        jqLite(container).on('$destroy', function() {
          var animationDetails = activeAnimationsLookup.get(node);

          if (!animationDetails) {
            // If there's an animation ongoing, the callback calling code will remove
            // the event listeners. If we'd remove here, the callbacks would be removed
            // before the animation ends
            $animate.off(event, container, callback);
          }
        });
      },

      off: function(event, container, callback) {
        if (arguments.length === 1 && !angular.isString(arguments[0])) {
          container = arguments[0];
          for (var eventType in callbackRegistry) {
            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
          }

          return;
        }

        var entries = callbackRegistry[event];
        if (!entries) return;

        callbackRegistry[event] = arguments.length === 1
            ? null
            : filterFromRegistry(entries, container, callback);
      },

      pin: function(element, parentElement) {
        assertArg(isElement(element), 'element', 'not an element');
        assertArg(isElement(parentElement), 'parentElement', 'not an element');
        element.data(NG_ANIMATE_PIN_DATA, parentElement);
      },

      push: function(element, event, options, domOperation) {
        options = options || {};
        options.domOperation = domOperation;
        return queueAnimation(element, event, options);
      },

      // this method has four signatures:
      //  () - global getter
      //  (bool) - global setter
      //  (element) - element getter
      //  (element, bool) - element setter<F37>
      enabled: function(element, bool) {
        var argCount = arguments.length;

        if (argCount === 0) {
          // () - Global getter
          bool = !!animationsEnabled;
        } else {
          var hasElement = isElement(element);

          if (!hasElement) {
            // (bool) - Global setter
            bool = animationsEnabled = !!element;
          } else {
            var node = getDomNode(element);
            var recordExists = disabledElementsLookup.get(node);

            if (argCount === 1) {
              // (element) - Element getter
              bool = !recordExists;
            } else {
              // (element, bool) - Element setter
              disabledElementsLookup.put(node, !bool);
            }
          }
        }

        return bool;
      }
    };

    return $animate;

    function queueAnimation(element, event, initialOptions) {
      // we always make a copy of the options since
      // there should never be any side effects on
      // the input data when running `$animateCss`.
      var options = copy(initialOptions);

      var node, parent;
      element = stripCommentsFromElement(element);
      if (element) {
        node = getDomNode(element);
        parent = element.parent();
      }

      options = prepareAnimationOptions(options);

      // we create a fake runner with a working promise.
      // These methods will become available after the digest has passed
      var runner = new $$AnimateRunner();

      // this is used to trigger callbacks in postDigest mode
      var runInNextPostDigestOrNow = postDigestTaskFactory();

      if (isArray(options.addClass)) {
        options.addClass = options.addClass.join(' ');
      }

      if (options.addClass && !isString(options.addClass)) {
        options.addClass = null;
      }

      if (isArray(options.removeClass)) {
        options.removeClass = options.removeClass.join(' ');
      }

      if (options.removeClass && !isString(options.removeClass)) {
        options.removeClass = null;
      }

      if (options.from && !isObject(options.from)) {
        options.from = null;
      }

      if (options.to && !isObject(options.to)) {
        options.to = null;
      }

      // there are situations where a directive issues an animation for
      // a jqLite wrapper that contains only comment nodes... If this
      // happens then there is no way we can perform an animation
      if (!node) {
        close();
        return runner;
      }

      var className = [node.className, options.addClass, options.removeClass].join(' ');
      if (!isAnimatableClassName(className)) {
        close();
        return runner;
      }

      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      var documentHidden = $document[0].hidden;

      // this is a hard disable of all animations for the application or on
      // the element itself, therefore  there is no need to continue further
      // past this point if not enabled
      // Animations are also disabled if the document is currently hidden (page is not visible
      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame
      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
      var hasExistingAnimation = !!existingAnimation.state;

      // there is no point in traversing the same collection of parent ancestors if a followup
      // animation will be run on the same element that already did all that checking work
      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
        skipAnimations = !areAnimationsAllowed(element, parent, event);
      }

      if (skipAnimations) {
        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)
        if (documentHidden) notifyProgress(runner, event, 'start');
        close();
        if (documentHidden) notifyProgress(runner, event, 'close');
        return runner;
      }

      if (isStructural) {
        closeChildAnimations(element);
      }

      var newAnimation = {
        structural: isStructural,
        element: element,
        event: event,
        addClass: options.addClass,
        removeClass: options.removeClass,
        close: close,
        options: options,
        runner: runner
      };

      if (hasExistingAnimation) {
        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
        if (skipAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            close();
            return runner;
          } else {
            mergeAnimationDetails(element, existingAnimation, newAnimation);
            return existingAnimation.runner;
          }
        }
        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
        if (cancelAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            // this will end the animation right away and it is safe
            // to do so since the animation is already running and the
            // runner callback code will run in async
            existingAnimation.runner.end();
          } else if (existingAnimation.structural) {
            // this means that the animation is queued into a digest, but
            // hasn't started yet. Therefore it is safe to run the close
            // method which will call the runner methods in async.
            existingAnimation.close();
          } else {
            // this will merge the new animation options into existing animation options
            mergeAnimationDetails(element, existingAnimation, newAnimation);

            return existingAnimation.runner;
          }
        } else {
          // a joined animation means that this animation will take over the existing one
          // so an example would involve a leave animation taking over an enter. Then when
          // the postDigest kicks in the enter will be ignored.
          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
          if (joinAnimationFlag) {
            if (existingAnimation.state === RUNNING_STATE) {
              normalizeAnimationDetails(element, newAnimation);
            } else {
              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);

              event = newAnimation.event = existingAnimation.event;
              options = mergeAnimationDetails(element, existingAnimation, newAnimation);

              //we return the same runner since only the option values of this animation will
              //be fed into the `existingAnimation`.
              return existingAnimation.runner;
            }
          }
        }
      } else {
        // normalization in this case means that it removes redundant CSS classes that
        // already exist (addClass) or do not exist (removeClass) on the element
        normalizeAnimationDetails(element, newAnimation);
      }

      // when the options are merged and cleaned up we may end up not having to do
      // an animation at all, therefore we should check this before issuing a post
      // digest callback. Structural animations will always run no matter what.
      var isValidAnimation = newAnimation.structural;
      if (!isValidAnimation) {
        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present
        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)
                            || hasAnimationClasses(newAnimation);
      }

      if (!isValidAnimation) {
        close();
        clearElementAnimationState(element);
        return runner;
      }

      // the counter keeps track of cancelled animations
      var counter = (existingAnimation.counter || 0) + 1;
      newAnimation.counter = counter;

      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);

      $rootScope.$$postDigest(function() {
        var animationDetails = activeAnimationsLookup.get(node);
        var animationCancelled = !animationDetails;
        animationDetails = animationDetails || {};

        // if addClass/removeClass is called before something like enter then the
        // registered parent element may not be present. The code below will ensure
        // that a final value for parent element is obtained
        var parentElement = element.parent() || [];

        // animate/structural/class-based animations all have requirements. Otherwise there
        // is no point in performing an animation. The parent node must also be set.
        var isValidAnimation = parentElement.length > 0
                                && (animationDetails.event === 'animate'
                                    || animationDetails.structural
                                    || hasAnimationClasses(animationDetails));

        // this means that the previous animation was cancelled
        // even if the follow-up animation is the same event
        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
          // if another animation did not take over then we need
          // to make sure that the domOperation and options are
          // handled accordingly
          if (animationCancelled) {
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
          }

          // if the event changed from something like enter to leave then we do
          // it, otherwise if it's the same then the end result will be the same too
          if (animationCancelled || (isStructural && animationDetails.event !== event)) {
            options.domOperation();
            runner.end();
          }

          // in the event that the element animation was not cancelled or a follow-up animation
          // isn't allowed to animate from here then we need to clear the state of the element
          // so that any future animations won't read the expired animation data.
          if (!isValidAnimation) {
            clearElementAnimationState(element);
          }

          return;
        }

        // this combined multiple class to addClass / removeClass into a setClass event
        // so long as a structural event did not take over the animation
        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)
            ? 'setClass'
            : animationDetails.event;

        markElementAnimationState(element, RUNNING_STATE);
        var realRunner = $$animation(element, event, animationDetails.options);

        // this will update the runner's flow-control events based on
        // the `realRunner` object.
        runner.setHost(realRunner);
        notifyProgress(runner, event, 'start', {});

        realRunner.done(function(status) {
          close(!status);
          var animationDetails = activeAnimationsLookup.get(node);
          if (animationDetails && animationDetails.counter === counter) {
            clearElementAnimationState(getDomNode(element));
          }
          notifyProgress(runner, event, 'close', {});
        });
      });

      return runner;

      function notifyProgress(runner, event, phase, data) {
        runInNextPostDigestOrNow(function() {
          var callbacks = findCallbacks(parent, element, event);
          if (callbacks.length) {
            // do not optimize this call here to RAF because
            // we don't know how heavy the callback code here will
            // be and if this code is buffered then this can
            // lead to a performance regression.
            $$rAF(function() {
              forEach(callbacks, function(callback) {
                callback(element, phase, data);
              });
              cleanupEventListeners(phase, element);
            });
          } else {
            cleanupEventListeners(phase, element);
          }
        });
        runner.progress(event, phase, data);
      }

      function close(reject) { // jshint ignore:line
        clearGeneratedClasses(element, options);
        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();
        runner.complete(!reject);
      }
    }

    function closeChildAnimations(element) {
      var node = getDomNode(element);
      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
      forEach(children, function(child) {
        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
        var animationDetails = activeAnimationsLookup.get(child);
        if (animationDetails) {
          switch (state) {
            case RUNNING_STATE:
              animationDetails.runner.end();
              /* falls through */
            case PRE_DIGEST_STATE:
              activeAnimationsLookup.remove(child);
              break;
          }
        }
      });
    }

    function clearElementAnimationState(element) {
      var node = getDomNode(element);
      node.removeAttribute(NG_ANIMATE_ATTR_NAME);
      activeAnimationsLookup.remove(node);
    }

    function isMatchingElement(nodeOrElmA, nodeOrElmB) {
      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
    }

    /**
     * This fn returns false if any of the following is true:
     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed
     * b) a parent element has an ongoing structural animation, and animateChildren is false
     * c) the element is not a child of the body
     * d) the element is not a child of the $rootElement
     */
    function areAnimationsAllowed(element, parentElement, event) {
      var bodyElement = jqLite($document[0].body);
      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
      var rootElementDetected = isMatchingElement(element, $rootElement);
      var parentAnimationDetected = false;
      var animateChildren;
      var elementDisabled = disabledElementsLookup.get(getDomNode(element));

      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
      if (parentHost) {
        parentElement = parentHost;
      }

      parentElement = getDomNode(parentElement);

      while (parentElement) {
        if (!rootElementDetected) {
          // angular doesn't want to attempt to animate elements outside of the application
          // therefore we need to ensure that the rootElement is an ancestor of the current element
          rootElementDetected = isMatchingElement(parentElement, $rootElement);
        }

        if (parentElement.nodeType !== ELEMENT_NODE) {
          // no point in inspecting the #document element
          break;
        }

        var details = activeAnimationsLookup.get(parentElement) || {};
        // either an enter, leave or move animation will commence
        // therefore we can't allow any animations to take place
        // but if a parent animation is class-based then that's ok
        if (!parentAnimationDetected) {
          var parentElementDisabled = disabledElementsLookup.get(parentElement);

          if (parentElementDisabled === true && elementDisabled !== false) {
            // disable animations if the user hasn't explicitly enabled animations on the
            // current element
            elementDisabled = true;
            // element is disabled via parent element, no need to check anything else
            break;
          } else if (parentElementDisabled === false) {
            elementDisabled = false;
          }
          parentAnimationDetected = details.structural;
        }

        if (isUndefined(animateChildren) || animateChildren === true) {
          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
          if (isDefined(value)) {
            animateChildren = value;
          }
        }

        // there is no need to continue traversing at this point
        if (parentAnimationDetected && animateChildren === false) break;

        if (!bodyElementDetected) {
          // we also need to ensure that the element is or will be a part of the body element
          // otherwise it is pointless to even issue an animation to be rendered
          bodyElementDetected = isMatchingElement(parentElement, bodyElement);
        }

        if (bodyElementDetected && rootElementDetected) {
          // If both body and root have been found, any other checks are pointless,
          // as no animation data should live outside the application
          break;
        }

        if (!rootElementDetected) {
          // If no rootElement is detected, check if the parentElement is pinned to another element
          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
          if (parentHost) {
            // The pin target element becomes the next parent element
            parentElement = getDomNode(parentHost);
            continue;
          }
        }

        parentElement = parentElement.parentNode;
      }

      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
      return allowAnimation && rootElementDetected && bodyElementDetected;
    }

    function markElementAnimationState(element, state, details) {
      details = details || {};
      details.state = state;

      var node = getDomNode(element);
      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);

      var oldValue = activeAnimationsLookup.get(node);
      var newValue = oldValue
          ? extend(oldValue, details)
          : details;
      activeAnimationsLookup.put(node, newValue);
    }
  }];
}];

var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';

  var drivers = this.drivers = [];

  var RUNNER_STORAGE_KEY = '$$animationRunner';

  function setRunner(element, runner) {
    element.data(RUNNER_STORAGE_KEY, runner);
  }

  function removeRunner(element) {
    element.removeData(RUNNER_STORAGE_KEY);
  }

  function getRunner(element) {
    return element.data(RUNNER_STORAGE_KEY);
  }

  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',
       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {

    var animationQueue = [];
    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function sortAnimations(animations) {
      var tree = { children: [] };
      var i, lookup = new $$HashMap();

      // this is done first beforehand so that the hashmap
      // is filled with a list of the elements that will be animated
      for (i = 0; i < animations.length; i++) {
        var animation = animations[i];
        lookup.put(animation.domNode, animations[i] = {
          domNode: animation.domNode,
          fn: animation.fn,
          children: []
        });
      }

      for (i = 0; i < animations.length; i++) {
        processNode(animations[i]);
      }

      return flatten(tree);

      function processNode(entry) {
        if (entry.processed) return entry;
        entry.processed = true;

        var elementNode = entry.domNode;
        var parentNode = elementNode.parentNode;
        lookup.put(elementNode, entry);

        var parentEntry;
        while (parentNode) {
          parentEntry = lookup.get(parentNode);
          if (parentEntry) {
            if (!parentEntry.processed) {
              parentEntry = processNode(parentEntry);
            }
            break;
          }
          parentNode = parentNode.parentNode;
        }

        (parentEntry || tree).children.push(entry);
        return entry;
      }

      function flatten(tree) {
        var result = [];
        var queue = [];
        var i;

        for (i = 0; i < tree.children.length; i++) {
          queue.push(tree.children[i]);
        }

        var remainingLevelEntries = queue.length;
        var nextLevelEntries = 0;
        var row = [];

        for (i = 0; i < queue.length; i++) {
          var entry = queue[i];
          if (remainingLevelEntries <= 0) {
            remainingLevelEntries = nextLevelEntries;
            nextLevelEntries = 0;
            result.push(row);
            row = [];
          }
          row.push(entry.fn);
          entry.children.forEach(function(childEntry) {
            nextLevelEntries++;
            queue.push(childEntry);
          });
          remainingLevelEntries--;
        }

        if (row.length) {
          result.push(row);
        }

        return result;
      }
    }

    // TODO(matsko): document the signature in a better way
    return function(element, event, options) {
      options = prepareAnimationOptions(options);
      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      // there is no animation at the current moment, however
      // these runner methods will get later updated with the
      // methods leading into the driver's end/cancel methods
      // for now they just stop the animation from starting
      var runner = new $$AnimateRunner({
        end: function() { close(); },
        cancel: function() { close(true); }
      });

      if (!drivers.length) {
        close();
        return runner;
      }

      setRunner(element, runner);

      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
      var tempClasses = options.tempClasses;
      if (tempClasses) {
        classes += ' ' + tempClasses;
        options.tempClasses = null;
      }

      var prepareClassName;
      if (isStructural) {
        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
        $$jqLite.addClass(element, prepareClassName);
      }

      animationQueue.push({
        // this data is used by the postDigest code and passed into
        // the driver step function
        element: element,
        classes: classes,
        event: event,
        structural: isStructural,
        options: options,
        beforeStart: beforeStart,
        close: close
      });

      element.on('$destroy', handleDestroyedElement);

      // we only want there to be one function called within the post digest
      // block. This way we can group animations for all the animations that
      // were apart of the same postDigest flush call.
      if (animationQueue.length > 1) return runner;

      $rootScope.$$postDigest(function() {
        var animations = [];
        forEach(animationQueue, function(entry) {
          // the element was destroyed early on which removed the runner
          // form its storage. This means we can't animate this element
          // at all and it already has been closed due to destruction.
          if (getRunner(entry.element)) {
            animations.push(entry);
          } else {
            entry.close();
          }
        });

        // now any future animations will be in another postDigest
        animationQueue.length = 0;

        var groupedAnimations = groupAnimations(animations);
        var toBeSortedAnimations = [];

        forEach(groupedAnimations, function(animationEntry) {
          toBeSortedAnimations.push({
            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
            fn: function triggerAnimationStart() {
              // it's important that we apply the `ng-animate` CSS class and the
              // temporary classes before we do any driver invoking since these
              // CSS classes may be required for proper CSS detection.
              animationEntry.beforeStart();

              var startAnimationFn, closeFn = animationEntry.close;

              // in the event that the element was removed before the digest runs or
              // during the RAF sequencing then we should not trigger the animation.
              var targetElement = animationEntry.anchors
                  ? (animationEntry.from.element || animationEntry.to.element)
                  : animationEntry.element;

              if (getRunner(targetElement)) {
                var operation = invokeFirstDriver(animationEntry);
                if (operation) {
                  startAnimationFn = operation.start;
                }
              }

              if (!startAnimationFn) {
                closeFn();
              } else {
                var animationRunner = startAnimationFn();
                animationRunner.done(function(status) {
                  closeFn(!status);
                });
                updateAnimationRunners(animationEntry, animationRunner);
              }
            }
          });
        });

        // we need to sort each of the animations in order of parent to child
        // relationships. This ensures that the child classes are applied at the
        // right time.
        $$rAFScheduler(sortAnimations(toBeSortedAnimations));
      });

      return runner;

      // TODO(matsko): change to reference nodes
      function getAnchorNodes(node) {
        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
              ? [node]
              : node.querySelectorAll(SELECTOR);
        var anchors = [];
        forEach(items, function(node) {
          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
          if (attr && attr.length) {
            anchors.push(node);
          }
        });
        return anchors;
      }

      function groupAnimations(animations) {
        var preparedAnimations = [];
        var refLookup = {};
        forEach(animations, function(animation, index) {
          var element = animation.element;
          var node = getDomNode(element);
          var event = animation.event;
          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];

          if (anchorNodes.length) {
            var direction = enterOrMove ? 'to' : 'from';

            forEach(anchorNodes, function(anchor) {
              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
              refLookup[key] = refLookup[key] || {};
              refLookup[key][direction] = {
                animationID: index,
                element: jqLite(anchor)
              };
            });
          } else {
            preparedAnimations.push(animation);
          }
        });

        var usedIndicesLookup = {};
        var anchorGroups = {};
        forEach(refLookup, function(operations, key) {
          var from = operations.from;
          var to = operations.to;

          if (!from || !to) {
            // only one of these is set therefore we can't have an
            // anchor animation since all three pieces are required
            var index = from ? from.animationID : to.animationID;
            var indexKey = index.toString();
            if (!usedIndicesLookup[indexKey]) {
              usedIndicesLookup[indexKey] = true;
              preparedAnimations.push(animations[index]);
            }
            return;
          }

          var fromAnimation = animations[from.animationID];
          var toAnimation = animations[to.animationID];
          var lookupKey = from.animationID.toString();
          if (!anchorGroups[lookupKey]) {
            var group = anchorGroups[lookupKey] = {
              structural: true,
              beforeStart: function() {
                fromAnimation.beforeStart();
                toAnimation.beforeStart();
              },
              close: function() {
                fromAnimation.close();
                toAnimation.close();
              },
              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
              from: fromAnimation,
              to: toAnimation,
              anchors: [] // TODO(matsko): change to reference nodes
            };

            // the anchor animations require that the from and to elements both have at least
            // one shared CSS class which effectively marries the two elements together to use
            // the same animation driver and to properly sequence the anchor animation.
            if (group.classes.length) {
              preparedAnimations.push(group);
            } else {
              preparedAnimations.push(fromAnimation);
              preparedAnimations.push(toAnimation);
            }
          }

          anchorGroups[lookupKey].anchors.push({
            'out': from.element, 'in': to.element
          });
        });

        return preparedAnimations;
      }

      function cssClassesIntersection(a,b) {
        a = a.split(' ');
        b = b.split(' ');
        var matches = [];

        for (var i = 0; i < a.length; i++) {
          var aa = a[i];
          if (aa.substring(0,3) === 'ng-') continue;

          for (var j = 0; j < b.length; j++) {
            if (aa === b[j]) {
              matches.push(aa);
              break;
            }
          }
        }

        return matches.join(' ');
      }

      function invokeFirstDriver(animationDetails) {
        // we loop in reverse order since the more general drivers (like CSS and JS)
        // may attempt more elements, but custom drivers are more particular
        for (var i = drivers.length - 1; i >= 0; i--) {
          var driverName = drivers[i];
          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check

          var factory = $injector.get(driverName);
          var driver = factory(animationDetails);
          if (driver) {
            return driver;
          }
        }
      }

      function beforeStart() {
        element.addClass(NG_ANIMATE_CLASSNAME);
        if (tempClasses) {
          $$jqLite.addClass(element, tempClasses);
        }
        if (prepareClassName) {
          $$jqLite.removeClass(element, prepareClassName);
          prepareClassName = null;
        }
      }

      function updateAnimationRunners(animation, newRunner) {
        if (animation.from && animation.to) {
          update(animation.from.element);
          update(animation.to.element);
        } else {
          update(animation.element);
        }

        function update(element) {
          getRunner(element).setHost(newRunner);
        }
      }

      function handleDestroyedElement() {
        var runner = getRunner(element);
        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
          runner.end();
        }
      }

      function close(rejected) { // jshint ignore:line
        element.off('$destroy', handleDestroyedElement);
        removeRunner(element);

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();

        if (tempClasses) {
          $$jqLite.removeClass(element, tempClasses);
        }

        element.removeClass(NG_ANIMATE_CLASSNAME);
        runner.complete(!rejected);
      }
    };
  }];
}];

/**
 * @ngdoc directive
 * @name ngAnimateSwap
 * @restrict A
 * @scope
 *
 * @description
 *
 * ngAnimateSwap is a animation-oriented directive that allows for the container to
 * be removed and entered in whenever the associated expression changes. A
 * common usecase for this directive is a rotating banner or slider component which
 * contains one image being present at a time. When the active image changes
 * then the old image will perform a `leave` animation and the new element
 * will be inserted via an `enter` animation.
 *
 * @animations
 * | Animation                        | Occurs                               |
 * |----------------------------------|--------------------------------------|
 * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |
 * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |
 *
 * @example
 * <example name="ngAnimateSwap-directive" module="ngAnimateSwapExample"
 *          deps="angular-animate.js"
 *          animations="true" fixBase="true">
 *   <file name="index.html">
 *     <div class="container" ng-controller="AppCtrl">
 *       <div ng-animate-swap="number" class="cell swap-animation" ng-class="colorClass(number)">
 *         {{ number }}
 *       </div>
 *     </div>
 *   </file>
 *   <file name="script.js">
 *     angular.module('ngAnimateSwapExample', ['ngAnimate'])
 *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {
 *         $scope.number = 0;
 *         $interval(function() {
 *           $scope.number++;
 *         }, 1000);
 *
 *         var colors = ['red','blue','green','yellow','orange'];
 *         $scope.colorClass = function(number) {
 *           return colors[number % colors.length];
 *         };
 *       }]);
 *   </file>
 *  <file name="animations.css">
 *  .container {
 *    height:250px;
 *    width:250px;
 *    position:relative;
 *    overflow:hidden;
 *    border:2px solid black;
 *  }
 *  .container .cell {
 *    font-size:150px;
 *    text-align:center;
 *    line-height:250px;
 *    position:absolute;
 *    top:0;
 *    left:0;
 *    right:0;
 *    border-bottom:2px solid black;
 *  }
 *  .swap-animation.ng-enter, .swap-animation.ng-leave {
 *    transition:0.5s linear all;
 *  }
 *  .swap-animation.ng-enter {
 *    top:-250px;
 *  }
 *  .swap-animation.ng-enter-active {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave-active {
 *    top:250px;
 *  }
 *  .red { background:red; }
 *  .green { background:green; }
 *  .blue { background:blue; }
 *  .yellow { background:yellow; }
 *  .orange { background:orange; }
 *  </file>
 * </example>
 */
var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
  return {
    restrict: 'A',
    transclude: 'element',
    terminal: true,
    priority: 600, // we use 600 here to ensure that the directive is caught before others
    link: function(scope, $element, attrs, ctrl, $transclude) {
      var previousElement, previousScope;
      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
        if (previousElement) {
          $animate.leave(previousElement);
        }
        if (previousScope) {
          previousScope.$destroy();
          previousScope = null;
        }
        if (value || value === 0) {
          previousScope = scope.$new();
          $transclude(previousScope, function(element) {
            previousElement = element;
            $animate.enter(element, null, $element);
          });
        }
      });
    }
  };
}];

/* global angularAnimateModule: true,

   ngAnimateSwapDirective,
   $$AnimateAsyncRunFactory,
   $$rAFSchedulerFactory,
   $$AnimateChildrenDirective,
   $$AnimateQueueProvider,
   $$AnimationProvider,
   $AnimateCssProvider,
   $$AnimateCssDriverProvider,
   $$AnimateJsProvider,
   $$AnimateJsDriverProvider,
*/

/**
 * @ngdoc module
 * @name ngAnimate
 * @description
 *
 * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via
 * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.
 *
 * <div doc-module-components="ngAnimate"></div>
 *
 * # Usage
 * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based
 * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For
 * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within
 * the HTML element that the animation will be triggered on.
 *
 * ## Directive Support
 * The following directives are "animation aware":
 *
 * | Directive                                                                                                | Supported Animations                                                     |
 * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
 * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |
 * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |
 * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |
 * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |
 * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |
 * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |
 * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |
 * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |
 * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |
 * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |
 *
 * (More information can be found by visiting each the documentation associated with each directive.)
 *
 * ## CSS-based Animations
 *
 * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML
 * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.
 *
 * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:
 *
 * ```html
 * <div ng-if="bool" class="fade">
 *    Fade me in out
 * </div>
 * <button ng-click="bool=true">Fade In!</button>
 * <button ng-click="bool=false">Fade Out!</button>
 * ```
 *
 * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:
 *
 * ```css
 * /&#42; The starting CSS styles for the enter animation &#42;/
 * .fade.ng-enter {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 *
 * /&#42; The finishing CSS styles for the enter animation &#42;/
 * .fade.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * ```
 *
 * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two
 * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition
 * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.
 *
 * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:
 *
 * ```css
 * /&#42; now the element will fade out before it is removed from the DOM &#42;/
 * .fade.ng-leave {
 *   transition:0.5s linear all;
 *   opacity:1;
 * }
 * .fade.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:
 *
 * ```css
 * /&#42; there is no need to define anything inside of the destination
 * CSS class since the keyframe will take charge of the animation &#42;/
 * .fade.ng-leave {
 *   animation: my_fade_animation 0.5s linear;
 *   -webkit-animation: my_fade_animation 0.5s linear;
 * }
 *
 * @keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 *
 * @-webkit-keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 * ```
 *
 * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.
 *
 * ### CSS Class-based Animations
 *
 * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different
 * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added
 * and removed.
 *
 * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:
 *
 * ```html
 * <div ng-show="bool" class="fade">
 *   Show and hide me
 * </div>
 * <button ng-click="bool=!bool">Toggle</button>
 *
 * <style>
 * .fade.ng-hide {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 * </style>
 * ```
 *
 * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since
 * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.
 *
 * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation
 * with CSS styles.
 *
 * ```html
 * <div ng-class="{on:onOff}" class="highlight">
 *   Highlight this box
 * </div>
 * <button ng-click="onOff=!onOff">Toggle</button>
 *
 * <style>
 * .highlight {
 *   transition:0.5s linear all;
 * }
 * .highlight.on-add {
 *   background:white;
 * }
 * .highlight.on {
 *   background:yellow;
 * }
 * .highlight.on-remove {
 *   background:black;
 * }
 * </style>
 * ```
 *
 * We can also make use of CSS keyframes by placing them within the CSS classes.
 *
 *
 * ### CSS Staggering Animations
 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
 * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be
 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
 *
 * ```css
 * .my-animation.ng-enter {
 *   /&#42; standard transition code &#42;/
 *   transition: 1s linear all;
 *   opacity:0;
 * }
 * .my-animation.ng-enter-stagger {
 *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
 *   transition-delay: 0.1s;
 *
 *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate
 *     to not accidentally inherit a delay property from another CSS class &#42;/
 *   transition-duration: 0s;
 * }
 * .my-animation.ng-enter.ng-enter-active {
 *   /&#42; standard transition styles &#42;/
 *   opacity:1;
 * }
 * ```
 *
 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
 * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.
 *
 * The following code will issue the **ng-leave-stagger** event on the element provided:
 *
 * ```js
 * var kids = parent.children();
 *
 * $animate.leave(kids[0]); //stagger index=0
 * $animate.leave(kids[1]); //stagger index=1
 * $animate.leave(kids[2]); //stagger index=2
 * $animate.leave(kids[3]); //stagger index=3
 * $animate.leave(kids[4]); //stagger index=4
 *
 * window.requestAnimationFrame(function() {
 *   //stagger has reset itself
 *   $animate.leave(kids[5]); //stagger index=0
 *   $animate.leave(kids[6]); //stagger index=1
 *
 *   $scope.$digest();
 * });
 * ```
 *
 * Stagger animations are currently only supported within CSS-defined animations.
 *
 * ### The `ng-animate` CSS class
 *
 * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.
 * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).
 *
 * Therefore, animations can be applied to an element using this temporary class directly via CSS.
 *
 * ```css
 * .zipper.ng-animate {
 *   transition:0.5s linear all;
 * }
 * .zipper.ng-enter {
 *   opacity:0;
 * }
 * .zipper.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * .zipper.ng-leave {
 *   opacity:1;
 * }
 * .zipper.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove
 * the CSS class once an animation has completed.)
 *
 *
 * ### The `ng-[event]-prepare` class
 *
 * This is a special class that can be used to prevent unwanted flickering / flash of content before
 * the actual animation starts. The class is added as soon as an animation is initialized, but removed
 * before the actual animation starts (after waiting for a $digest).
 * It is also only added for *structural* animations (`enter`, `move`, and `leave`).
 *
 * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`
 * into elements that have class-based animations such as `ngClass`.
 *
 * ```html
 * <div ng-class="{red: myProp}">
 *   <div ng-class="{blue: myProp}">
 *     <div class="message" ng-if="myProp"></div>
 *   </div>
 * </div>
 * ```
 *
 * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.
 * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:
 *
 * ```css
 * .message.ng-enter-prepare {
 *   opacity: 0;
 * }
 *
 * ```
 *
 * ## JavaScript-based Animations
 *
 * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared
 * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the
 * `module.animation()` module function we can register the animation.
 *
 * Let's see an example of a enter/leave animation using `ngRepeat`:
 *
 * ```html
 * <div ng-repeat="item in items" class="slide">
 *   {{ item }}
 * </div>
 * ```
 *
 * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     // make note that other events (like addClass/removeClass)
 *     // have different function input parameters
 *     enter: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *
 *       // remember to call doneFn so that angular
 *       // knows that the animation has concluded
 *     },
 *
 *     move: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *     },
 *
 *     leave: function(element, doneFn) {
 *       jQuery(element).fadeOut(1000, doneFn);
 *     }
 *   }
 * }]);
 * ```
 *
 * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as
 * greensock.js and velocity.js.
 *
 * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define
 * our animations inside of the same registered animation, however, the function input arguments are a bit different:
 *
 * ```html
 * <div ng-class="color" class="colorful">
 *   this box is moody
 * </div>
 * <button ng-click="color='red'">Change to red</button>
 * <button ng-click="color='blue'">Change to blue</button>
 * <button ng-click="color='green'">Change to green</button>
 * ```
 *
 * ```js
 * myModule.animation('.colorful', [function() {
 *   return {
 *     addClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     removeClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     setClass: function(element, addedClass, removedClass, doneFn) {
 *       // do some cool animation and call the doneFn
 *     }
 *   }
 * }]);
 * ```
 *
 * ## CSS + JS Animations Together
 *
 * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,
 * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking
 * charge of the animation**:
 *
 * ```html
 * <div ng-if="bool" class="slide">
 *   Slide in and out
 * </div>
 * ```
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     enter: function(element, doneFn) {
 *       jQuery(element).slideIn(1000, doneFn);
 *     }
 *   }
 * }]);
 * ```
 *
 * ```css
 * .slide.ng-enter {
 *   transition:0.5s linear all;
 *   transform:translateY(-100px);
 * }
 * .slide.ng-enter.ng-enter-active {
 *   transform:translateY(0);
 * }
 * ```
 *
 * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the
 * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from
 * our own JS-based animation code:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element) {
*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.
 *       return $animateCss(element, {
 *         event: 'enter',
 *         structural: true
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.
 *
 * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or
 * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that
 * data into `$animateCss` directly:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element) {
 *       return $animateCss(element, {
 *         event: 'enter',
 *         structural: true,
 *         addClass: 'maroon-setting',
 *         from: { height:0 },
 *         to: { height: 200 }
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * Now we can fill in the rest via our transition CSS code:
 *
 * ```css
 * /&#42; the transition tells ngAnimate to make the animation happen &#42;/
 * .slide.ng-enter { transition:0.5s linear all; }
 *
 * /&#42; this extra CSS class will be absorbed into the transition
 * since the $animateCss code is adding the class &#42;/
 * .maroon-setting { background:red; }
 * ```
 *
 * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.
 *
 * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.
 *
 * ## Animation Anchoring (via `ng-animate-ref`)
 *
 * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between
 * structural areas of an application (like views) by pairing up elements using an attribute
 * called `ng-animate-ref`.
 *
 * Let's say for example we have two views that are managed by `ng-view` and we want to show
 * that there is a relationship between two components situated in within these views. By using the
 * `ng-animate-ref` attribute we can identify that the two components are paired together and we
 * can then attach an animation, which is triggered when the view changes.
 *
 * Say for example we have the following template code:
 *
 * ```html
 * <!-- index.html -->
 * <div ng-view class="view-animation">
 * </div>
 *
 * <!-- home.html -->
 * <a href="#/banner-page">
 *   <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * </a>
 *
 * <!-- banner-page.html -->
 * <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * ```
 *
 * Now, when the view changes (once the link is clicked), ngAnimate will examine the
 * HTML contents to see if there is a match reference between any components in the view
 * that is leaving and the view that is entering. It will scan both the view which is being
 * removed (leave) and inserted (enter) to see if there are any paired DOM elements that
 * contain a matching ref value.
 *
 * The two images match since they share the same ref value. ngAnimate will now create a
 * transport element (which is a clone of the first image element) and it will then attempt
 * to animate to the position of the second image element in the next view. For the animation to
 * work a special CSS class called `ng-anchor` will be added to the transported element.
 *
 * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then
 * ngAnimate will handle the entire transition for us as well as the addition and removal of
 * any changes of CSS classes between the elements:
 *
 * ```css
 * .banner.ng-anchor {
 *   /&#42; this animation will last for 1 second since there are
 *          two phases to the animation (an `in` and an `out` phase) &#42;/
 *   transition:0.5s linear all;
 * }
 * ```
 *
 * We also **must** include animations for the views that are being entered and removed
 * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).
 *
 * ```css
 * .view-animation.ng-enter, .view-animation.ng-leave {
 *   transition:0.5s linear all;
 *   position:fixed;
 *   left:0;
 *   top:0;
 *   width:100%;
 * }
 * .view-animation.ng-enter {
 *   transform:translateX(100%);
 * }
 * .view-animation.ng-leave,
 * .view-animation.ng-enter.ng-enter-active {
 *   transform:translateX(0%);
 * }
 * .view-animation.ng-leave.ng-leave-active {
 *   transform:translateX(-100%);
 * }
 * ```
 *
 * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:
 * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away
 * from its origin. Once that animation is over then the `in` stage occurs which animates the
 * element to its destination. The reason why there are two animations is to give enough time
 * for the enter animation on the new element to be ready.
 *
 * The example above sets up a transition for both the in and out phases, but we can also target the out or
 * in phases directly via `ng-anchor-out` and `ng-anchor-in`.
 *
 * ```css
 * .banner.ng-anchor-out {
 *   transition: 0.5s linear all;
 *
 *   /&#42; the scale will be applied during the out animation,
 *          but will be animated away when the in animation runs &#42;/
 *   transform: scale(1.2);
 * }
 *
 * .banner.ng-anchor-in {
 *   transition: 1s linear all;
 * }
 * ```
 *
 *
 *
 *
 * ### Anchoring Demo
 *
  <example module="anchoringExample"
           name="anchoringExample"
           id="anchoringExample"
           deps="angular-animate.js;angular-route.js"
           animations="true">
    <file name="index.html">
      <a href="#/">Home</a>
      <hr />
      <div class="view-container">
        <div ng-view class="view"></div>
      </div>
    </file>
    <file name="script.js">
      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])
        .config(['$routeProvider', function($routeProvider) {
          $routeProvider.when('/', {
            templateUrl: 'home.html',
            controller: 'HomeController as home'
          });
          $routeProvider.when('/profile/:id', {
            templateUrl: 'profile.html',
            controller: 'ProfileController as profile'
          });
        }])
        .run(['$rootScope', function($rootScope) {
          $rootScope.records = [
            { id:1, title: "Miss Beulah Roob" },
            { id:2, title: "Trent Morissette" },
            { id:3, title: "Miss Ava Pouros" },
            { id:4, title: "Rod Pouros" },
            { id:5, title: "Abdul Rice" },
            { id:6, title: "Laurie Rutherford Sr." },
            { id:7, title: "Nakia McLaughlin" },
            { id:8, title: "Jordon Blanda DVM" },
            { id:9, title: "Rhoda Hand" },
            { id:10, title: "Alexandrea Sauer" }
          ];
        }])
        .controller('HomeController', [function() {
          //empty
        }])
        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {
          var index = parseInt($routeParams.id, 10);
          var record = $rootScope.records[index - 1];

          this.title = record.title;
          this.id = record.id;
        }]);
    </file>
    <file name="home.html">
      <h2>Welcome to the home page</h1>
      <p>Please click on an element</p>
      <a class="record"
         ng-href="#/profile/{{ record.id }}"
         ng-animate-ref="{{ record.id }}"
         ng-repeat="record in records">
        {{ record.title }}
      </a>
    </file>
    <file name="profile.html">
      <div class="profile record" ng-animate-ref="{{ profile.id }}">
        {{ profile.title }}
      </div>
    </file>
    <file name="animations.css">
      .record {
        display:block;
        font-size:20px;
      }
      .profile {
        background:black;
        color:white;
        font-size:100px;
      }
      .view-container {
        position:relative;
      }
      .view-container > .view.ng-animate {
        position:absolute;
        top:0;
        left:0;
        width:100%;
        min-height:500px;
      }
      .view.ng-enter, .view.ng-leave,
      .record.ng-anchor {
        transition:0.5s linear all;
      }
      .view.ng-enter {
        transform:translateX(100%);
      }
      .view.ng-enter.ng-enter-active, .view.ng-leave {
        transform:translateX(0%);
      }
      .view.ng-leave.ng-leave-active {
        transform:translateX(-100%);
      }
      .record.ng-anchor-out {
        background:red;
      }
    </file>
  </example>
 *
 * ### How is the element transported?
 *
 * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting
 * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element
 * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The
 * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match
 * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied
 * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class
 * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element
 * will become visible since the shim class will be removed.
 *
 * ### How is the morphing handled?
 *
 * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out
 * what CSS classes differ between the starting element and the destination element. These different CSS classes
 * will be added/removed on the anchor element and a transition will be applied (the transition that is provided
 * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will
 * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that
 * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since
 * the cloned element is placed inside of root element which is likely close to the body element).
 *
 * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.
 *
 *
 * ## Using $animate in your directive code
 *
 * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?
 * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's
 * imagine we have a greeting box that shows and hides itself when the data changes
 *
 * ```html
 * <greeting-box active="onOrOff">Hi there</greeting-box>
 * ```
 *
 * ```js
 * ngModule.directive('greetingBox', ['$animate', function($animate) {
 *   return function(scope, element, attrs) {
 *     attrs.$observe('active', function(value) {
 *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');
 *     });
 *   });
 * }]);
 * ```
 *
 * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element
 * in our HTML code then we can trigger a CSS or JS animation to happen.
 *
 * ```css
 * /&#42; normally we would create a CSS class to reference on the element &#42;/
 * greeting-box.on { transition:0.5s linear all; background:green; color:white; }
 * ```
 *
 * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's
 * possible be sure to visit the {@link ng.$animate $animate service API page}.
 *
 *
 * ## Callbacks and Promises
 *
 * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger
 * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has
 * ended by chaining onto the returned promise that animation method returns.
 *
 * ```js
 * // somewhere within the depths of the directive
 * $animate.enter(element, parent).then(function() {
 *   //the animation has completed
 * });
 * ```
 *
 * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case
 * anymore.)
 *
 * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering
 * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view
 * routing controller to hook into that:
 *
 * ```js
 * ngModule.controller('HomePageController', ['$animate', function($animate) {
 *   $animate.on('enter', ngViewElement, function(element) {
 *     // the animation for this route has completed
 *   }]);
 * }])
 * ```
 *
 * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)
 */

/**
 * @ngdoc service
 * @name $animate
 * @kind object
 *
 * @description
 * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.
 *
 * Click here {@link ng.$animate to learn more about animations with `$animate`}.
 */
angular.module('ngAnimate', [])
  .directive('ngAnimateSwap', ngAnimateSwapDirective)

  .directive('ngAnimateChildren', $$AnimateChildrenDirective)
  .factory('$$rAFScheduler', $$rAFSchedulerFactory)

  .provider('$$animateQueue', $$AnimateQueueProvider)
  .provider('$$animation', $$AnimationProvider)

  .provider('$animateCss', $AnimateCssProvider)
  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)

  .provider('$$animateJs', $$AnimateJsProvider)
  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);


})(window, window.angular);

/**
 * @license AngularJS v1.5.5
 * (c) 2010-2016 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *     Any commits to this file should be reviewed with security in mind.  *
 *   Changes to this file can potentially create security vulnerabilities. *
 *          An approval from 2 Core members with history of modifying      *
 *                         this file is required.                          *
 *                                                                         *
 *  Does the change somehow allow for arbitrary javascript to be executed? *
 *    Or allows for someone to change the prototype of built-in objects?   *
 *     Or gives undesired access to variables likes document or window?    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

var $sanitizeMinErr = angular.$$minErr('$sanitize');

/**
 * @ngdoc module
 * @name ngSanitize
 * @description
 *
 * # ngSanitize
 *
 * The `ngSanitize` module provides functionality to sanitize HTML.
 *
 *
 * <div doc-module-components="ngSanitize"></div>
 *
 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
 */

/**
 * @ngdoc service
 * @name $sanitize
 * @kind function
 *
 * @description
 *   Sanitizes an html string by stripping all potentially dangerous tokens.
 *
 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
 *   then serialized back to properly escaped html string. This means that no unsafe input can make
 *   it into the returned string.
 *
 *   The whitelist for URL sanitization of attribute values is configured using the functions
 *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider
 *   `$compileProvider`}.
 *
 *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.
 *
 * @param {string} html HTML input.
 * @returns {string} Sanitized HTML.
 *
 * @example
   <example module="sanitizeExample" deps="angular-sanitize.js">
   <file name="index.html">
     <script>
         angular.module('sanitizeExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
             $scope.snippet =
               '<p style="color:blue">an html\n' +
               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
               'snippet</p>';
             $scope.deliberatelyTrustDangerousSnippet = function() {
               return $sce.trustAsHtml($scope.snippet);
             };
           }]);
     </script>
     <div ng-controller="ExampleController">
        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Directive</td>
           <td>How</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="bind-html-with-sanitize">
           <td>ng-bind-html</td>
           <td>Automatically uses $sanitize</td>
           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind-html="snippet"></div></td>
         </tr>
         <tr id="bind-html-with-trust">
           <td>ng-bind-html</td>
           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
           <td>
           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
&lt;/div&gt;</pre>
           </td>
           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
         </tr>
         <tr id="bind-default">
           <td>ng-bind</td>
           <td>Automatically escapes</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
       </div>
   </file>
   <file name="protractor.js" type="protractor">
     it('should sanitize the html snippet by default', function() {
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
     });

     it('should inline raw snippet if bound to a trusted value', function() {
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
         toBe("<p style=\"color:blue\">an html\n" +
              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
              "snippet</p>");
     });

     it('should escape snippet without any filter', function() {
       expect(element(by.css('#bind-default div')).getInnerHtml()).
         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
              "snippet&lt;/p&gt;");
     });

     it('should update', function() {
       element(by.model('snippet')).clear();
       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('new <b>text</b>');
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
         'new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
     });
   </file>
   </example>
 */


/**
 * @ngdoc provider
 * @name $sanitizeProvider
 *
 * @description
 * Creates and configures {@link $sanitize} instance.
 */
function $SanitizeProvider() {
  var svgEnabled = false;

  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
    if (svgEnabled) {
      angular.extend(validElements, svgElements);
    }
    return function(html) {
      var buf = [];
      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
      }));
      return buf.join('');
    };
  }];


  /**
   * @ngdoc method
   * @name $sanitizeProvider#enableSvg
   * @kind function
   *
   * @description
   * Enables a subset of svg to be supported by the sanitizer.
   *
   * <div class="alert alert-warning">
   *   <p>By enabling this setting without taking other precautions, you might expose your
   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned
   *   outside of the containing element and be rendered over other elements on the page (e.g. a login
   *   link). Such behavior can then result in phishing incidents.</p>
   *
   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg
   *   tags within the sanitized content:</p>
   *
   *   <br>
   *
   *   <pre><code>
   *   .rootOfTheIncludedContent svg {
   *     overflow: hidden !important;
   *   }
   *   </code></pre>
   * </div>
   *
   * @param {boolean=} regexp New regexp to whitelist urls with.
   * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called
   *    without an argument or self for chaining otherwise.
   */
  this.enableSvg = function(enableSvg) {
    if (angular.isDefined(enableSvg)) {
      svgEnabled = enableSvg;
      return this;
    } else {
      return svgEnabled;
    }
  };
}

function sanitizeText(chars) {
  var buf = [];
  var writer = htmlSanitizeWriter(buf, angular.noop);
  writer.chars(chars);
  return buf.join('');
}


// Regular Expressions for parsing tags and attributes
var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  // Match everything outside of normal chars and " (quote character)
  NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;


// Good source of info about elements and attributes
// http://dev.w3.org/html5/spec/Overview.html#semantics
// http://simon.html5.org/html-elements

// Safe Void Elements - HTML5
// http://dev.w3.org/html5/spec/Overview.html#void-elements
var voidElements = toMap("area,br,col,hr,img,wbr");

// Elements that you can, intentionally, leave open (and which close themselves)
// http://dev.w3.org/html5/spec/Overview.html#optional-tags
var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
    optionalEndTagInlineElements = toMap("rp,rt"),
    optionalEndTagElements = angular.extend({},
                                            optionalEndTagInlineElements,
                                            optionalEndTagBlockElements);

// Safe Block Elements - HTML5
var blockElements = angular.extend({}, optionalEndTagBlockElements, toMap("address,article," +
        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));

// Inline Elements - HTML5
var inlineElements = angular.extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," +
        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));

// SVG Elements
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
// They can potentially allow for arbitrary javascript to be executed. See #11290
var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
        "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
        "radialGradient,rect,stop,svg,switch,text,title,tspan");

// Blocked Elements (will be stripped)
var blockedElements = toMap("script,style");

var validElements = angular.extend({},
                                   voidElements,
                                   blockElements,
                                   inlineElements,
                                   optionalEndTagElements);

//Attributes that have href and hence need to be sanitized
var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");

var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
    'valign,value,vspace,width');

// SVG attributes (without "id" and "name" attributes)
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);

var validAttrs = angular.extend({},
                                uriAttrs,
                                svgAttrs,
                                htmlAttrs);

function toMap(str, lowercaseKeys) {
  var obj = {}, items = str.split(','), i;
  for (i = 0; i < items.length; i++) {
    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
  }
  return obj;
}

var inertBodyElement;
(function(window) {
  var doc;
  if (window.document && window.document.implementation) {
    doc = window.document.implementation.createHTMLDocument("inert");
  } else {
    throw $sanitizeMinErr('noinert', "Can't create an inert html document");
  }
  var docElement = doc.documentElement || doc.getDocumentElement();
  var bodyElements = docElement.getElementsByTagName('body');

  // usually there should be only one body element in the document, but IE doesn't have any, so we need to create one
  if (bodyElements.length === 1) {
    inertBodyElement = bodyElements[0];
  } else {
    var html = doc.createElement('html');
    inertBodyElement = doc.createElement('body');
    html.appendChild(inertBodyElement);
    doc.appendChild(html);
  }
})(window);

/**
 * @example
 * htmlParser(htmlString, {
 *     start: function(tag, attrs) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 * @param {string} html string
 * @param {object} handler
 */
function htmlParser(html, handler) {
  if (html === null || html === undefined) {
    html = '';
  } else if (typeof html !== 'string') {
    html = '' + html;
  }
  inertBodyElement.innerHTML = html;

  //mXSS protection
  var mXSSAttempts = 5;
  do {
    if (mXSSAttempts === 0) {
      throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
    }
    mXSSAttempts--;

    // strip custom-namespaced attributes on IE<=11
    if (window.document.documentMode) {
      stripCustomNsAttrs(inertBodyElement);
    }
    html = inertBodyElement.innerHTML; //trigger mXSS
    inertBodyElement.innerHTML = html;
  } while (html !== inertBodyElement.innerHTML);

  var node = inertBodyElement.firstChild;
  while (node) {
    switch (node.nodeType) {
      case 1: // ELEMENT_NODE
        handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
        break;
      case 3: // TEXT NODE
        handler.chars(node.textContent);
        break;
    }

    var nextNode;
    if (!(nextNode = node.firstChild)) {
      if (node.nodeType == 1) {
        handler.end(node.nodeName.toLowerCase());
      }
      nextNode = node.nextSibling;
      if (!nextNode) {
        while (nextNode == null) {
          node = node.parentNode;
          if (node === inertBodyElement) break;
          nextNode = node.nextSibling;
          if (node.nodeType == 1) {
            handler.end(node.nodeName.toLowerCase());
          }
        }
      }
    }
    node = nextNode;
  }

  while (node = inertBodyElement.firstChild) {
    inertBodyElement.removeChild(node);
  }
}

function attrToMap(attrs) {
  var map = {};
  for (var i = 0, ii = attrs.length; i < ii; i++) {
    var attr = attrs[i];
    map[attr.name] = attr.value;
  }
  return map;
}


/**
 * Escapes all potentially dangerous characters, so that the
 * resulting string can be safely inserted into attribute or
 * element text.
 * @param value
 * @returns {string} escaped text
 */
function encodeEntities(value) {
  return value.
    replace(/&/g, '&amp;').
    replace(SURROGATE_PAIR_REGEXP, function(value) {
      var hi = value.charCodeAt(0);
      var low = value.charCodeAt(1);
      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
    }).
    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
      return '&#' + value.charCodeAt(0) + ';';
    }).
    replace(/</g, '&lt;').
    replace(/>/g, '&gt;');
}

/**
 * create an HTML/XML writer which writes to buffer
 * @param {Array} buf use buf.join('') to get out sanitized html string
 * @returns {object} in the form of {
 *     start: function(tag, attrs) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * }
 */
function htmlSanitizeWriter(buf, uriValidator) {
  var ignoreCurrentElement = false;
  var out = angular.bind(buf, buf.push);
  return {
    start: function(tag, attrs) {
      tag = angular.lowercase(tag);
      if (!ignoreCurrentElement && blockedElements[tag]) {
        ignoreCurrentElement = tag;
      }
      if (!ignoreCurrentElement && validElements[tag] === true) {
        out('<');
        out(tag);
        angular.forEach(attrs, function(value, key) {
          var lkey=angular.lowercase(key);
          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
          if (validAttrs[lkey] === true &&
            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
            out(' ');
            out(key);
            out('="');
            out(encodeEntities(value));
            out('"');
          }
        });
        out('>');
      }
    },
    end: function(tag) {
      tag = angular.lowercase(tag);
      if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
        out('</');
        out(tag);
        out('>');
      }
      if (tag == ignoreCurrentElement) {
        ignoreCurrentElement = false;
      }
    },
    chars: function(chars) {
      if (!ignoreCurrentElement) {
        out(encodeEntities(chars));
      }
    }
  };
}


/**
 * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare
 * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want
 * to allow any of these custom attributes. This method strips them all.
 *
 * @param node Root element to process
 */
function stripCustomNsAttrs(node) {
  if (node.nodeType === window.Node.ELEMENT_NODE) {
    var attrs = node.attributes;
    for (var i = 0, l = attrs.length; i < l; i++) {
      var attrNode = attrs[i];
      var attrName = attrNode.name.toLowerCase();
      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
        node.removeAttributeNode(attrNode);
        i--;
        l--;
      }
    }
  }

  var nextNode = node.firstChild;
  if (nextNode) {
    stripCustomNsAttrs(nextNode);
  }

  nextNode = node.nextSibling;
  if (nextNode) {
    stripCustomNsAttrs(nextNode);
  }
}



// define ngSanitize module and register $sanitize service
angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);

/* global sanitizeText: false */

/**
 * @ngdoc filter
 * @name linky
 * @kind function
 *
 * @description
 * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and
 * plain email address links.
 *
 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
 *
 * @param {string} text Input text.
 * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.
 * @param {object|function(url)} [attributes] Add custom attributes to the link element.
 *
 *    Can be one of:
 *
 *    - `object`: A map of attributes
 *    - `function`: Takes the url as a parameter and returns a map of attributes
 *
 *    If the map of attributes contains a value for `target`, it overrides the value of
 *    the target parameter.
 *
 *
 * @returns {string} Html-linkified and {@link $sanitize sanitized} text.
 *
 * @usage
   <span ng-bind-html="linky_expression | linky"></span>
 *
 * @example
   <example module="linkyExample" deps="angular-sanitize.js">
     <file name="index.html">
       <div ng-controller="ExampleController">
       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <th>Filter</th>
           <th>Source</th>
           <th>Rendered</th>
         </tr>
         <tr id="linky-filter">
           <td>linky filter</td>
           <td>
             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
           </td>
           <td>
             <div ng-bind-html="snippet | linky"></div>
           </td>
         </tr>
         <tr id="linky-target">
          <td>linky target</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithSingleURL | linky:'_blank'"></div>
          </td>
         </tr>
         <tr id="linky-custom-attributes">
          <td>linky custom attributes</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"></div>
          </td>
         </tr>
         <tr id="escaped-html">
           <td>no filter</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
     </file>
     <file name="script.js">
       angular.module('linkyExample', ['ngSanitize'])
         .controller('ExampleController', ['$scope', function($scope) {
           $scope.snippet =
             'Pretty text with some links:\n'+
             'http://angularjs.org/,\n'+
             'mailto:us@somewhere.org,\n'+
             'another@somewhere.org,\n'+
             'and one more: ftp://127.0.0.1/.';
           $scope.snippetWithSingleURL = 'http://angularjs.org/';
         }]);
     </file>
     <file name="protractor.js" type="protractor">
       it('should linkify the snippet with urls', function() {
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
       });

       it('should not linkify snippet without the linky filter', function() {
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
       });

       it('should update', function() {
         element(by.model('snippet')).clear();
         element(by.model('snippet')).sendKeys('new http://link.');
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('new http://link.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
             .toBe('new http://link.');
       });

       it('should work with the target property', function() {
        expect(element(by.id('linky-target')).
            element(by.binding("snippetWithSingleURL | linky:'_blank'")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
       });

       it('should optionally add custom attributes', function() {
        expect(element(by.id('linky-custom-attributes')).
            element(by.binding("snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');
       });
     </file>
   </example>
 */
angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
  var LINKY_URL_REGEXP =
        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
      MAILTO_REGEXP = /^mailto:/i;

  var linkyMinErr = angular.$$minErr('linky');
  var isString = angular.isString;

  return function(text, target, attributes) {
    if (text == null || text === '') return text;
    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);

    var match;
    var raw = text;
    var html = [];
    var url;
    var i;
    while ((match = raw.match(LINKY_URL_REGEXP))) {
      // We can not end in these as they are sometimes found at the end of the sentence
      url = match[0];
      // if we did not match ftp/http/www/mailto then assume mailto
      if (!match[2] && !match[4]) {
        url = (match[3] ? 'http://' : 'mailto:') + url;
      }
      i = match.index;
      addText(raw.substr(0, i));
      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
      raw = raw.substring(i + match[0].length);
    }
    addText(raw);
    return $sanitize(html.join(''));

    function addText(text) {
      if (!text) {
        return;
      }
      html.push(sanitizeText(text));
    }

    function addLink(url, text) {
      var key;
      html.push('<a ');
      if (angular.isFunction(attributes)) {
        attributes = attributes(url);
      }
      if (angular.isObject(attributes)) {
        for (key in attributes) {
          html.push(key + '="' + attributes[key] + '" ');
        }
      } else {
        attributes = {};
      }
      if (angular.isDefined(target) && !('target' in attributes)) {
        html.push('target="',
                  target,
                  '" ');
      }
      html.push('href="',
                url.replace(/"/g, '&quot;'),
                '">');
      addText(text);
      html.push('</a>');
    }
  };
}]);


})(window, window.angular);

/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 2.5.0 - 2017-01-28
 * License: MIT
 */angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.tabindex","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.isClass","ui.bootstrap.datepicker","ui.bootstrap.position","ui.bootstrap.datepickerPopup","ui.bootstrap.debounce","ui.bootstrap.multiMap","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.paging","ui.bootstrap.pager","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html","uib/template/accordion/accordion.html","uib/template/alert/alert.html","uib/template/carousel/carousel.html","uib/template/carousel/slide.html","uib/template/datepicker/datepicker.html","uib/template/datepicker/day.html","uib/template/datepicker/month.html","uib/template/datepicker/year.html","uib/template/datepickerPopup/popup.html","uib/template/modal/window.html","uib/template/pager/pager.html","uib/template/pagination/pagination.html","uib/template/tooltip/tooltip-html-popup.html","uib/template/tooltip/tooltip-popup.html","uib/template/tooltip/tooltip-template-popup.html","uib/template/popover/popover-html.html","uib/template/popover/popover-template.html","uib/template/popover/popover.html","uib/template/progressbar/bar.html","uib/template/progressbar/progress.html","uib/template/progressbar/progressbar.html","uib/template/rating/rating.html","uib/template/tabs/tab.html","uib/template/tabs/tabset.html","uib/template/timepicker/timepicker.html","uib/template/typeahead/typeahead-match.html","uib/template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])

  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        var expandingExpr = $parse(attrs.expanding),
          expandedExpr = $parse(attrs.expanded),
          collapsingExpr = $parse(attrs.collapsing),
          collapsedExpr = $parse(attrs.collapsed),
          horizontal = false,
          css = {},
          cssTo = {};

        init();

        function init() {
          horizontal = !!('horizontal' in attrs);
          if (horizontal) {
            css = {
              width: ''
            };
            cssTo = {width: '0'};
          } else {
            css = {
              height: ''
            };
            cssTo = {height: '0'};
          }
          if (!scope.$eval(attrs.uibCollapse)) {
            element.addClass('in')
              .addClass('collapse')
              .attr('aria-expanded', true)
              .attr('aria-hidden', false)
              .css(css);
          }
        }

        function getScrollFromElement(element) {
          if (horizontal) {
            return {width: element.scrollWidth + 'px'};
          }
          return {height: element.scrollHeight + 'px'};
        }

        function expand() {
          if (element.hasClass('collapse') && element.hasClass('in')) {
            return;
          }

          $q.resolve(expandingExpr(scope))
            .then(function() {
              element.removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', true)
                .attr('aria-hidden', false);

              if ($animateCss) {
                $animateCss(element, {
                  addClass: 'in',
                  easing: 'ease',
                  css: {
                    overflow: 'hidden'
                  },
                  to: getScrollFromElement(element[0])
                }).start()['finally'](expandDone);
              } else {
                $animate.addClass(element, 'in', {
                  css: {
                    overflow: 'hidden'
                  },
                  to: getScrollFromElement(element[0])
                }).then(expandDone);
              }
            }, angular.noop);
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse')
            .css(css);
          expandedExpr(scope);
        }

        function collapse() {
          if (!element.hasClass('collapse') && !element.hasClass('in')) {
            return collapseDone();
          }

          $q.resolve(collapsingExpr(scope))
            .then(function() {
              element
              // IMPORTANT: The width must be set before adding "collapsing" class.
              // Otherwise, the browser attempts to animate from width 0 (in
              // collapsing class) to the given width here.
                .css(getScrollFromElement(element[0]))
                // initially all panel collapse have the collapse class, this removal
                // prevents the animation from jumping to collapsed state
                .removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', false)
                .attr('aria-hidden', true);

              if ($animateCss) {
                $animateCss(element, {
                  removeClass: 'in',
                  to: cssTo
                }).start()['finally'](collapseDone);
              } else {
                $animate.removeClass(element, 'in', {
                  to: cssTo
                }).then(collapseDone);
              }
            }, angular.noop);
        }

        function collapseDone() {
          element.css(cssTo); // Required so that collapse works when animation is disabled
          element.removeClass('collapsing')
            .addClass('collapse');
          collapsedExpr(scope);
        }

        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module('ui.bootstrap.tabindex', [])

.directive('uibTabindexToggle', function() {
  return {
    restrict: 'A',
    link: function(scope, elem, attrs) {
      attrs.$observe('disabled', function(disabled) {
        attrs.$set('tabindex', disabled ? -1 : null);
      });
    }
  };
});

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex'])

.constant('uibAccordionConfig', {
  closeOthers: true
})

.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ?
      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if (closeOthers) {
      angular.forEach(this.groups, function(group) {
        if (group !== openGroup) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function(event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if (index !== -1) {
      this.groups.splice(index, 1);
    }
  };
}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('uibAccordion', function() {
  return {
    controller: 'UibAccordionController',
    controllerAs: 'accordion',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/accordion/accordion.html';
    }
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('uibAccordionGroup', function() {
  return {
    require: '^uibAccordion',         // We need this directive to be inside an accordion
    transclude: true,              // It transcludes the contents of the directive into the template
    restrict: 'A',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
    },
    scope: {
      heading: '@',               // Interpolate the heading attribute onto this scope
      panelClass: '@?',           // Ditto with panelClass
      isOpen: '=?',
      isDisabled: '=?'
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      element.addClass('panel');
      accordionCtrl.addGroup(scope);

      scope.openClass = attrs.openClass || 'panel-open';
      scope.panelClass = attrs.panelClass || 'panel-default';
      scope.$watch('isOpen', function(value) {
        element.toggleClass(scope.openClass, !!value);
        if (value) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function($event) {
        if (!scope.isDisabled) {
          if (!$event || $event.which === 32) {
            scope.isOpen = !scope.isOpen;
          }
        }
      };

      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      scope.headingId = id + '-tab';
      scope.panelId = id + '-panel';
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
.directive('uibAccordionHeading', function() {
  return {
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
.directive('uibAccordionTransclude', function() {
  return {
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, controller) {
      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {
        if (heading) {
          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
          elem.html('');
          elem.append(heading);
        }
      });
    }
  };

  function getHeaderSelectors() {
      return 'uib-accordion-header,' +
          'data-uib-accordion-header,' +
          'x-uib-accordion-header,' +
          'uib\\:accordion-header,' +
          '[uib-accordion-header],' +
          '[data-uib-accordion-header],' +
          '[x-uib-accordion-header]';
  }
});

angular.module('ui.bootstrap.alert', [])

.controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function($scope, $element, $attrs, $interpolate, $timeout) {
  $scope.closeable = !!$attrs.close;
  $element.addClass('alert');
  $attrs.$set('role', 'alert');
  if ($scope.closeable) {
    $element.addClass('alert-dismissible');
  }

  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

  if (dismissOnTimeout) {
    $timeout(function() {
      $scope.close();
    }, parseInt(dismissOnTimeout, 10));
  }
}])

.directive('uibAlert', function() {
  return {
    controller: 'UibAlertController',
    controllerAs: 'alert',
    restrict: 'A',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/alert/alert.html';
    },
    transclude: true,
    scope: {
      close: '&'
    }
  };
});

angular.module('ui.bootstrap.buttons', [])

.constant('uibButtonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('uibBtnRadio', ['$parse', function($parse) {
  return {
    require: ['uibBtnRadio', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'buttons',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      var uncheckableExpr = $parse(attrs.uibUncheckable);

      element.find('input').css({display: 'none'});

      //model -> UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
      };

      //ui->model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
            ngModelCtrl.$render();
          });
        }
      });

      if (attrs.uibUncheckable) {
        scope.$watch(uncheckableExpr, function(uncheckable) {
          attrs.$set('uncheckable', uncheckable ? '' : undefined);
        });
      }
    }
  };
}])

.directive('uibBtnCheckbox', function() {
  return {
    require: ['uibBtnCheckbox', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'button',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find('input').css({display: 'none'});

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attribute, defaultValue) {
        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
      }

      //model -> UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        scope.$apply(function() {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

angular.module('ui.bootstrap.carousel', [])

.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    SLIDE_DIRECTION = 'uib-slideDirection',
    currentIndex = $scope.active,
    currentInterval, isPlaying;

  var destroyed = false;
  $element.addClass('carousel');

  self.addSlide = function(slide, element) {
    slides.push({
      slide: slide,
      element: element
    });
    slides.sort(function(a, b) {
      return +a.slide.index - +b.slide.index;
    });
    //if this is the first slide or the slide is set to active, select it
    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
      if ($scope.$currentTransition) {
        $scope.$currentTransition = null;
      }

      currentIndex = slide.index;
      $scope.active = slide.index;
      setActive(currentIndex);
      self.select(slides[findSlideIndex(slide)]);
      if (slides.length === 1) {
        $scope.play();
      }
    }
  };

  self.getCurrentIndex = function() {
    for (var i = 0; i < slides.length; i++) {
      if (slides[i].slide.index === currentIndex) {
        return i;
      }
    }
  };

  self.next = $scope.next = function() {
    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

    if (newIndex === 0 && $scope.noWrap()) {
      $scope.pause();
      return;
    }

    return self.select(slides[newIndex], 'next');
  };

  self.prev = $scope.prev = function() {
    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

    if ($scope.noWrap() && newIndex === slides.length - 1) {
      $scope.pause();
      return;
    }

    return self.select(slides[newIndex], 'prev');
  };

  self.removeSlide = function(slide) {
    var index = findSlideIndex(slide);

    //get the index of the slide inside the carousel
    slides.splice(index, 1);
    if (slides.length > 0 && currentIndex === index) {
      if (index >= slides.length) {
        currentIndex = slides.length - 1;
        $scope.active = currentIndex;
        setActive(currentIndex);
        self.select(slides[slides.length - 1]);
      } else {
        currentIndex = index;
        $scope.active = currentIndex;
        setActive(currentIndex);
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
      $scope.active = currentIndex;
    }

    //clean the active value when no more slide
    if (slides.length === 0) {
      currentIndex = null;
      $scope.active = null;
    }
  };

  /* direction: "prev" or "next" */
  self.select = $scope.select = function(nextSlide, direction) {
    var nextIndex = findSlideIndex(nextSlide.slide);
    //Decide direction if it's not given
    if (direction === undefined) {
      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
    }
    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (nextSlide.slide.index !== currentIndex &&
      !$scope.$currentTransition) {
      goNext(nextSlide.slide, nextIndex, direction);
    }
  };

  /* Allow outside people to call indexOf on slides array */
  $scope.indexOfSlide = function(slide) {
    return +slide.slide.index;
  };

  $scope.isActive = function(slide) {
    return $scope.active === slide.slide.index;
  };

  $scope.isPrevDisabled = function() {
    return $scope.active === 0 && $scope.noWrap();
  };

  $scope.isNextDisabled = function() {
    return $scope.active === slides.length - 1 && $scope.noWrap();
  };

  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      resetTimer();
    }
  };

  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };

  $element.on('mouseenter', $scope.pause);
  $element.on('mouseleave', $scope.play);

  $scope.$on('$destroy', function() {
    destroyed = true;
    resetTimer();
  });

  $scope.$watch('noTransition', function(noTransition) {
    $animate.enabled($element, !noTransition);
  });

  $scope.$watch('interval', restartTimer);

  $scope.$watchCollection('slides', resetTransition);

  $scope.$watch('active', function(index) {
    if (angular.isNumber(index) && currentIndex !== index) {
      for (var i = 0; i < slides.length; i++) {
        if (slides[i].slide.index === index) {
          index = i;
          break;
        }
      }

      var slide = slides[index];
      if (slide) {
        setActive(index);
        self.select(slides[index]);
        currentIndex = index;
      }
    }
  });

  function getSlideByIndex(index) {
    for (var i = 0, l = slides.length; i < l; ++i) {
      if (slides[i].index === index) {
        return slides[i];
      }
    }
  }

  function setActive(index) {
    for (var i = 0; i < slides.length; i++) {
      slides[i].slide.active = i === index;
    }
  }

  function goNext(slide, index, direction) {
    if (destroyed) {
      return;
    }

    angular.extend(slide, {direction: direction});
    angular.extend(slides[currentIndex].slide || {}, {direction: direction});
    if ($animate.enabled($element) && !$scope.$currentTransition &&
      slides[index].element && self.slides.length > 1) {
      slides[index].element.data(SLIDE_DIRECTION, slide.direction);
      var currentIdx = self.getCurrentIndex();

      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
      }

      $scope.$currentTransition = true;
      $animate.on('addClass', slides[index].element, function(element, phase) {
        if (phase === 'close') {
          $scope.$currentTransition = null;
          $animate.off('addClass', element);
        }
      });
    }

    $scope.active = slide.index;
    currentIndex = slide.index;
    setActive(index);

    //every time you change slides, reset the timer
    restartTimer();
  }

  function findSlideIndex(slide) {
    for (var i = 0; i < slides.length; i++) {
      if (slides[i].slide === slide) {
        return i;
      }
    }
  }

  function resetTimer() {
    if (currentInterval) {
      $interval.cancel(currentInterval);
      currentInterval = null;
    }
  }

  function resetTransition(slides) {
    if (!slides.length) {
      $scope.$currentTransition = null;
    }
  }

  function restartTimer() {
    resetTimer();
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval > 0) {
      currentInterval = $interval(timerFn, interval);
    }
  }

  function timerFn() {
    var interval = +$scope.interval;
    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
      $scope.next();
    } else {
      $scope.pause();
    }
  }
}])

.directive('uibCarousel', function() {
  return {
    transclude: true,
    controller: 'UibCarouselController',
    controllerAs: 'carousel',
    restrict: 'A',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/carousel/carousel.html';
    },
    scope: {
      active: '=',
      interval: '=',
      noTransition: '=',
      noPause: '=',
      noWrap: '&'
    }
  };
})

.directive('uibSlide', ['$animate', function($animate) {
  return {
    require: '^uibCarousel',
    restrict: 'A',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/carousel/slide.html';
    },
    scope: {
      actual: '=?',
      index: '=?'
    },
    link: function (scope, element, attrs, carouselCtrl) {
      element.addClass('item');
      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        $animate[active ? 'addClass' : 'removeClass'](element, 'active');
      });
    }
  };
}])

.animation('.item', ['$animateCss',
function($animateCss) {
  var SLIDE_DIRECTION = 'uib-slideDirection';

  function removeClass(element, className, callback) {
    element.removeClass(className);
    if (callback) {
      callback();
    }
  }

  return {
    beforeAddClass: function(element, className, done) {
      if (className === 'active') {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction === 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element,
          directionClass + ' ' + direction, done);
        element.addClass(direction);

        $animateCss(element, {addClass: directionClass})
          .start()
          .done(removeClassFn);

        return function() {
          stopped = true;
        };
      }
      done();
    },
    beforeRemoveClass: function (element, className, done) {
      if (className === 'active') {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction === 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element, directionClass, done);

        $animateCss(element, {addClass: directionClass})
          .start()
          .done(removeClassFn);

        return function() {
          stopped = true;
        };
      }
      done();
    }
  };
}]);

angular.module('ui.bootstrap.dateparser', [])

.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', 'filterFilter', function($log, $locale, dateFilter, orderByFilter, filterFilter) {
  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  var localeId;
  var formatCodeToRegex;

  this.init = function() {
    localeId = $locale.id;

    this.parsers = {};
    this.formatters = {};

    formatCodeToRegex = [
      {
        key: 'yyyy',
        regex: '\\d{4}',
        apply: function(value) { this.year = +value; },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'yyyy');
        }
      },
      {
        key: 'yy',
        regex: '\\d{2}',
        apply: function(value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'yy');
        }
      },
      {
        key: 'y',
        regex: '\\d{1,4}',
        apply: function(value) { this.year = +value; },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'y');
        }
      },
      {
        key: 'M!',
        regex: '0?[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; },
        formatter: function(date) {
          var value = date.getMonth();
          if (/^[0-9]$/.test(value)) {
            return dateFilter(date, 'MM');
          }

          return dateFilter(date, 'M');
        }
      },
      {
        key: 'MMMM',
        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },
        formatter: function(date) { return dateFilter(date, 'MMMM'); }
      },
      {
        key: 'MMM',
        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },
        formatter: function(date) { return dateFilter(date, 'MMM'); }
      },
      {
        key: 'MM',
        regex: '0[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; },
        formatter: function(date) { return dateFilter(date, 'MM'); }
      },
      {
        key: 'M',
        regex: '[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; },
        formatter: function(date) { return dateFilter(date, 'M'); }
      },
      {
        key: 'd!',
        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; },
        formatter: function(date) {
          var value = date.getDate();
          if (/^[1-9]$/.test(value)) {
            return dateFilter(date, 'dd');
          }

          return dateFilter(date, 'd');
        }
      },
      {
        key: 'dd',
        regex: '[0-2][0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; },
        formatter: function(date) { return dateFilter(date, 'dd'); }
      },
      {
        key: 'd',
        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; },
        formatter: function(date) { return dateFilter(date, 'd'); }
      },
      {
        key: 'EEEE',
        regex: $locale.DATETIME_FORMATS.DAY.join('|'),
        formatter: function(date) { return dateFilter(date, 'EEEE'); }
      },
      {
        key: 'EEE',
        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
        formatter: function(date) { return dateFilter(date, 'EEE'); }
      },
      {
        key: 'HH',
        regex: '(?:0|1)[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'HH'); }
      },
      {
        key: 'hh',
        regex: '0[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'hh'); }
      },
      {
        key: 'H',
        regex: '1?[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'H'); }
      },
      {
        key: 'h',
        regex: '[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'h'); }
      },
      {
        key: 'mm',
        regex: '[0-5][0-9]',
        apply: function(value) { this.minutes = +value; },
        formatter: function(date) { return dateFilter(date, 'mm'); }
      },
      {
        key: 'm',
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.minutes = +value; },
        formatter: function(date) { return dateFilter(date, 'm'); }
      },
      {
        key: 'sss',
        regex: '[0-9][0-9][0-9]',
        apply: function(value) { this.milliseconds = +value; },
        formatter: function(date) { return dateFilter(date, 'sss'); }
      },
      {
        key: 'ss',
        regex: '[0-5][0-9]',
        apply: function(value) { this.seconds = +value; },
        formatter: function(date) { return dateFilter(date, 'ss'); }
      },
      {
        key: 's',
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.seconds = +value; },
        formatter: function(date) { return dateFilter(date, 's'); }
      },
      {
        key: 'a',
        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
        apply: function(value) {
          if (this.hours === 12) {
            this.hours = 0;
          }

          if (value === 'PM') {
            this.hours += 12;
          }
        },
        formatter: function(date) { return dateFilter(date, 'a'); }
      },
      {
        key: 'Z',
        regex: '[+-]\\d{4}',
        apply: function(value) {
          var matches = value.match(/([+-])(\d{2})(\d{2})/),
            sign = matches[1],
            hours = matches[2],
            minutes = matches[3];
          this.hours += toInt(sign + hours);
          this.minutes += toInt(sign + minutes);
        },
        formatter: function(date) {
          return dateFilter(date, 'Z');
        }
      },
      {
        key: 'ww',
        regex: '[0-4][0-9]|5[0-3]',
        formatter: function(date) { return dateFilter(date, 'ww'); }
      },
      {
        key: 'w',
        regex: '[0-9]|[1-4][0-9]|5[0-3]',
        formatter: function(date) { return dateFilter(date, 'w'); }
      },
      {
        key: 'GGGG',
        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
        formatter: function(date) { return dateFilter(date, 'GGGG'); }
      },
      {
        key: 'GGG',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) { return dateFilter(date, 'GGG'); }
      },
      {
        key: 'GG',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) { return dateFilter(date, 'GG'); }
      },
      {
        key: 'G',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) { return dateFilter(date, 'G'); }
      }
    ];

    if (angular.version.major >= 1 && angular.version.minor > 4) {
      formatCodeToRegex.push({
        key: 'LLLL',
        regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value); },
        formatter: function(date) { return dateFilter(date, 'LLLL'); }
      });
    }
  };

  this.init();

  function getFormatCodeToRegex(key) {
    return filterFilter(formatCodeToRegex, {key: key}, true)[0];
  }

  this.getParser = function (key) {
    var f = getFormatCodeToRegex(key);
    return f && f.apply || null;
  };

  this.overrideParser = function (key, parser) {
    var f = getFormatCodeToRegex(key);
    if (f && angular.isFunction(parser)) {
      this.parsers = {};
      f.apply = parser;
    }
  }.bind(this);

  function createParser(format) {
    var map = [], regex = format.split('');

    // check for literal values
    var quoteIndex = format.indexOf('\'');
    if (quoteIndex > -1) {
      var inLiteral = false;
      format = format.split('');
      for (var i = quoteIndex; i < format.length; i++) {
        if (inLiteral) {
          if (format[i] === '\'') {
            if (i + 1 < format.length && format[i+1] === '\'') { // escaped single quote
              format[i+1] = '$';
              regex[i+1] = '';
            } else { // end of literal
              regex[i] = '';
              inLiteral = false;
            }
          }
          format[i] = '$';
        } else {
          if (format[i] === '\'') { // start of literal
            format[i] = '$';
            regex[i] = '';
            inLiteral = true;
          }
        }
      }

      format = format.join('');
    }

    angular.forEach(formatCodeToRegex, function(data) {
      var index = format.indexOf(data.key);

      if (index > -1) {
        format = format.split('');

        regex[index] = '(' + data.regex + ')';
        format[index] = '$'; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + data.key.length; i < n; i++) {
          regex[i] = '';
          format[i] = '$';
        }
        format = format.join('');

        map.push({
          index: index,
          key: data.key,
          apply: data.apply,
          matcher: data.regex
        });
      }
    });

    return {
      regex: new RegExp('^' + regex.join('') + '$'),
      map: orderByFilter(map, 'index')
    };
  }

  function createFormatter(format) {
    var formatters = [];
    var i = 0;
    var formatter, literalIdx;
    while (i < format.length) {
      if (angular.isNumber(literalIdx)) {
        if (format.charAt(i) === '\'') {
          if (i + 1 >= format.length || format.charAt(i + 1) !== '\'') {
            formatters.push(constructLiteralFormatter(format, literalIdx, i));
            literalIdx = null;
          }
        } else if (i === format.length) {
          while (literalIdx < format.length) {
            formatter = constructFormatterFromIdx(format, literalIdx);
            formatters.push(formatter);
            literalIdx = formatter.endIdx;
          }
        }

        i++;
        continue;
      }

      if (format.charAt(i) === '\'') {
        literalIdx = i;
        i++;
        continue;
      }

      formatter = constructFormatterFromIdx(format, i);

      formatters.push(formatter.parser);
      i = formatter.endIdx;
    }

    return formatters;
  }

  function constructLiteralFormatter(format, literalIdx, endIdx) {
    return function() {
      return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
    };
  }

  function constructFormatterFromIdx(format, i) {
    var currentPosStr = format.substr(i);
    for (var j = 0; j < formatCodeToRegex.length; j++) {
      if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
        var data = formatCodeToRegex[j];
        return {
          endIdx: i + data.key.length,
          parser: data.formatter
        };
      }
    }

    return {
      endIdx: i + 1,
      parser: function() {
        return currentPosStr.charAt(0);
      }
    };
  }

  this.filter = function(date, format) {
    if (!angular.isDate(date) || isNaN(date) || !format) {
      return '';
    }

    format = $locale.DATETIME_FORMATS[format] || format;

    if ($locale.id !== localeId) {
      this.init();
    }

    if (!this.formatters[format]) {
      this.formatters[format] = createFormatter(format);
    }

    var formatters = this.formatters[format];

    return formatters.reduce(function(str, formatter) {
      return str + formatter(date);
    }, '');
  };

  this.parse = function(input, format, baseDate) {
    if (!angular.isString(input) || !format) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;
    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

    if ($locale.id !== localeId) {
      this.init();
    }

    if (!this.parsers[format]) {
      this.parsers[format] = createParser(format, 'apply');
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex),
        tzOffset = false;
    if (results && results.length) {
      var fields, dt;
      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
        fields = {
          year: baseDate.getFullYear(),
          month: baseDate.getMonth(),
          date: baseDate.getDate(),
          hours: baseDate.getHours(),
          minutes: baseDate.getMinutes(),
          seconds: baseDate.getSeconds(),
          milliseconds: baseDate.getMilliseconds()
        };
      } else {
        if (baseDate) {
          $log.warn('dateparser:', 'baseDate is not a valid date');
        }
        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
      }

      for (var i = 1, n = results.length; i < n; i++) {
        var mapper = map[i - 1];
        if (mapper.matcher === 'Z') {
          tzOffset = true;
        }

        if (mapper.apply) {
          mapper.apply.call(fields, results[i]);
        }
      }

      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
        Date.prototype.setFullYear;
      var timesetter = tzOffset ? Date.prototype.setUTCHours :
        Date.prototype.setHours;

      if (isValid(fields.year, fields.month, fields.date)) {
        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
          dt = new Date(baseDate);
          datesetter.call(dt, fields.year, fields.month, fields.date);
          timesetter.call(dt, fields.hours, fields.minutes,
            fields.seconds, fields.milliseconds);
        } else {
          dt = new Date(0);
          datesetter.call(dt, fields.year, fields.month, fields.date);
          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
            fields.seconds || 0, fields.milliseconds || 0);
        }
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if (date < 1) {
      return false;
    }

    if (month === 1 && date > 28) {
      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
    }

    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return date < 31;
    }

    return true;
  }

  function toInt(str) {
    return parseInt(str, 10);
  }

  this.toTimezone = toTimezone;
  this.fromTimezone = fromTimezone;
  this.timezoneToOffset = timezoneToOffset;
  this.addDateMinutes = addDateMinutes;
  this.convertTimezoneToLocal = convertTimezoneToLocal;

  function toTimezone(date, timezone) {
    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
  }

  function fromTimezone(date, timezone) {
    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
  }

  //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207
  function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(/:/g, '');
    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }

  function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }

  function convertTimezoneToLocal(date, timezone, reverse) {
    reverse = reverse ? -1 : 1;
    var dateTimezoneOffset = date.getTimezoneOffset();
    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
  }
}]);

// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to
// at most one element.
angular.module('ui.bootstrap.isClass', [])
.directive('uibIsClass', [
         '$animate',
function ($animate) {
  //                    11111111          22222222
  var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
  //                    11111111           22222222
  var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

  var dataPerTracked = {};

  return {
    restrict: 'A',
    compile: function(tElement, tAttrs) {
      var linkedScopes = [];
      var instances = [];
      var expToData = {};
      var lastActivated = null;
      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
      var onExp = onExpMatches[2];
      var expsStr = onExpMatches[1];
      var exps = expsStr.split(',');

      return linkFn;

      function linkFn(scope, element, attrs) {
        linkedScopes.push(scope);
        instances.push({
          scope: scope,
          element: element
        });

        exps.forEach(function(exp, k) {
          addForExp(exp, scope);
        });

        scope.$on('$destroy', removeScope);
      }

      function addForExp(exp, scope) {
        var matches = exp.match(IS_REGEXP);
        var clazz = scope.$eval(matches[1]);
        var compareWithExp = matches[2];
        var data = expToData[exp];
        if (!data) {
          var watchFn = function(compareWithVal) {
            var newActivated = null;
            instances.some(function(instance) {
              var thisVal = instance.scope.$eval(onExp);
              if (thisVal === compareWithVal) {
                newActivated = instance;
                return true;
              }
            });
            if (data.lastActivated !== newActivated) {
              if (data.lastActivated) {
                $animate.removeClass(data.lastActivated.element, clazz);
              }
              if (newActivated) {
                $animate.addClass(newActivated.element, clazz);
              }
              data.lastActivated = newActivated;
            }
          };
          expToData[exp] = data = {
            lastActivated: null,
            scope: scope,
            watchFn: watchFn,
            compareWithExp: compareWithExp,
            watcher: scope.$watch(compareWithExp, watchFn)
          };
        }
        data.watchFn(scope.$eval(compareWithExp));
      }

      function removeScope(e) {
        var removedScope = e.targetScope;
        var index = linkedScopes.indexOf(removedScope);
        linkedScopes.splice(index, 1);
        instances.splice(index, 1);
        if (linkedScopes.length) {
          var newWatchScope = linkedScopes[0];
          angular.forEach(expToData, function(data) {
            if (data.scope === removedScope) {
              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
              data.scope = newWatchScope;
            }
          });
        } else {
          expToData = {};
        }
      }
    }
  };
}]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])

.value('$datepickerSuppressError', false)

.value('$datepickerLiteralWarning', true)

.constant('uibDatepickerConfig', {
  datepickerMode: 'day',
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  maxDate: null,
  maxMode: 'year',
  minDate: null,
  minMode: 'day',
  monthColumns: 3,
  ngModelOptions: {},
  shortcutPropagation: false,
  showWeeks: true,
  yearColumns: 5,
  yearRows: 4
})

.controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',
  function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;
      ngModelOptions = {},
      watchListeners = [];

  $element.addClass('uib-datepicker');
  $attrs.$set('role', 'application');

  if (!$scope.datepickerOptions) {
    $scope.datepickerOptions = {};
  }

  // Modes chain
  this.modes = ['day', 'month', 'year'];

  [
    'customClass',
    'dateDisabled',
    'datepickerMode',
    'formatDay',
    'formatDayHeader',
    'formatDayTitle',
    'formatMonth',
    'formatMonthTitle',
    'formatYear',
    'maxDate',
    'maxMode',
    'minDate',
    'minMode',
    'monthColumns',
    'showWeeks',
    'shortcutPropagation',
    'startingDay',
    'yearColumns',
    'yearRows'
  ].forEach(function(key) {
    switch (key) {
      case 'customClass':
      case 'dateDisabled':
        $scope[key] = $scope.datepickerOptions[key] || angular.noop;
        break;
      case 'datepickerMode':
        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?
          $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
        break;
      case 'formatDay':
      case 'formatDayHeader':
      case 'formatDayTitle':
      case 'formatMonth':
      case 'formatMonthTitle':
      case 'formatYear':
        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
          $interpolate($scope.datepickerOptions[key])($scope.$parent) :
          datepickerConfig[key];
        break;
      case 'monthColumns':
      case 'showWeeks':
      case 'shortcutPropagation':
      case 'yearColumns':
      case 'yearRows':
        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
          $scope.datepickerOptions[key] : datepickerConfig[key];
        break;
      case 'startingDay':
        if (angular.isDefined($scope.datepickerOptions.startingDay)) {
          self.startingDay = $scope.datepickerOptions.startingDay;
        } else if (angular.isNumber(datepickerConfig.startingDay)) {
          self.startingDay = datepickerConfig.startingDay;
        } else {
          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
        }

        break;
      case 'maxDate':
      case 'minDate':
        $scope.$watch('datepickerOptions.' + key, function(value) {
          if (value) {
            if (angular.isDate(value)) {
              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption('timezone'));
            } else {
              if ($datepickerLiteralWarning) {
                $log.warn('Literal date support has been deprecated, please switch to date object usage');
              }

              self[key] = new Date(dateFilter(value, 'medium'));
            }
          } else {
            self[key] = datepickerConfig[key] ?
              dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption('timezone')) :
              null;
          }

          self.refreshView();
        });

        break;
      case 'maxMode':
      case 'minMode':
        if ($scope.datepickerOptions[key]) {
          $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {
            self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key];
            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||
              key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
              $scope.datepickerMode = self[key];
              $scope.datepickerOptions.datepickerMode = self[key];
            }
          });
        } else {
          self[key] = $scope[key] = datepickerConfig[key] || null;
        }

        break;
    }
  });

  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  $scope.disabled = angular.isDefined($attrs.disabled) || false;
  if (angular.isDefined($attrs.ngDisabled)) {
    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
      $scope.disabled = disabled;
      self.refreshView();
    }));
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelOptions = extractOptions(ngModelCtrl);

    if ($scope.datepickerOptions.initDate) {
      self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption('timezone')) || new Date();
      $scope.$watch('datepickerOptions.initDate', function(initDate) {
        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption('timezone'));
          self.refreshView();
        }
      });
    } else {
      self.activeDate = new Date();
    }

    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
    this.activeDate = !isNaN(date) ?
      dateParser.fromTimezone(date, ngModelOptions.getOption('timezone')) :
      dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if (ngModelCtrl.$viewValue) {
      var date = new Date(ngModelCtrl.$viewValue),
          isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
      } else if (!$datepickerSuppressError) {
        $log.error('Datepicker directive: "ng-model" value must be a Date object');
      }
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if (this.element) {
      $scope.selectedDt = null;
      this._refreshView();
      if ($scope.activeDt) {
        $scope.activeDateId = $scope.activeDt.uid;
      }

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      date = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
      ngModelCtrl.$setValidity('dateDisabled', !date ||
        this.element && !this.isDisabled(date));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    model = dateParser.fromTimezone(model, ngModelOptions.getOption('timezone'));
    var today = new Date();
    today = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
    var time = this.compare(date, today);
    var dt = {
      date: date,
      label: dateParser.filter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      past: time < 0,
      current: time === 0,
      future: time > 0,
      customClass: this.customClass(date) || null
    };

    if (model && this.compare(date, model) === 0) {
      $scope.selectedDt = dt;
    }

    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
      $scope.activeDt = dt;
    }

    return dt;
  };

  this.isDisabled = function(date) {
    return $scope.disabled ||
      this.minDate && this.compare(date, this.minDate) < 0 ||
      this.maxDate && this.compare(date, this.maxDate) > 0 ||
      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});
  };

  this.customClass = function(date) {
    return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  $scope.select = function(date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption('timezone')) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      dt = dateParser.toTimezone(dt, ngModelOptions.getOption('timezone'));
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);

      $scope.$emit('uib:datepicker.mode');
    }

    $scope.$broadcast('uib:datepicker.focus');
  };

  $scope.move = function(direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function(direction) {
    direction = direction || 1;

    if ($scope.datepickerMode === self.maxMode && direction === 1 ||
      $scope.datepickerMode === self.minMode && direction === -1) {
      return;
    }

    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);

    $scope.$emit('uib:datepicker.mode');
  };

  // Key event mapper
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function() {
    self.element[0].focus();
  };

  // Listen for focus requests from popup directive
  $scope.$on('uib:datepicker.focus', focusElement);

  $scope.keydown = function(evt) {
    var key = $scope.keys[evt.which];

    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
      return;
    }

    evt.preventDefault();
    if (!self.shortcutPropagation) {
      evt.stopPropagation();
    }

    if (key === 'enter' || key === 'space') {
      if (self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };

  $element.on('keydown', function(evt) {
    $scope.$apply(function() {
      $scope.keydown(evt);
    });
  });

  $scope.$on('$destroy', function() {
    //Clear all watch listeners on destroy
    while (watchListeners.length) {
      watchListeners.shift()();
    }
  });

  function setMode(mode) {
    $scope.datepickerMode = mode;
    $scope.datepickerOptions.datepickerMode = mode;
  }

  function extractOptions(ngModelCtrl) {
    var ngModelOptions;

    if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing
      // guarantee a value
      ngModelOptions = ngModelCtrl.$options ||
        $scope.datepickerOptions.ngModelOptions ||
        datepickerConfig.ngModelOptions ||
        {};

      // mimic 1.6+ api
      ngModelOptions.getOption = function (key) {
        return ngModelOptions[key];
      };
    } else { // in angular >=1.6 $options is always present
      // ng-model-options defaults timezone to null; don't let its precedence squash a non-null value
      var timezone = ngModelCtrl.$options.getOption('timezone') ||
        ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) ||
        (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);

      // values passed to createChild override existing values
      ngModelOptions = ngModelCtrl.$options // start with a ModelOptions instance
        .createChild(datepickerConfig.ngModelOptions) // lowest precedence
        .createChild($scope.datepickerOptions.ngModelOptions)
        .createChild(ngModelCtrl.$options) // highest precedence
        .createChild({timezone: timezone}); // to keep from squashing a non-null value
    }

    return ngModelOptions;
  }
}])

.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  this.step = { months: 1 };
  this.element = $element;
  function getDaysInMonth(year, month) {
    return month === 1 && year % 4 === 0 &&
      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
  }

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    scope.showWeeks = ctrl.showWeeks;
    ctrl.refreshView();
  };

  this.getDates = function(startDate, n) {
    var dates = new Array(n), current = new Date(startDate), i = 0, date;
    while (i < n) {
      date = new Date(current);
      dates[i++] = date;
      current.setDate(current.getDate() + 1);
    }
    return dates;
  };

  this._refreshView = function() {
    var year = this.activeDate.getFullYear(),
      month = this.activeDate.getMonth(),
      firstDayOfMonth = new Date(this.activeDate);

    firstDayOfMonth.setFullYear(year, month, 1);

    var difference = this.startingDay - firstDayOfMonth.getDay(),
      numDisplayedFromPreviousMonth = difference > 0 ?
        7 - difference : - difference,
      firstDate = new Date(firstDayOfMonth);

    if (numDisplayedFromPreviousMonth > 0) {
      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
    }

    // 42 is the number of days on a six-week calendar
    var days = this.getDates(firstDate, 42);
    for (var i = 0; i < 42; i ++) {
      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
        secondary: days[i].getMonth() !== month,
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.labels = new Array(7);
    for (var j = 0; j < 7; j++) {
      scope.labels[j] = {
        abbr: dateFilter(days[j].date, this.formatDayHeader),
        full: dateFilter(days[j].date, 'EEEE')
      };
    }

    scope.title = dateFilter(this.activeDate, this.formatDayTitle);
    scope.rows = this.split(days, 7);

    if (scope.showWeeks) {
      scope.weekNumbers = [];
      var thursdayIndex = (4 + 7 - this.startingDay) % 7,
          numWeeks = scope.rows.length;
      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
        scope.weekNumbers.push(
          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
      }
    }
  };

  this.compare = function(date1, date2) {
    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    _date1.setFullYear(date1.getFullYear());
    _date2.setFullYear(date2.getFullYear());
    return _date1 - _date2;
  };

  function getISO8601WeekNumber(date) {
    var checkDate = new Date(date);
    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
    var time = checkDate.getTime();
    checkDate.setMonth(0); // Compare with Jan 1
    checkDate.setDate(1);
    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
  }

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getDate();

    if (key === 'left') {
      date = date - 1;
    } else if (key === 'up') {
      date = date - 7;
    } else if (key === 'right') {
      date = date + 1;
    } else if (key === 'down') {
      date = date + 7;
    } else if (key === 'pageup' || key === 'pagedown') {
      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setMonth(month, 1);
      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
    } else if (key === 'home') {
      date = 1;
    } else if (key === 'end') {
      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
    }
    this.activeDate.setDate(date);
  };
}])

.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  this.step = { years: 1 };
  this.element = $element;

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    ctrl.refreshView();
  };

  this._refreshView = function() {
    var months = new Array(12),
        year = this.activeDate.getFullYear(),
        date;

    for (var i = 0; i < 12; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(year, i, 1);
      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
    scope.rows = this.split(months, this.monthColumns);
    scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
  };

  this.compare = function(date1, date2) {
    var _date1 = new Date(date1.getFullYear(), date1.getMonth());
    var _date2 = new Date(date2.getFullYear(), date2.getMonth());
    _date1.setFullYear(date1.getFullYear());
    _date2.setFullYear(date2.getFullYear());
    return _date1 - _date2;
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getMonth();

    if (key === 'left') {
      date = date - 1;
    } else if (key === 'up') {
      date = date - this.monthColumns;
    } else if (key === 'right') {
      date = date + 1;
    } else if (key === 'down') {
      date = date + this.monthColumns;
    } else if (key === 'pageup' || key === 'pagedown') {
      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setFullYear(year);
    } else if (key === 'home') {
      date = 0;
    } else if (key === 'end') {
      date = 11;
    }
    this.activeDate.setMonth(date);
  };
}])

.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var columns, range;
  this.element = $element;

  function getStartingYear(year) {
    return parseInt((year - 1) / range, 10) * range + 1;
  }

  this.yearpickerInit = function() {
    columns = this.yearColumns;
    range = this.yearRows * columns;
    this.step = { years: range };
  };

  this._refreshView = function() {
    var years = new Array(range), date;

    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(start + i, 0, 1);
      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = [years[0].label, years[range - 1].label].join(' - ');
    scope.rows = this.split(years, columns);
    scope.columns = columns;
  };

  this.compare = function(date1, date2) {
    return date1.getFullYear() - date2.getFullYear();
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getFullYear();

    if (key === 'left') {
      date = date - 1;
    } else if (key === 'up') {
      date = date - columns;
    } else if (key === 'right') {
      date = date + 1;
    } else if (key === 'down') {
      date = date + columns;
    } else if (key === 'pageup' || key === 'pagedown') {
      date += (key === 'pageup' ? - 1 : 1) * range;
    } else if (key === 'home') {
      date = getStartingYear(this.activeDate.getFullYear());
    } else if (key === 'end') {
      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
    }
    this.activeDate.setFullYear(date);
  };
}])

.directive('uibDatepicker', function() {
  return {
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
    },
    scope: {
      datepickerOptions: '=?'
    },
    require: ['uibDatepicker', '^ngModel'],
    restrict: 'A',
    controller: 'UibDatepickerController',
    controllerAs: 'datepicker',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      datepickerCtrl.init(ngModelCtrl);
    }
  };
})

.directive('uibDaypicker', function() {
  return {
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/day.html';
    },
    require: ['^uibDatepicker', 'uibDaypicker'],
    restrict: 'A',
    controller: 'UibDaypickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0],
        daypickerCtrl = ctrls[1];

      daypickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibMonthpicker', function() {
  return {
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/month.html';
    },
    require: ['^uibDatepicker', 'uibMonthpicker'],
    restrict: 'A',
    controller: 'UibMonthpickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0],
        monthpickerCtrl = ctrls[1];

      monthpickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibYearpicker', function() {
  return {
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/year.html';
    },
    require: ['^uibDatepicker', 'uibYearpicker'],
    restrict: 'A',
    controller: 'UibYearpickerController',
    link: function(scope, element, attrs, ctrls) {
      var ctrl = ctrls[0];
      angular.extend(ctrl, ctrls[1]);
      ctrl.yearpickerInit();

      ctrl.refreshView();
    }
  };
});

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods for working with the DOM.
 * It is meant to be used where we need to absolute-position elements in
 * relation to another element (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
    /**
     * Used by scrollbarWidth() function to cache scrollbar's width.
     * Do not access this variable directly, use scrollbarWidth() instead.
     */
    var SCROLLBAR_WIDTH;
    /**
     * scrollbar on body and html element in IE and Edge overlay
     * content and should be considered 0 width.
     */
    var BODY_SCROLLBAR_WIDTH;
    var OVERFLOW_REGEX = {
      normal: /(auto|scroll)/,
      hidden: /(auto|scroll|hidden)/
    };
    var PLACEMENT_REGEX = {
      auto: /\s?auto?\s?/i,
      primary: /^(top|bottom|left|right)$/,
      secondary: /^(top|bottom|left|right|center)$/,
      vertical: /^(top|bottom)$/
    };
    var BODY_REGEX = /(HTML|BODY)/;

    return {

      /**
       * Provides a raw DOM element from a jQuery/jQLite element.
       *
       * @param {element} elem - The element to convert.
       *
       * @returns {element} A HTML element.
       */
      getRawNode: function(elem) {
        return elem.nodeName ? elem : elem[0] || elem;
      },

      /**
       * Provides a parsed number for a style property.  Strips
       * units and casts invalid numbers to 0.
       *
       * @param {string} value - The style value to parse.
       *
       * @returns {number} A valid number.
       */
      parseStyle: function(value) {
        value = parseFloat(value);
        return isFinite(value) ? value : 0;
      },

      /**
       * Provides the closest positioned ancestor.
       *
       * @param {element} element - The element to get the offest parent for.
       *
       * @returns {element} The closest positioned ancestor.
       */
      offsetParent: function(elem) {
        elem = this.getRawNode(elem);

        var offsetParent = elem.offsetParent || $document[0].documentElement;

        function isStaticPositioned(el) {
          return ($window.getComputedStyle(el).position || 'static') === 'static';
        }

        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || $document[0].documentElement;
      },

      /**
       * Provides the scrollbar width, concept from TWBS measureScrollbar()
       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js
       * In IE and Edge, scollbar on body and html element overlay and should
       * return a width of 0.
       *
       * @returns {number} The width of the browser scollbar.
       */
      scrollbarWidth: function(isBody) {
        if (isBody) {
          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
            var bodyElem = $document.find('body');
            bodyElem.addClass('uib-position-body-scrollbar-measure');
            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
            bodyElem.removeClass('uib-position-body-scrollbar-measure');
          }
          return BODY_SCROLLBAR_WIDTH;
        }

        if (angular.isUndefined(SCROLLBAR_WIDTH)) {
          var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
          $document.find('body').append(scrollElem);
          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
          scrollElem.remove();
        }

        return SCROLLBAR_WIDTH;
      },

      /**
       * Provides the padding required on an element to replace the scrollbar.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**scrollbarWidth**: the width of the scrollbar</li>
       *     <li>**widthOverflow**: whether the the width is overflowing</li>
       *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>
       *     <li>**rightOriginal**: the amount of right padding currently on the element</li>
       *     <li>**heightOverflow**: whether the the height is overflowing</li>
       *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>
       *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>
       *   </ul>
       */
      scrollbarPadding: function(elem) {
        elem = this.getRawNode(elem);

        var elemStyle = $window.getComputedStyle(elem);
        var paddingRight = this.parseStyle(elemStyle.paddingRight);
        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
        var scrollParent = this.scrollParent(elem, false, true);
        var scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));

        return {
          scrollbarWidth: scrollbarWidth,
          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
          right: paddingRight + scrollbarWidth,
          originalRight: paddingRight,
          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
          bottom: paddingBottom + scrollbarWidth,
          originalBottom: paddingBottom
         };
      },

      /**
       * Checks to see if the element is scrollable.
       *
       * @param {element} elem - The element to check.
       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
       *   default is false.
       *
       * @returns {boolean} Whether the element is scrollable.
       */
      isScrollable: function(elem, includeHidden) {
        elem = this.getRawNode(elem);

        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var elemStyle = $window.getComputedStyle(elem);
        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
      },

      /**
       * Provides the closest scrollable ancestor.
       * A port of the jQuery UI scrollParent method:
       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js
       *
       * @param {element} elem - The element to find the scroll parent of.
       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
       *   default is false.
       * @param {boolean=} [includeSelf=false] - Should the element being passed be
       * included in the scrollable llokup.
       *
       * @returns {element} A HTML element.
       */
      scrollParent: function(elem, includeHidden, includeSelf) {
        elem = this.getRawNode(elem);

        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var documentEl = $document[0].documentElement;
        var elemStyle = $window.getComputedStyle(elem);
        if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
          return elem;
        }
        var excludeStatic = elemStyle.position === 'absolute';
        var scrollParent = elem.parentElement || documentEl;

        if (scrollParent === documentEl || elemStyle.position === 'fixed') {
          return documentEl;
        }

        while (scrollParent.parentElement && scrollParent !== documentEl) {
          var spStyle = $window.getComputedStyle(scrollParent);
          if (excludeStatic && spStyle.position !== 'static') {
            excludeStatic = false;
          }

          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
            break;
          }
          scrollParent = scrollParent.parentElement;
        }

        return scrollParent;
      },

      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/ - distance to closest positioned
       * ancestor.  Does not account for margins by default like jQuery position.
       *
       * @param {element} elem - The element to caclulate the position on.
       * @param {boolean=} [includeMargins=false] - Should margins be accounted
       * for, default is false.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**width**: the width of the element</li>
       *     <li>**height**: the height of the element</li>
       *     <li>**top**: distance to top edge of offset parent</li>
       *     <li>**left**: distance to left edge of offset parent</li>
       *   </ul>
       */
      position: function(elem, includeMagins) {
        elem = this.getRawNode(elem);

        var elemOffset = this.offset(elem);
        if (includeMagins) {
          var elemStyle = $window.getComputedStyle(elem);
          elemOffset.top -= this.parseStyle(elemStyle.marginTop);
          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
        }
        var parent = this.offsetParent(elem);
        var parentOffset = {top: 0, left: 0};

        if (parent !== $document[0].documentElement) {
          parentOffset = this.offset(parent);
          parentOffset.top += parent.clientTop - parent.scrollTop;
          parentOffset.left += parent.clientLeft - parent.scrollLeft;
        }

        return {
          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
          top: Math.round(elemOffset.top - parentOffset.top),
          left: Math.round(elemOffset.left - parentOffset.left)
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/ - distance to viewport.  Does
       * not account for borders, margins, or padding on the body
       * element.
       *
       * @param {element} elem - The element to calculate the offset on.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**width**: the width of the element</li>
       *     <li>**height**: the height of the element</li>
       *     <li>**top**: distance to top edge of viewport</li>
       *     <li>**right**: distance to bottom edge of viewport</li>
       *   </ul>
       */
      offset: function(elem) {
        elem = this.getRawNode(elem);

        var elemBCR = elem.getBoundingClientRect();
        return {
          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
        };
      },

      /**
       * Provides offset distance to the closest scrollable ancestor
       * or viewport.  Accounts for border and scrollbar width.
       *
       * Right and bottom dimensions represent the distance to the
       * respective edge of the viewport element.  If the element
       * edge extends beyond the viewport, a negative value will be
       * reported.
       *
       * @param {element} elem - The element to get the viewport offset for.
       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead
       * of the first scrollable element, default is false.
       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element
       * be accounted for, default is true.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**top**: distance to the top content edge of viewport element</li>
       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>
       *     <li>**left**: distance to the left content edge of viewport element</li>
       *     <li>**right**: distance to the right content edge of viewport element</li>
       *   </ul>
       */
      viewportOffset: function(elem, useDocument, includePadding) {
        elem = this.getRawNode(elem);
        includePadding = includePadding !== false ? true : false;

        var elemBCR = elem.getBoundingClientRect();
        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};

        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
        var offsetParentBCR = offsetParent.getBoundingClientRect();

        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
        if (offsetParent === $document[0].documentElement) {
          offsetBCR.top += $window.pageYOffset;
          offsetBCR.left += $window.pageXOffset;
        }
        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

        if (includePadding) {
          var offsetParentStyle = $window.getComputedStyle(offsetParent);
          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
        }

        return {
          top: Math.round(elemBCR.top - offsetBCR.top),
          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
          left: Math.round(elemBCR.left - offsetBCR.left),
          right: Math.round(offsetBCR.right - elemBCR.right)
        };
      },

      /**
       * Provides an array of placement values parsed from a placement string.
       * Along with the 'auto' indicator, supported placement strings are:
       *   <ul>
       *     <li>top: element on top, horizontally centered on host element.</li>
       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>
       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>
       *     <li>bottom: element on bottom, horizontally centered on host element.</li>
       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>
       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>
       *     <li>left: element on left, vertically centered on host element.</li>
       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>
       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>
       *     <li>right: element on right, vertically centered on host element.</li>
       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>
       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>
       *   </ul>
       * A placement string with an 'auto' indicator is expected to be
       * space separated from the placement, i.e: 'auto bottom-left'  If
       * the primary and secondary placement values do not match 'top,
       * bottom, left, right' then 'top' will be the primary placement and
       * 'center' will be the secondary placement.  If 'auto' is passed, true
       * will be returned as the 3rd value of the array.
       *
       * @param {string} placement - The placement string to parse.
       *
       * @returns {array} An array with the following values
       * <ul>
       *   <li>**[0]**: The primary placement.</li>
       *   <li>**[1]**: The secondary placement.</li>
       *   <li>**[2]**: If auto is passed: true, else undefined.</li>
       * </ul>
       */
      parsePlacement: function(placement) {
        var autoPlace = PLACEMENT_REGEX.auto.test(placement);
        if (autoPlace) {
          placement = placement.replace(PLACEMENT_REGEX.auto, '');
        }

        placement = placement.split('-');

        placement[0] = placement[0] || 'top';
        if (!PLACEMENT_REGEX.primary.test(placement[0])) {
          placement[0] = 'top';
        }

        placement[1] = placement[1] || 'center';
        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
          placement[1] = 'center';
        }

        if (autoPlace) {
          placement[2] = true;
        } else {
          placement[2] = false;
        }

        return placement;
      },

      /**
       * Provides coordinates for an element to be positioned relative to
       * another element.  Passing 'auto' as part of the placement parameter
       * will enable smart placement - where the element fits. i.e:
       * 'auto left-top' will check to see if there is enough space to the left
       * of the hostElem to fit the targetElem, if not place right (same for secondary
       * top placement).  Available space is calculated using the viewportOffset
       * function.
       *
       * @param {element} hostElem - The element to position against.
       * @param {element} targetElem - The element to position.
       * @param {string=} [placement=top] - The placement for the targetElem,
       *   default is 'top'. 'center' is assumed as secondary placement for
       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:
       *   <ul>
       *     <li>top</li>
       *     <li>top-right</li>
       *     <li>top-left</li>
       *     <li>bottom</li>
       *     <li>bottom-left</li>
       *     <li>bottom-right</li>
       *     <li>left</li>
       *     <li>left-top</li>
       *     <li>left-bottom</li>
       *     <li>right</li>
       *     <li>right-top</li>
       *     <li>right-bottom</li>
       *   </ul>
       * @param {boolean=} [appendToBody=false] - Should the top and left values returned
       *   be calculated from the body element, default is false.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**top**: Value for targetElem top.</li>
       *     <li>**left**: Value for targetElem left.</li>
       *     <li>**placement**: The resolved placement.</li>
       *   </ul>
       */
      positionElements: function(hostElem, targetElem, placement, appendToBody) {
        hostElem = this.getRawNode(hostElem);
        targetElem = this.getRawNode(targetElem);

        // need to read from prop to support tests.
        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

        placement = this.parsePlacement(placement);

        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
        var targetElemPos = {top: 0, left: 0, placement: ''};

        if (placement[2]) {
          var viewportOffset = this.viewportOffset(hostElem, appendToBody);

          var targetElemStyle = $window.getComputedStyle(targetElem);
          var adjustedSize = {
            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
          };

          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
                         placement[0];

          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
                         placement[1];

          if (placement[1] === 'center') {
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                placement[1] = 'left';
              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                placement[1] = 'right';
              }
            } else {
              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                placement[1] = 'top';
              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                placement[1] = 'bottom';
              }
            }
          }
        }

        switch (placement[0]) {
          case 'top':
            targetElemPos.top = hostElemPos.top - targetHeight;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left - targetWidth;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width;
            break;
        }

        switch (placement[1]) {
          case 'top':
            targetElemPos.top = hostElemPos.top;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
            break;
          case 'center':
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
            } else {
              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            break;
        }

        targetElemPos.top = Math.round(targetElemPos.top);
        targetElemPos.left = Math.round(targetElemPos.left);
        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

        return targetElemPos;
      },

      /**
       * Provides a way to adjust the top positioning after first
       * render to correctly align element to top after content
       * rendering causes resized element height
       *
       * @param {array} placementClasses - The array of strings of classes
       * element should have.
       * @param {object} containerPosition - The object with container
       * position information
       * @param {number} initialHeight - The initial height for the elem.
       * @param {number} currentHeight - The current height for the elem.
       */
      adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {
        if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {
          return {
            top: containerPosition.top - currentHeight + 'px'
          };
        }
      },

      /**
       * Provides a way for positioning tooltip & dropdown
       * arrows when using placement options beyond the standard
       * left, right, top, or bottom.
       *
       * @param {element} elem - The tooltip/dropdown element.
       * @param {string} placement - The placement for the elem.
       */
      positionArrow: function(elem, placement) {
        elem = this.getRawNode(elem);

        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
        if (!innerElem) {
          return;
        }

        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');

        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
        if (!arrowElem) {
          return;
        }

        var arrowCss = {
          top: '',
          bottom: '',
          left: '',
          right: ''
        };

        placement = this.parsePlacement(placement);
        if (placement[1] === 'center') {
          // no adjustment necessary - just reset styles
          angular.element(arrowElem).css(arrowCss);
          return;
        }

        var borderProp = 'border-' + placement[0] + '-width';
        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

        var borderRadiusProp = 'border-';
        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
          borderRadiusProp += placement[0] + '-' + placement[1];
        } else {
          borderRadiusProp += placement[1] + '-' + placement[0];
        }
        borderRadiusProp += '-radius';
        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

        switch (placement[0]) {
          case 'top':
            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'bottom':
            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'left':
            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'right':
            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
            break;
        }

        arrowCss[placement[1]] = borderRadius;

        angular.element(arrowElem).css(arrowCss);
      }
    };
  }]);

angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])

.value('$datepickerPopupLiteralWarning', true)

.constant('uibDatepickerPopupConfig', {
  altInputFormats: [],
  appendToBody: false,
  clearText: 'Clear',
  closeOnDateSelection: true,
  closeText: 'Done',
  currentText: 'Today',
  datepickerPopup: 'yyyy-MM-dd',
  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
  html5Types: {
    date: 'yyyy-MM-dd',
    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
    'month': 'yyyy-MM'
  },
  onOpenFocus: true,
  showButtonBar: true,
  placement: 'auto bottom-left'
})

.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',
function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
  var cache = {},
    isHtml5DateInput = false;
  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,
    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];

  this.init = function(_ngModel_) {
    ngModel = _ngModel_;
    ngModelOptions = extractOptions(ngModel);
    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?
      $scope.$parent.$eval($attrs.closeOnDateSelection) :
      datepickerPopupConfig.closeOnDateSelection;
    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?
      $scope.$parent.$eval($attrs.datepickerAppendToBody) :
      datepickerPopupConfig.appendToBody;
    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?
      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?
      $attrs.datepickerPopupTemplateUrl :
      datepickerPopupConfig.datepickerPopupTemplateUrl;
    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?
      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
    altInputFormats = angular.isDefined($attrs.altInputFormats) ?
      $scope.$parent.$eval($attrs.altInputFormats) :
      datepickerPopupConfig.altInputFormats;

    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?
      $scope.$parent.$eval($attrs.showButtonBar) :
      datepickerPopupConfig.showButtonBar;

    if (datepickerPopupConfig.html5Types[$attrs.type]) {
      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
      isHtml5DateInput = true;
    } else {
      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
        // Invalidate the $modelValue to ensure that formatters re-run
        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
        if (newDateFormat !== dateFormat) {
          dateFormat = newDateFormat;
          ngModel.$modelValue = null;

          if (!dateFormat) {
            throw new Error('uibDatepickerPopup must have a date format specified.');
          }
        }
      });
    }

    if (!dateFormat) {
      throw new Error('uibDatepickerPopup must have a date format specified.');
    }

    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
      throw new Error('HTML5 date input types do not support custom formats.');
    }

    // popup element used to display calendar
    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');

    popupEl.attr({
      'ng-model': 'date',
      'ng-change': 'dateSelection(date)',
      'template-url': datepickerPopupTemplateUrl
    });

    // datepicker element
    datepickerEl = angular.element(popupEl.children()[0]);
    datepickerEl.attr('template-url', datepickerTemplateUrl);

    if (!$scope.datepickerOptions) {
      $scope.datepickerOptions = {};
    }

    if (isHtml5DateInput) {
      if ($attrs.type === 'month') {
        $scope.datepickerOptions.datepickerMode = 'month';
        $scope.datepickerOptions.minMode = 'month';
      }
    }

    datepickerEl.attr('datepicker-options', 'datepickerOptions');

    if (!isHtml5DateInput) {
      // Internal API to maintain the correct ng-invalid-[key] class
      ngModel.$$parserName = 'date';
      ngModel.$validators.date = validator;
      ngModel.$parsers.unshift(parseDate);
      ngModel.$formatters.push(function(value) {
        if (ngModel.$isEmpty(value)) {
          $scope.date = value;
          return value;
        }

        if (angular.isNumber(value)) {
          value = new Date(value);
        }

        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));

        return dateParser.filter($scope.date, dateFormat);
      });
    } else {
      ngModel.$formatters.push(function(value) {
        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));
        return value;
      });
    }

    // Detect changes in the view from the text box
    ngModel.$viewChangeListeners.push(function() {
      $scope.date = parseDateString(ngModel.$viewValue);
    });

    $element.on('keydown', inputKeydownBind);

    $popup = $compile(popupEl)($scope);
    // Prevent jQuery cache memory leak (template is now redundant after linking)
    popupEl.remove();

    if (appendToBody) {
      $document.find('body').append($popup);
    } else {
      $element.after($popup);
    }

    $scope.$on('$destroy', function() {
      if ($scope.isOpen === true) {
        if (!$rootScope.$$phase) {
          $scope.$apply(function() {
            $scope.isOpen = false;
          });
        }
      }

      $popup.remove();
      $element.off('keydown', inputKeydownBind);
      $document.off('click', documentClickBind);
      if (scrollParentEl) {
        scrollParentEl.off('scroll', positionPopup);
      }
      angular.element($window).off('resize', positionPopup);

      //Clear all watch listeners on destroy
      while (watchListeners.length) {
        watchListeners.shift()();
      }
    });
  };

  $scope.getText = function(key) {
    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
  };

  $scope.isDisabled = function(date) {
    if (date === 'today') {
      date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));
    }

    var dates = {};
    angular.forEach(['minDate', 'maxDate'], function(key) {
      if (!$scope.datepickerOptions[key]) {
        dates[key] = null;
      } else if (angular.isDate($scope.datepickerOptions[key])) {
        dates[key] = new Date($scope.datepickerOptions[key]);
      } else {
        if ($datepickerPopupLiteralWarning) {
          $log.warn('Literal date support has been deprecated, please switch to date object usage');
        }

        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
      }
    });

    return $scope.datepickerOptions &&
      dates.minDate && $scope.compare(date, dates.minDate) < 0 ||
      dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
  };

  $scope.compare = function(date1, date2) {
    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
  };

  // Inner change
  $scope.dateSelection = function(dt) {
    $scope.date = dt;
    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
    $element.val(date);
    ngModel.$setViewValue(date);

    if (closeOnDateSelection) {
      $scope.isOpen = false;
      $element[0].focus();
    }
  };

  $scope.keydown = function(evt) {
    if (evt.which === 27) {
      evt.stopPropagation();
      $scope.isOpen = false;
      $element[0].focus();
    }
  };

  $scope.select = function(date, evt) {
    evt.stopPropagation();

    if (date === 'today') {
      var today = new Date();
      if (angular.isDate($scope.date)) {
        date = new Date($scope.date);
        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
      } else {
        date = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
        date.setHours(0, 0, 0, 0);
      }
    }
    $scope.dateSelection(date);
  };

  $scope.close = function(evt) {
    evt.stopPropagation();

    $scope.isOpen = false;
    $element[0].focus();
  };

  $scope.disabled = angular.isDefined($attrs.disabled) || false;
  if ($attrs.ngDisabled) {
    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
      $scope.disabled = disabled;
    }));
  }

  $scope.$watch('isOpen', function(value) {
    if (value) {
      if (!$scope.disabled) {
        $timeout(function() {
          positionPopup();

          if (onOpenFocus) {
            $scope.$broadcast('uib:datepicker.focus');
          }

          $document.on('click', documentClickBind);

          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
          if (appendToBody || $position.parsePlacement(placement)[2]) {
            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
            if (scrollParentEl) {
              scrollParentEl.on('scroll', positionPopup);
            }
          } else {
            scrollParentEl = null;
          }

          angular.element($window).on('resize', positionPopup);
        }, 0, false);
      } else {
        $scope.isOpen = false;
      }
    } else {
      $document.off('click', documentClickBind);
      if (scrollParentEl) {
        scrollParentEl.off('scroll', positionPopup);
      }
      angular.element($window).off('resize', positionPopup);
    }
  });

  function cameltoDash(string) {
    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
  }

  function parseDateString(viewValue) {
    var date = dateParser.parse(viewValue, dateFormat, $scope.date);
    if (isNaN(date)) {
      for (var i = 0; i < altInputFormats.length; i++) {
        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
        if (!isNaN(date)) {
          return date;
        }
      }
    }
    return date;
  }

  function parseDate(viewValue) {
    if (angular.isNumber(viewValue)) {
      // presumably timestamp to date object
      viewValue = new Date(viewValue);
    }

    if (!viewValue) {
      return null;
    }

    if (angular.isDate(viewValue) && !isNaN(viewValue)) {
      return viewValue;
    }

    if (angular.isString(viewValue)) {
      var date = parseDateString(viewValue);
      if (!isNaN(date)) {
        return dateParser.toTimezone(date, ngModelOptions.getOption('timezone'));
      }
    }

    return ngModelOptions.getOption('allowInvalid') ? viewValue : undefined;
  }

  function validator(modelValue, viewValue) {
    var value = modelValue || viewValue;

    if (!$attrs.ngRequired && !value) {
      return true;
    }

    if (angular.isNumber(value)) {
      value = new Date(value);
    }

    if (!value) {
      return true;
    }

    if (angular.isDate(value) && !isNaN(value)) {
      return true;
    }

    if (angular.isString(value)) {
      return !isNaN(parseDateString(value));
    }

    return false;
  }

  function documentClickBind(event) {
    if (!$scope.isOpen && $scope.disabled) {
      return;
    }

    var popup = $popup[0];
    var dpContainsTarget = $element[0].contains(event.target);
    // The popup node may not be an element node
    // In some browsers (IE) only element nodes have the 'contains' function
    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
      $scope.$apply(function() {
        $scope.isOpen = false;
      });
    }
  }

  function inputKeydownBind(evt) {
    if (evt.which === 27 && $scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.$apply(function() {
        $scope.isOpen = false;
      });
      $element[0].focus();
    } else if (evt.which === 40 && !$scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.$apply(function() {
        $scope.isOpen = true;
      });
    }
  }

  function positionPopup() {
    if ($scope.isOpen) {
      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
      var position = $position.positionElements($element, dpElement, placement, appendToBody);
      dpElement.css({top: position.top + 'px', left: position.left + 'px'});
      if (dpElement.hasClass('uib-position-measure')) {
        dpElement.removeClass('uib-position-measure');
      }
    }
  }

  function extractOptions(ngModelCtrl) {
    var ngModelOptions;

    if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing
      // guarantee a value
      ngModelOptions = angular.isObject(ngModelCtrl.$options) ?
        ngModelCtrl.$options :
        {
          timezone: null
        };

      // mimic 1.6+ api
      ngModelOptions.getOption = function (key) {
        return ngModelOptions[key];
      };
    } else { // in angular >=1.6 $options is always present
      ngModelOptions = ngModelCtrl.$options;
    }

    return ngModelOptions;
  }

  $scope.$on('uib:datepicker.mode', function() {
    $timeout(positionPopup, 0, false);
  });
}])

.directive('uibDatepickerPopup', function() {
  return {
    require: ['ngModel', 'uibDatepickerPopup'],
    controller: 'UibDatepickerPopupController',
    scope: {
      datepickerOptions: '=?',
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@'
    },
    link: function(scope, element, attrs, ctrls) {
      var ngModel = ctrls[0],
        ctrl = ctrls[1];

      ctrl.init(ngModel);
    }
  };
})

.directive('uibDatepickerPopupWrap', function() {
  return {
    restrict: 'A',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
    }
  };
});

angular.module('ui.bootstrap.debounce', [])
/**
 * A helper, internal service that debounces a function
 */
  .factory('$$debounce', ['$timeout', function($timeout) {
    return function(callback, debounceTime) {
      var timeoutPromise;

      return function() {
        var self = this;
        var args = Array.prototype.slice.call(arguments);
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }

        timeoutPromise = $timeout(function() {
          callback.apply(self, args);
        }, debounceTime);
      };
    };
  }]);

angular.module('ui.bootstrap.multiMap', [])
/**
 * A helper, internal data structure that stores all references attached to key
 */
  .factory('$$multiMap', function() {
    return {
      createNew: function() {
        var map = {};

        return {
          entries: function() {
            return Object.keys(map).map(function(key) {
              return {
                key: key,
                value: map[key]
              };
            });
          },
          get: function(key) {
            return map[key];
          },
          hasKey: function(key) {
            return !!map[key];
          },
          keys: function() {
            return Object.keys(map);
          },
          put: function(key, value) {
            if (!map[key]) {
              map[key] = [];
            }

            map[key].push(value);
          },
          remove: function(key, value) {
            var values = map[key];

            if (!values) {
              return;
            }

            var idx = values.indexOf(value);

            if (idx !== -1) {
              values.splice(idx, 1);
            }

            if (!values.length) {
              delete map[key];
            }
          }
        };
      }
    };
  });

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.multiMap', 'ui.bootstrap.position'])

.constant('uibDropdownConfig', {
  appendToOpenClass: 'uib-dropdown-open',
  openClass: 'open'
})

.service('uibDropdownService', ['$document', '$rootScope', '$$multiMap', function($document, $rootScope, $$multiMap) {
  var openScope = null;
  var openedContainers = $$multiMap.createNew();

  this.isOnlyOpen = function(dropdownScope, appendTo) {
    var openedDropdowns = openedContainers.get(appendTo);
    if (openedDropdowns) {
      var openDropdown = openedDropdowns.reduce(function(toClose, dropdown) {
        if (dropdown.scope === dropdownScope) {
          return dropdown;
        }

        return toClose;
      }, {});
      if (openDropdown) {
        return openedDropdowns.length === 1;
      }
    }

    return false;
  };

  this.open = function(dropdownScope, element, appendTo) {
    if (!openScope) {
      $document.on('click', closeDropdown);
    }

    if (openScope && openScope !== dropdownScope) {
      openScope.isOpen = false;
    }

    openScope = dropdownScope;

    if (!appendTo) {
      return;
    }

    var openedDropdowns = openedContainers.get(appendTo);
    if (openedDropdowns) {
      var openedScopes = openedDropdowns.map(function(dropdown) {
        return dropdown.scope;
      });
      if (openedScopes.indexOf(dropdownScope) === -1) {
        openedContainers.put(appendTo, {
          scope: dropdownScope
        });
      }
    } else {
      openedContainers.put(appendTo, {
        scope: dropdownScope
      });
    }
  };

  this.close = function(dropdownScope, element, appendTo) {
    if (openScope === dropdownScope) {
      $document.off('click', closeDropdown);
      $document.off('keydown', this.keybindFilter);
      openScope = null;
    }

    if (!appendTo) {
      return;
    }

    var openedDropdowns = openedContainers.get(appendTo);
    if (openedDropdowns) {
      var dropdownToClose = openedDropdowns.reduce(function(toClose, dropdown) {
        if (dropdown.scope === dropdownScope) {
          return dropdown;
        }

        return toClose;
      }, {});
      if (dropdownToClose) {
        openedContainers.remove(appendTo, dropdownToClose);
      }
    }
  };

  var closeDropdown = function(evt) {
    // This method may still be called during the same mouse event that
    // unbound this event handler. So check openScope before proceeding.
    if (!openScope || !openScope.isOpen) { return; }

    if (evt && openScope.getAutoClose() === 'disabled') { return; }

    if (evt && evt.which === 3) { return; }

    var toggleElement = openScope.getToggleElement();
    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
      return;
    }

    var dropdownElement = openScope.getDropdownElement();
    if (evt && openScope.getAutoClose() === 'outsideClick' &&
      dropdownElement && dropdownElement[0].contains(evt.target)) {
      return;
    }

    openScope.focusToggleElement();
    openScope.isOpen = false;

    if (!$rootScope.$$phase) {
      openScope.$apply();
    }
  };

  this.keybindFilter = function(evt) {
    if (!openScope) {
      // see this.close as ESC could have been pressed which kills the scope so we can not proceed
      return;
    }

    var dropdownElement = openScope.getDropdownElement();
    var toggleElement = openScope.getToggleElement();
    var dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target);
    var toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
    if (evt.which === 27) {
      evt.stopPropagation();
      openScope.focusToggleElement();
      closeDropdown();
    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted)) {
      evt.preventDefault();
      evt.stopPropagation();
      openScope.focusDropdownEntry(evt.which);
    }
  };
}])

.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
  var self = this,
    scope = $scope.$new(), // create a child scope so we are not polluting original one
    templateScope,
    appendToOpenClass = dropdownConfig.appendToOpenClass,
    openClass = dropdownConfig.openClass,
    getIsOpen,
    setIsOpen = angular.noop,
    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
    keynavEnabled = false,
    selectedOption = null,
    body = $document.find('body');

  $element.addClass('dropdown');

  this.init = function() {
    if ($attrs.isOpen) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    keynavEnabled = angular.isDefined($attrs.keyboardNav);
  };

  this.toggle = function(open) {
    scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    if (angular.isFunction(setIsOpen)) {
      setIsOpen(scope, scope.isOpen);
    }

    return scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
  };

  scope.getElement = function() {
    return $element;
  };

  scope.isKeynavEnabled = function() {
    return keynavEnabled;
  };

  scope.focusDropdownEntry = function(keyCode) {
    var elems = self.dropdownMenu ? //If append to body is used.
      angular.element(self.dropdownMenu).find('a') :
      $element.find('ul').eq(0).find('a');

    switch (keyCode) {
      case 40: {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = 0;
        } else {
          self.selectedOption = self.selectedOption === elems.length - 1 ?
            self.selectedOption :
            self.selectedOption + 1;
        }
        break;
      }
      case 38: {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = elems.length - 1;
        } else {
          self.selectedOption = self.selectedOption === 0 ?
            0 : self.selectedOption - 1;
        }
        break;
      }
    }
    elems[self.selectedOption].focus();
  };

  scope.getDropdownElement = function() {
    return self.dropdownMenu;
  };

  scope.focusToggleElement = function() {
    if (self.toggleElement) {
      self.toggleElement[0].focus();
    }
  };

  function removeDropdownMenu() {
    $element.append(self.dropdownMenu);
  }

  scope.$watch('isOpen', function(isOpen, wasOpen) {
    var appendTo = null,
      appendToBody = false;

    if (angular.isDefined($attrs.dropdownAppendTo)) {
      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
      if (appendToEl) {
        appendTo = angular.element(appendToEl);
      }
    }

    if (angular.isDefined($attrs.dropdownAppendToBody)) {
      var appendToBodyValue = $parse($attrs.dropdownAppendToBody)(scope);
      if (appendToBodyValue !== false) {
        appendToBody = true;
      }
    }

    if (appendToBody && !appendTo) {
      appendTo = body;
    }

    if (appendTo && self.dropdownMenu) {
      if (isOpen) {
        appendTo.append(self.dropdownMenu);
        $element.on('$destroy', removeDropdownMenu);
      } else {
        $element.off('$destroy', removeDropdownMenu);
        removeDropdownMenu();
      }
    }

    if (appendTo && self.dropdownMenu) {
      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
        css,
        rightalign,
        scrollbarPadding,
        scrollbarWidth = 0;

      css = {
        top: pos.top + 'px',
        display: isOpen ? 'block' : 'none'
      };

      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
      if (!rightalign) {
        css.left = pos.left + 'px';
        css.right = 'auto';
      } else {
        css.left = 'auto';
        scrollbarPadding = $position.scrollbarPadding(appendTo);

        if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
          scrollbarWidth = scrollbarPadding.scrollbarWidth;
        }

        css.right = window.innerWidth - scrollbarWidth -
          (pos.left + $element.prop('offsetWidth')) + 'px';
      }

      // Need to adjust our positioning to be relative to the appendTo container
      // if it's not the body element
      if (!appendToBody) {
        var appendOffset = $position.offset(appendTo);

        css.top = pos.top - appendOffset.top + 'px';

        if (!rightalign) {
          css.left = pos.left - appendOffset.left + 'px';
        } else {
          css.right = window.innerWidth -
            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
        }
      }

      self.dropdownMenu.css(css);
    }

    var openContainer = appendTo ? appendTo : $element;
    var dropdownOpenClass = appendTo ? appendToOpenClass : openClass;
    var hasOpenClass = openContainer.hasClass(dropdownOpenClass);
    var isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);

    if (hasOpenClass === !isOpen) {
      var toggleClass;
      if (appendTo) {
        toggleClass = !isOnlyOpen ? 'addClass' : 'removeClass';
      } else {
        toggleClass = isOpen ? 'addClass' : 'removeClass';
      }
      $animate[toggleClass](openContainer, dropdownOpenClass).then(function() {
        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
          toggleInvoker($scope, { open: !!isOpen });
        }
      });
    }

    if (isOpen) {
      if (self.dropdownMenuTemplateUrl) {
        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
          templateScope = scope.$new();
          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
            var newEl = dropdownElement;
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
            $document.on('keydown', uibDropdownService.keybindFilter);
          });
        });
      } else {
        $document.on('keydown', uibDropdownService.keybindFilter);
      }

      scope.focusToggleElement();
      uibDropdownService.open(scope, $element, appendTo);
    } else {
      uibDropdownService.close(scope, $element, appendTo);
      if (self.dropdownMenuTemplateUrl) {
        if (templateScope) {
          templateScope.$destroy();
        }
        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
        self.dropdownMenu.replaceWith(newEl);
        self.dropdownMenu = newEl;
      }

      self.selectedOption = null;
    }

    if (angular.isFunction(setIsOpen)) {
      setIsOpen($scope, isOpen);
    }
  });
}])

.directive('uibDropdown', function() {
  return {
    controller: 'UibDropdownController',
    link: function(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init();
    }
  };
})

.directive('uibDropdownMenu', function() {
  return {
    restrict: 'A',
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
        return;
      }

      element.addClass('dropdown-menu');

      var tplUrl = attrs.templateUrl;
      if (tplUrl) {
        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
      }

      if (!dropdownCtrl.dropdownMenu) {
        dropdownCtrl.dropdownMenu = element;
      }
    }
  };
})

.directive('uibDropdownToggle', function() {
  return {
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl) {
        return;
      }

      element.addClass('dropdown-toggle');

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if (!element.hasClass('disabled') && !attrs.disabled) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.on('click', toggleDropdown);

      // WAI-ARIA
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function() {
        element.off('click', toggleDropdown);
      });
    }
  };
});

angular.module('ui.bootstrap.stackedMap', [])
/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function() {
    return {
      createNew: function() {
        var stack = [];

        return {
          add: function(key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function(key) {
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function() {
            return stack[stack.length - 1];
          },
          remove: function(key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function() {
            return stack.pop();
          },
          length: function() {
            return stack.length;
          }
        };
      }
    };
  });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.multiMap', 'ui.bootstrap.stackedMap', 'ui.bootstrap.position'])
/**
 * Pluggable resolve mechanism for the modal resolve resolution
 * Supports UI Router's $resolve service
 */
  .provider('$uibResolve', function() {
    var resolve = this;
    this.resolver = null;

    this.setResolver = function(resolver) {
      this.resolver = resolver;
    };

    this.$get = ['$injector', '$q', function($injector, $q) {
      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
      return {
        resolve: function(invocables, locals, parent, self) {
          if (resolver) {
            return resolver.resolve(invocables, locals, parent, self);
          }

          var promises = [];

          angular.forEach(invocables, function(value) {
            if (angular.isFunction(value) || angular.isArray(value)) {
              promises.push($q.resolve($injector.invoke(value)));
            } else if (angular.isString(value)) {
              promises.push($q.resolve($injector.get(value)));
            } else {
              promises.push($q.resolve(value));
            }
          });

          return $q.all(promises).then(function(resolves) {
            var resolveObj = {};
            var resolveIter = 0;
            angular.forEach(invocables, function(value, key) {
              resolveObj[key] = resolves[resolveIter++];
            });

            return resolveObj;
          });
        }
      };
    }];
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',
  function($animate, $injector, $modalStack) {
    return {
      restrict: 'A',
      compile: function(tElement, tAttrs) {
        tElement.addClass(tAttrs.backdropClass);
        return linkFn;
      }
    };

    function linkFn(scope, element, attrs) {
      if (attrs.modalInClass) {
        $animate.addClass(element, attrs.modalInClass);

        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
          var done = setIsAsync();
          if (scope.modalOptions.animation) {
            $animate.removeClass(element, attrs.modalInClass).then(done);
          } else {
            done();
          }
        });
      }
    }
  }])

  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',
  function($modalStack, $q, $animateCss, $document) {
    return {
      scope: {
        index: '@'
      },
      restrict: 'A',
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || 'uib/template/modal/window.html';
      },
      link: function(scope, element, attrs) {
        element.addClass(attrs.windowTopClass || '');
        scope.size = attrs.size;

        scope.close = function(evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop &&
            modal.value.backdrop !== 'static' &&
            evt.target === evt.currentTarget) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };

        // moved from template to fix issue #2280
        element.on('click', scope.close);

        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
        // We can detect that by using this property in the template associated with this directive and then use
        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
        scope.$isRendered = true;

        // Deferred object that will be resolved when this modal is rendered.
        var modalRenderDeferObj = $q.defer();
        // Resolve render promise post-digest
        scope.$$postDigest(function() {
          modalRenderDeferObj.resolve();
        });

        modalRenderDeferObj.promise.then(function() {
          var animationPromise = null;

          if (attrs.modalInClass) {
            animationPromise = $animateCss(element, {
              addClass: attrs.modalInClass
            }).start();

            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
              var done = setIsAsync();
              $animateCss(element, {
                removeClass: attrs.modalInClass
              }).start().then(done);
            });
          }


          $q.when(animationPromise).then(function() {
            // Notify {@link $modalStack} that modal is rendered.
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }

            /**
             * If something within the freshly-opened modal already has focus (perhaps via a
             * directive that causes focus) then there's no need to try to focus anything.
             */
            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
              var inputWithAutofocus = element[0].querySelector('[autofocus]');
              /**
               * Auto-focusing of a freshly-opened modal element causes any child elements
               * with the autofocus attribute to lose focus. This is an issue on touch
               * based devices which will show and then hide the onscreen keyboard.
               * Attempts to refocus the autofocus element via JavaScript will not reopen
               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
               * the modal element if the modal does not contain an autofocus element.
               */
              if (inputWithAutofocus) {
                inputWithAutofocus.focus();
              } else {
                element[0].focus();
              }
            }
          });
        });
      }
    };
  }])

  .directive('uibModalAnimationClass', function() {
    return {
      compile: function(tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      }
    };
  })

  .directive('uibModalTransclude', ['$animate', function($animate) {
    return {
      link: function(scope, element, attrs, controller, transclude) {
        transclude(scope.$parent, function(clone) {
          element.empty();
          $animate.enter(clone, element);
        });
      }
    };
  }])

  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',
    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
      var OPENED_MODAL_CLASS = 'modal-open';

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
      };
      var topModalIndex = 0;
      var previousTopOpenedModal = null;
      var ARIA_HIDDEN_ATTRIBUTE_NAME = 'data-bootstrap-modal-aria-hidden-count';

      //Modal focus behavior
      var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' +
        'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' +
        'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
      var scrollbarPadding;
      var SNAKE_CASE_REGEXP = /[A-Z]/g;

      // TODO: extract into common dependency with tooltip
      function snake_case(name) {
        var separator = '-';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }

      function isVisible(element) {
        return !!(element.offsetWidth ||
          element.offsetHeight ||
          element.getClientRects().length);
      }

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }

        // If any backdrop exist, ensure that it's index is always
        // right below the top modal
        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
          topBackdropIndex = topModalIndex;
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;

        //clean up the stack
        openedWindows.remove(modalInstance);
        previousTopOpenedModal = openedWindows.top();
        if (previousTopOpenedModal) {
          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
        }

        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          var areAnyOpen = openedClasses.hasKey(modalBodyClass);
          appendToElement.toggleClass(modalBodyClass, areAnyOpen);
          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
            if (scrollbarPadding.originalRight) {
              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});
            } else {
              appendToElement.css({paddingRight: ''});
            }
            scrollbarPadding = null;
          }
          toggleTopWindowClass(true);
        }, modalWindow.closedDeferred);
        checkRemoveBackdrop();

        //move focus to specified element if available, or else to body
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }

      // Add or remove "windowTopClass" from the top window in the stack
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;

        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }

      function checkRemoveBackdrop() {
        //remove backdrop if no longer needed
        if (backdropDomEl && backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }

      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }

          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

        // Note that it's intentional that asyncPromise might be null.
        // That's when setIsAsync has not been called during the
        // NOW_CLOSING_EVENT broadcast.
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          $animate.leave(domEl).then(function() {
            if (done) {
              done();
            }

            domEl.remove();
            if (closedDeferred) {
              closedDeferred.resolve();
            }
          });

          scope.$destroy();
        }
      }

      $document.on('keydown', keydownListener);

      $rootScope.$on('$destroy', function() {
        $document.off('keydown', keydownListener);
      });

      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }

        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27: {
              if (modal.value.keyboard) {
                evt.preventDefault();
                $rootScope.$apply(function() {
                  $modalStack.dismiss(modal.key, 'escape key press');
                });
              }
              break;
            }
            case 9: {
              var list = $modalStack.loadFocusElementList(modal);
              var focusChanged = false;
              if (evt.shiftKey) {
                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                  focusChanged = $modalStack.focusLastFocusableElement(list);
                }
              } else {
                if ($modalStack.isFocusInLastItem(evt, list)) {
                  focusChanged = $modalStack.focusFirstFocusableElement(list);
                }
              }

              if (focusChanged) {
                evt.preventDefault();
                evt.stopPropagation();
              }

              break;
            }
          }
        }
      }

      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

        toggleTopWindowClass(false);

        // Store the current top first, to determine what index we ought to use
        // for the current top modal
        previousTopOpenedModal = openedWindows.top();

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo
        });

        openedClasses.put(modalBodyClass, modalInstance);

        var appendToElement = modal.appendTo,
            currBackdropIndex = backdropIndex();

        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          backdropDomEl.attr({
            'class': 'modal-backdrop',
            'ng-style': '{\'z-index\': 1040 + (index && 1 || 0) + index*10}',
            'uib-modal-animation-class': 'fade',
            'modal-in-class': 'in'
          });
          if (modal.backdropClass) {
            backdropDomEl.addClass(modal.backdropClass);
          }

          if (modal.animation) {
            backdropDomEl.attr('modal-animation', 'true');
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
          if ($uibPosition.isScrollable(appendToElement)) {
            scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
            if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
              appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});
            }
          }
        }

        var content;
        if (modal.component) {
          content = document.createElement(snake_case(modal.component.name));
          content = angular.element(content);
          content.attr({
            resolve: '$resolve',
            'modal-instance': '$uibModalInstance',
            close: '$close($value)',
            dismiss: '$dismiss($value)'
          });
        } else {
          content = modal.content;
        }

        // Set the top modal index based on the index of the previous top modal
        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'class': 'modal',
          'template-url': modal.windowTemplateUrl,
          'window-top-class': modal.windowTopClass,
          'role': 'dialog',
          'aria-labelledby': modal.ariaLabelledBy,
          'aria-describedby': modal.ariaDescribedBy,
          'size': modal.size,
          'index': topModalIndex,
          'animate': 'animate',
          'ng-style': '{\'z-index\': 1050 + $$topModalIndex*10, display: \'block\'}',
          'tabindex': -1,
          'uib-modal-animation-class': 'fade',
          'modal-in-class': 'in'
        }).append(content);
        if (modal.windowClass) {
          angularDomEl.addClass(modal.windowClass);
        }

        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }

        appendToElement.addClass(modalBodyClass);
        if (modal.scope) {
          // we need to explicitly add the modal index to the modal scope
          // because it is needed by ngStyle to compute the zIndex property.
          modal.scope.$$topModalIndex = topModalIndex;
        }
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);

        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;

        applyAriaHidden(angularDomEl);

        function applyAriaHidden(el) {
          if (!el || el[0].tagName === 'BODY') {
            return;
          }

          getSiblings(el).forEach(function(sibling) {
            var elemIsAlreadyHidden = sibling.getAttribute('aria-hidden') === 'true',
              ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);

            if (!ariaHiddenCount) {
              ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;
            }

            sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1);
            sibling.setAttribute('aria-hidden', 'true');
          });

          return applyAriaHidden(el.parent());

          function getSiblings(el) {
            var children = el.parent() ? el.parent().children() : [];

            return Array.prototype.filter.call(children, function(child) {
              return child !== el[0];
            });
          }
        }
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }

      function unhideBackgroundElements() {
        Array.prototype.forEach.call(
          document.querySelectorAll('[' + ARIA_HIDDEN_ATTRIBUTE_NAME + ']'),
          function(hiddenEl) {
            var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10),
              newHiddenCount = ariaHiddenCount - 1;
            hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);

            if (!newHiddenCount) {
              hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);
              hiddenEl.removeAttribute('aria-hidden');
            }
          }
        );
      }

      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        unhideBackgroundElements();
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }

        return !modalWindow;
      };

      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        unhideBackgroundElements();
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function() {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      $modalStack.focusFirstFocusableElement = function(list) {
        if (list.length > 0) {
          list[0].focus();
          return true;
        }
        return false;
      };

      $modalStack.focusLastFocusableElement = function(list) {
        if (list.length > 0) {
          list[list.length - 1].focus();
          return true;
        }
        return false;
      };

      $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl && modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };

      $modalStack.isFocusInFirstItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[0];
        }
        return false;
      };

      $modalStack.isFocusInLastItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[list.length - 1];
        }
        return false;
      };

      $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
          var modalDomE1 = modalWindow.value.modalDomEl;
          if (modalDomE1 && modalDomE1.length) {
            var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
            return elements ?
              Array.prototype.filter.call(elements, function(element) {
                return isVisible(element);
              }) : elements;
          }
        }
      };

      return $modalStack;
    }])

  .provider('$uibModal', function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true, //can also be false or 'static'
        keyboard: true
      },
      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ?
                options.templateUrl() : options.templateUrl);
          }

          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };

          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              closed: modalClosedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function (result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

            if (!modalOptions.appendTo.length) {
              throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
            }

            //verify options
            if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of component or template or templateUrl options is required.');
            }

            var templateAndResolvePromise;
            if (modalOptions.component) {
              templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));
            } else {
              templateAndResolvePromise =
                $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
            }

            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }

            // Wait for the resolution of the existing promise chain.
            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
            // Then add to $modalStack and resolve opened.
            // Finally clean up the chain variable if no subsequent modal has overwritten it.
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain])
              .then(resolveWithTemplate, resolveWithTemplate)
              .then(function resolveSuccess(tplAndVars) {
                var providedScope = modalOptions.scope || $rootScope;

                var modalScope = providedScope.$new();
                modalScope.$close = modalInstance.close;
                modalScope.$dismiss = modalInstance.dismiss;

                modalScope.$on('$destroy', function() {
                  if (!modalScope.$$uibDestructionScheduled) {
                    modalScope.$dismiss('$uibUnscheduledDestruction');
                  }
                });

                var modal = {
                  scope: modalScope,
                  deferred: modalResultDeferred,
                  renderDeferred: modalRenderDeferred,
                  closedDeferred: modalClosedDeferred,
                  animation: modalOptions.animation,
                  backdrop: modalOptions.backdrop,
                  keyboard: modalOptions.keyboard,
                  backdropClass: modalOptions.backdropClass,
                  windowTopClass: modalOptions.windowTopClass,
                  windowClass: modalOptions.windowClass,
                  windowTemplateUrl: modalOptions.windowTemplateUrl,
                  ariaLabelledBy: modalOptions.ariaLabelledBy,
                  ariaDescribedBy: modalOptions.ariaDescribedBy,
                  size: modalOptions.size,
                  openedClass: modalOptions.openedClass,
                  appendTo: modalOptions.appendTo
                };

                var component = {};
                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};

                if (modalOptions.component) {
                  constructLocals(component, false, true, false);
                  component.name = modalOptions.component;
                  modal.component = component;
                } else if (modalOptions.controller) {
                  constructLocals(ctrlLocals, true, false, true);

                  // the third param will make the controller instantiate later,private api
                  // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126
                  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
                  if (modalOptions.controllerAs && modalOptions.bindToController) {
                    ctrlInstance = ctrlInstantiate.instance;
                    ctrlInstance.$close = modalScope.$close;
                    ctrlInstance.$dismiss = modalScope.$dismiss;
                    angular.extend(ctrlInstance, {
                      $resolve: ctrlLocals.$scope.$resolve
                    }, providedScope);
                  }

                  ctrlInstance = ctrlInstantiate();

                  if (angular.isFunction(ctrlInstance.$onInit)) {
                    ctrlInstance.$onInit();
                  }
                }

                if (!modalOptions.component) {
                  modal.content = tplAndVars[0];
                }

                $modalStack.open(modalInstance, modal);
                modalOpenedDeferred.resolve(true);

                function constructLocals(obj, template, instanceOnScope, injectable) {
                  obj.$scope = modalScope;
                  obj.$scope.$resolve = {};
                  if (instanceOnScope) {
                    obj.$scope.$uibModalInstance = modalInstance;
                  } else {
                    obj.$uibModalInstance = modalInstance;
                  }

                  var resolves = template ? tplAndVars[1] : tplAndVars;
                  angular.forEach(resolves, function(value, key) {
                    if (injectable) {
                      obj[key] = value;
                    }

                    obj.$scope.$resolve[key] = value;
                  });
                }
            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            })['finally'](function() {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });

            return modalInstance;
          };

          return $modal;
        }
      ]
    };

    return $modalProvider;
  });

angular.module('ui.bootstrap.paging', [])
/**
 * Helper internal service for generating common controller code between the
 * pager and pagination components
 */
.factory('uibPaging', ['$parse', function($parse) {
  return {
    create: function(ctrl, $scope, $attrs) {
      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl
      ctrl._watchers = [];

      ctrl.init = function(ngModelCtrl, config) {
        ctrl.ngModelCtrl = ngModelCtrl;
        ctrl.config = config;

        ngModelCtrl.$render = function() {
          ctrl.render();
        };

        if ($attrs.itemsPerPage) {
          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
            ctrl.itemsPerPage = parseInt(value, 10);
            $scope.totalPages = ctrl.calculateTotalPages();
            ctrl.updatePage();
          }));
        } else {
          ctrl.itemsPerPage = config.itemsPerPage;
        }

        $scope.$watch('totalItems', function(newTotal, oldTotal) {
          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
            $scope.totalPages = ctrl.calculateTotalPages();
            ctrl.updatePage();
          }
        });
      };

      ctrl.calculateTotalPages = function() {
        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
        return Math.max(totalPages || 0, 1);
      };

      ctrl.render = function() {
        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
      };

      $scope.selectPage = function(page, evt) {
        if (evt) {
          evt.preventDefault();
        }

        var clickAllowed = !$scope.ngDisabled || !evt;
        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
          if (evt && evt.target) {
            evt.target.blur();
          }
          ctrl.ngModelCtrl.$setViewValue(page);
          ctrl.ngModelCtrl.$render();
        }
      };

      $scope.getText = function(key) {
        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
      };

      $scope.noPrevious = function() {
        return $scope.page === 1;
      };

      $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
      };

      ctrl.updatePage = function() {
        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable

        if ($scope.page > $scope.totalPages) {
          $scope.selectPage($scope.totalPages);
        } else {
          ctrl.ngModelCtrl.$render();
        }
      };

      $scope.$on('$destroy', function() {
        while (ctrl._watchers.length) {
          ctrl._watchers.shift()();
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])

.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

  uibPaging.create(this, $scope, $attrs);
}])

.constant('uibPagerConfig', {
  itemsPerPage: 10,
  previousText: ' Previous',
  nextText: 'Next ',
  align: true
})

.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
  return {
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@',
      ngDisabled: '='
    },
    require: ['uibPager', '?ngModel'],
    restrict: 'A',
    controller: 'UibPagerController',
    controllerAs: 'pager',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/pager/pager.html';
    },
    link: function(scope, element, attrs, ctrls) {
      element.addClass('pager');
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
        return; // do nothing if no ng-model
      }

      paginationCtrl.init(ngModelCtrl, uibPagerConfig);
    }
  };
}]);

angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])
.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
  var ctrl = this;
  // Setup configuration parameters
  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;
  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
  $attrs.$set('role', 'menu');

  uibPaging.create(this, $scope, $attrs);

  if ($attrs.maxSize) {
    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
      maxSize = parseInt(value, 10);
      ctrl.render();
    }));
  }

  // Create page object used in template
  function makePage(number, text, isActive) {
    return {
      number: number,
      text: text,
      active: isActive
    };
  }

  function getPages(currentPage, totalPages) {
    var pages = [];

    // Default page limits
    var startPage = 1, endPage = totalPages;
    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

    // recompute if maxSize
    if (isMaxSized) {
      if (rotate) {
        // Current page is displayed in the middle of the visible ones
        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
        endPage = startPage + maxSize - 1;

        // Adjust if limit is exceeded
        if (endPage > totalPages) {
          endPage = totalPages;
          startPage = endPage - maxSize + 1;
        }
      } else {
        // Visible pages are paginated with maxSize
        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

        // Adjust last page if limit is exceeded
        endPage = Math.min(startPage + maxSize - 1, totalPages);
      }
    }

    // Add page number links
    for (var number = startPage; number <= endPage; number++) {
      var page = makePage(number, pageLabel(number), number === currentPage);
      pages.push(page);
    }

    // Add links to move between page sets
    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
      if (startPage > 1) {
        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning
        var previousPageSet = makePage(startPage - 1, '...', false);
        pages.unshift(previousPageSet);
      }
        if (boundaryLinkNumbers) {
          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential
            var secondPageLink = makePage(2, '2', false);
            pages.unshift(secondPageLink);
          }
          //add the first page
          var firstPageLink = makePage(1, '1', false);
          pages.unshift(firstPageLink);
        }
      }

      if (endPage < totalPages) {
        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end
        var nextPageSet = makePage(endPage + 1, '...', false);
        pages.push(nextPageSet);
      }
        if (boundaryLinkNumbers) {
          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential
            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
            pages.push(secondToLastPageLink);
          }
          //add the last page
          var lastPageLink = makePage(totalPages, totalPages, false);
          pages.push(lastPageLink);
        }
      }
    }
    return pages;
  }

  var originalRender = this.render;
  this.render = function() {
    originalRender();
    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
      $scope.pages = getPages($scope.page, $scope.totalPages);
    }
  };
}])

.constant('uibPaginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  boundaryLinkNumbers: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true,
  forceEllipses: false
})

.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
  return {
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@',
      ngDisabled:'='
    },
    require: ['uibPagination', '?ngModel'],
    restrict: 'A',
    controller: 'UibPaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/pagination/pagination.html';
    },
    link: function(scope, element, attrs, ctrls) {
      element.addClass('pagination');
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider('$uibTooltip', function() {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    placementClassPrefix: '',
    animation: true,
    popupDelay: 0,
    popupCloseDelay: 0,
    useContentExp: false
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'outsideClick': 'outsideClick',
    'focus': 'blur',
    'none': ''
  };

  // The options specified to the provider globally.
  var globalOptions = {};

  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function(value) {
		angular.extend(globalOptions, value);
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );
   */
  this.setTriggers = function setTriggers(triggers) {
    angular.extend(triggerMap, triggers);
  };

  /**
   * This is a helper function for translating camel-case to snake_case.
   */
  function snake_case(name) {
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
    var openedTooltips = $$stackedMap.createNew();
    $document.on('keyup', keypressListener);

    $rootScope.$on('$destroy', function() {
      $document.off('keyup', keypressListener);
    });

    function keypressListener(e) {
      if (e.which === 27) {
        var last = openedTooltips.top();
        if (last) {
          last.value.close();
          last = null;
        }
      }
    }

    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
      options = angular.extend({}, defaultOptions, globalOptions, options);

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers(trigger) {
        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
        var hide = show.map(function(trigger) {
          return triggerMap[trigger] || trigger;
        });
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case(ttType);

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template =
        '<div '+ directiveName + '-popup ' +
          'uib-title="' + startSym + 'title' + endSym + '" ' +
          (options.useContentExp ?
            'content-exp="contentExp()" ' :
            'content="' + startSym + 'content' + endSym + '" ') +
          'origin-scope="origScope" ' +
          'class="uib-position-measure ' + prefix + '" ' +
          'tooltip-animation-class="fade"' +
          'uib-tooltip-classes ' +
          'ng-class="{ in: isOpen }" ' +
          '>' +
        '</div>';

      return {
        compile: function(tElem, tAttrs) {
          var tooltipLinker = $compile(template);

          return function link(scope, element, attrs, tooltipCtrl) {
            var tooltip;
            var tooltipLinkedScope;
            var transitionTimeout;
            var showTimeout;
            var hideTimeout;
            var positionTimeout;
            var adjustmentTimeout;
            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
            var triggers = getTriggers(undefined);
            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
            var ttScope = scope.$new(true);
            var repositionScheduled = false;
            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
            var observers = [];
            var lastPlacement;

            var positionTooltip = function() {
              // check if tooltip exists and is not empty
              if (!tooltip || !tooltip.html()) { return; }

              if (!positionTimeout) {
                positionTimeout = $timeout(function() {
                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                  var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                  var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
                  var placementClasses = ttPosition.placement.split('-');

                  if (!tooltip.hasClass(placementClasses[0])) {
                    tooltip.removeClass(lastPlacement.split('-')[0]);
                    tooltip.addClass(placementClasses[0]);
                  }

                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                  }

                  adjustmentTimeout = $timeout(function() {
                    var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                    var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                    if (adjustment) {
                      tooltip.css(adjustment);
                    }
                    adjustmentTimeout = null;
                  }, 0, false);

                  // first time through tt element will have the
                  // uib-position-measure class or if the placement
                  // has changed we need to position the arrow.
                  if (tooltip.hasClass('uib-position-measure')) {
                    $position.positionArrow(tooltip, ttPosition.placement);
                    tooltip.removeClass('uib-position-measure');
                  } else if (lastPlacement !== ttPosition.placement) {
                    $position.positionArrow(tooltip, ttPosition.placement);
                  }
                  lastPlacement = ttPosition.placement;

                  positionTimeout = null;
                }, 0, false);
              }
            };

            // Set up the correct scope to allow transclusion later
            ttScope.origScope = scope;

            // By default, the tooltip is not open.
            // TODO add ability to start tooltip opened
            ttScope.isOpen = false;

            function toggleTooltipBind() {
              if (!ttScope.isOpen) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            // Show the tooltip with delay if specified, otherwise show it immediately
            function showTooltipBind() {
              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                return;
              }

              cancelHide();
              prepareTooltip();

              if (ttScope.popupDelay) {
                // Do nothing if the tooltip was already scheduled to pop-up.
                // This happens if show is triggered multiple times before any hide is triggered.
                if (!showTimeout) {
                  showTimeout = $timeout(show, ttScope.popupDelay, false);
                }
              } else {
                show();
              }
            }

            function hideTooltipBind() {
              cancelShow();

              if (ttScope.popupCloseDelay) {
                if (!hideTimeout) {
                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                }
              } else {
                hide();
              }
            }

            // Show the tooltip popup element.
            function show() {
              cancelShow();
              cancelHide();

              // Don't show empty tooltips.
              if (!ttScope.content) {
                return angular.noop;
              }

              createTooltip();

              // And show the tooltip.
              ttScope.$evalAsync(function() {
                ttScope.isOpen = true;
                assignIsOpen(true);
                positionTooltip();
              });
            }

            function cancelShow() {
              if (showTimeout) {
                $timeout.cancel(showTimeout);
                showTimeout = null;
              }

              if (positionTimeout) {
                $timeout.cancel(positionTimeout);
                positionTimeout = null;
              }
            }

            // Hide the tooltip popup element.
            function hide() {
              if (!ttScope) {
                return;
              }

              // First things first: we don't show it anymore.
              ttScope.$evalAsync(function() {
                if (ttScope) {
                  ttScope.isOpen = false;
                  assignIsOpen(false);
                  // And now we remove it from the DOM. However, if we have animation, we
                  // need to wait for it to expire beforehand.
                  // FIXME: this is a placeholder for a port of the transitions library.
                  // The fade transition in TWBS is 150ms.
                  if (ttScope.animation) {
                    if (!transitionTimeout) {
                      transitionTimeout = $timeout(removeTooltip, 150, false);
                    }
                  } else {
                    removeTooltip();
                  }
                }
              });
            }

            function cancelHide() {
              if (hideTimeout) {
                $timeout.cancel(hideTimeout);
                hideTimeout = null;
              }

              if (transitionTimeout) {
                $timeout.cancel(transitionTimeout);
                transitionTimeout = null;
              }
            }

            function createTooltip() {
              // There can only be one tooltip element per directive shown at once.
              if (tooltip) {
                return;
              }

              tooltipLinkedScope = ttScope.$new();
              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                if (appendToBody) {
                  $document.find('body').append(tooltip);
                } else {
                  element.after(tooltip);
                }
              });

              openedTooltips.add(ttScope, {
                close: hide
              });

              prepObservers();
            }

            function removeTooltip() {
              cancelShow();
              cancelHide();
              unregisterObservers();

              if (tooltip) {
                tooltip.remove();
                
                tooltip = null;
                if (adjustmentTimeout) {
                  $timeout.cancel(adjustmentTimeout);
                }
              }

              openedTooltips.remove(ttScope);
              
              if (tooltipLinkedScope) {
                tooltipLinkedScope.$destroy();
                tooltipLinkedScope = null;
              }
            }

            /**
             * Set the initial scope values. Once
             * the tooltip is created, the observers
             * will be added to keep things in sync.
             */
            function prepareTooltip() {
              ttScope.title = attrs[prefix + 'Title'];
              if (contentParse) {
                ttScope.content = contentParse(scope);
              } else {
                ttScope.content = attrs[ttType];
              }

              ttScope.popupClass = attrs[prefix + 'Class'];
              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
              var placement = $position.parsePlacement(ttScope.placement);
              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];

              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
            }

            function assignIsOpen(isOpen) {
              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                isOpenParse.assign(scope, isOpen);
              }
            }

            ttScope.contentExp = function() {
              return ttScope.content;
            };

            /**
             * Observe the relevant attributes.
             */
            attrs.$observe('disabled', function(val) {
              if (val) {
                cancelShow();
              }

              if (val && ttScope.isOpen) {
                hide();
              }
            });

            if (isOpenParse) {
              scope.$watch(isOpenParse, function(val) {
                if (ttScope && !val === ttScope.isOpen) {
                  toggleTooltipBind();
                }
              });
            }

            function prepObservers() {
              observers.length = 0;

              if (contentParse) {
                observers.push(
                  scope.$watch(contentParse, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    }
                  })
                );

                observers.push(
                  tooltipLinkedScope.$watch(function() {
                    if (!repositionScheduled) {
                      repositionScheduled = true;
                      tooltipLinkedScope.$$postDigest(function() {
                        repositionScheduled = false;
                        if (ttScope && ttScope.isOpen) {
                          positionTooltip();
                        }
                      });
                    }
                  })
                );
              } else {
                observers.push(
                  attrs.$observe(ttType, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    } else {
                      positionTooltip();
                    }
                  })
                );
              }

              observers.push(
                attrs.$observe(prefix + 'Title', function(val) {
                  ttScope.title = val;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );

              observers.push(
                attrs.$observe(prefix + 'Placement', function(val) {
                  ttScope.placement = val ? val : options.placement;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );
            }

            function unregisterObservers() {
              if (observers.length) {
                angular.forEach(observers, function(observer) {
                  observer();
                });
                observers.length = 0;
              }
            }

            // hide tooltips/popovers for outsideClick trigger
            function bodyHideTooltipBind(e) {
              if (!ttScope || !ttScope.isOpen || !tooltip) {
                return;
              }
              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked
              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                hideTooltipBind();
              }
            }

            // KeyboardEvent handler to hide the tooltip on Escape key press
            function hideOnEscapeKey(e) {
              if (e.which === 27) {
                hideTooltipBind();
              }
            }

            var unregisterTriggers = function() {
              triggers.show.forEach(function(trigger) {
                if (trigger === 'outsideClick') {
                  element.off('click', toggleTooltipBind);
                } else {
                  element.off(trigger, showTooltipBind);
                  element.off(trigger, toggleTooltipBind);
                }
                element.off('keypress', hideOnEscapeKey);
              });
              triggers.hide.forEach(function(trigger) {
                if (trigger === 'outsideClick') {
                  $document.off('click', bodyHideTooltipBind);
                } else {
                  element.off(trigger, hideTooltipBind);
                }
              });
            };

            function prepTriggers() {
              var showTriggers = [], hideTriggers = [];
              var val = scope.$eval(attrs[prefix + 'Trigger']);
              unregisterTriggers();

              if (angular.isObject(val)) {
                Object.keys(val).forEach(function(key) {
                  showTriggers.push(key);
                  hideTriggers.push(val[key]);
                });
                triggers = {
                  show: showTriggers,
                  hide: hideTriggers
                };
              } else {
                triggers = getTriggers(val);
              }

              if (triggers.show !== 'none') {
                triggers.show.forEach(function(trigger, idx) {
                  if (trigger === 'outsideClick') {
                    element.on('click', toggleTooltipBind);
                    $document.on('click', bodyHideTooltipBind);
                  } else if (trigger === triggers.hide[idx]) {
                    element.on(trigger, toggleTooltipBind);
                  } else if (trigger) {
                    element.on(trigger, showTooltipBind);
                    element.on(triggers.hide[idx], hideTooltipBind);
                  }
                  element.on('keypress', hideOnEscapeKey);
                });
              }
            }

            prepTriggers();

            var animation = scope.$eval(attrs[prefix + 'Animation']);
            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

            var appendToBodyVal;
            var appendKey = prefix + 'AppendToBody';
            if (appendKey in attrs && attrs[appendKey] === undefined) {
              appendToBodyVal = true;
            } else {
              appendToBodyVal = scope.$eval(attrs[appendKey]);
            }

            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

            // Make sure tooltip is destroyed and removed.
            scope.$on('$destroy', function onDestroyTooltip() {
              unregisterTriggers();
              removeTooltip();
              ttScope = null;
            });
          };
        }
      };
    };
  }];
})

// This is mostly ngInclude code but with a custom scope
.directive('uibTooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest',
function ($animate, $sce, $compile, $templateRequest) {
  return {
    link: function(scope, elem, attrs) {
      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }

        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }

        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit('$includeContentLoaded', src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit('$includeContentError', src);
            }
          });
          scope.$emit('$includeContentRequested', src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on('$destroy', cleanupLastIncludeContent);
    }
  };
}])

/**
 * Note that it's intentional that these classes are *not* applied through $animate.
 * They must not be animated as they're expected to be present on the tooltip on
 * initialization.
 */
.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      // need to set the primary position so the
      // arrow has space during position measure.
      // tooltip.positionTooltip()
      if (scope.placement) {
        // // There are no top-left etc... classes
        // // in TWBS, so we need the primary position.
        var position = $uibPosition.parsePlacement(scope.placement);
        element.addClass(position[0]);
      }

      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }

      if (scope.animation) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
}])

.directive('uibTooltipPopup', function() {
  return {
    restrict: 'A',
    scope: { content: '@' },
    templateUrl: 'uib/template/tooltip/tooltip-popup.html'
  };
})

.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
}])

.directive('uibTooltipTemplatePopup', function() {
  return {
    restrict: 'A',
    scope: { contentExp: '&', originScope: '&' },
    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
  };
})

.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

.directive('uibTooltipHtmlPopup', function() {
  return {
    restrict: 'A',
    scope: { contentExp: '&' },
    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
  };
})

.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

.directive('uibPopoverTemplatePopup', function() {
  return {
    restrict: 'A',
    scope: { uibTitle: '@', contentExp: '&', originScope: '&' },
    templateUrl: 'uib/template/popover/popover-template.html'
  };
})

.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverHtmlPopup', function() {
  return {
    restrict: 'A',
    scope: { contentExp: '&', uibTitle: '@' },
    templateUrl: 'uib/template/popover/popover-html.html'
  };
})

.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverPopup', function() {
  return {
    restrict: 'A',
    scope: { uibTitle: '@', content: '@' },
    templateUrl: 'uib/template/popover/popover.html'
  };
})

.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopover', 'popover', 'click');
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('uibProgressConfig', {
  animate: true,
  max: 100
})

.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
  var self = this,
      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = getMaxOrDefault();

  this.addBar = function(bar, element, attrs) {
    if (!animate) {
      element.css({'transition': 'none'});
    }

    this.bars.push(bar);

    bar.max = getMaxOrDefault();
    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

    bar.$watch('value', function(value) {
      bar.recalculatePercentage();
    });

    bar.recalculatePercentage = function() {
      var totalPercentage = self.bars.reduce(function(total, bar) {
        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
        return total + bar.percent;
      }, 0);

      if (totalPercentage > 100) {
        bar.percent -= totalPercentage - 100;
      }
    };

    bar.$on('$destroy', function() {
      element = null;
      self.removeBar(bar);
    });
  };

  this.removeBar = function(bar) {
    this.bars.splice(this.bars.indexOf(bar), 1);
    this.bars.forEach(function (bar) {
      bar.recalculatePercentage();
    });
  };

  //$attrs.$observe('maxParam', function(maxParam) {
  $scope.$watch('maxParam', function(maxParam) {
    self.bars.forEach(function(bar) {
      bar.max = getMaxOrDefault();
      bar.recalculatePercentage();
    });
  });

  function getMaxOrDefault () {
    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
  }
}])

.directive('uibProgress', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    require: 'uibProgress',
    scope: {
      maxParam: '=?max'
    },
    templateUrl: 'uib/template/progressbar/progress.html'
  };
})

.directive('uibBar', function() {
  return {
    replace: true,
    transclude: true,
    require: '^uibProgress',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'uib/template/progressbar/bar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, element, attrs);
    }
  };
})

.directive('uibProgressbar', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    scope: {
      value: '=',
      maxParam: '=?max',
      type: '@'
    },
    templateUrl: 'uib/template/progressbar/progressbar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
    }
  };
});

angular.module('ui.bootstrap.rating', [])

.constant('uibRatingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null,
  enableReset: true,
  titles: ['one', 'two', 'three', 'four', 'five']
})

.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
  var ngModelCtrl = { $setViewValue: angular.noop },
    self = this;

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.push(function(value) {
      if (angular.isNumber(value) && value << 0 !== value) {
        value = Math.round(value);
      }

      return value;
    });

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
    this.enableReset = angular.isDefined($attrs.enableReset) ?
      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
      tmpTitles : ratingConfig.titles;

    var ratingStates = angular.isDefined($attrs.ratingStates) ?
      $scope.$parent.$eval($attrs.ratingStates) :
      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
    }
    return states;
  };

  this.getTitle = function(index) {
    if (index >= this.titles.length) {
      return index + 1;
    }

    return this.titles[index];
  };

  $scope.rate = function(value) {
    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
      ngModelCtrl.$setViewValue(newViewValue);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if (!$scope.readonly) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.title = self.getTitle($scope.value - 1);
  };
}])

.directive('uibRating', function() {
  return {
    require: ['uibRating', 'ngModel'],
    restrict: 'A',
    scope: {
      readonly: '=?readOnly',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'UibRatingController',
    templateUrl: 'uib/template/rating/rating.html',
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init(ngModelCtrl);
    }
  };
});

angular.module('ui.bootstrap.tabs', [])

.controller('UibTabsetController', ['$scope', function ($scope) {
  var ctrl = this,
    oldIndex;
  ctrl.tabs = [];

  ctrl.select = function(index, evt) {
    if (!destroyed) {
      var previousIndex = findTabIndex(oldIndex);
      var previousSelected = ctrl.tabs[previousIndex];
      if (previousSelected) {
        previousSelected.tab.onDeselect({
          $event: evt,
          $selectedIndex: index
        });
        if (evt && evt.isDefaultPrevented()) {
          return;
        }
        previousSelected.tab.active = false;
      }

      var selected = ctrl.tabs[index];
      if (selected) {
        selected.tab.onSelect({
          $event: evt
        });
        selected.tab.active = true;
        ctrl.active = selected.index;
        oldIndex = selected.index;
      } else if (!selected && angular.isDefined(oldIndex)) {
        ctrl.active = null;
        oldIndex = null;
      }
    }
  };

  ctrl.addTab = function addTab(tab) {
    ctrl.tabs.push({
      tab: tab,
      index: tab.index
    });
    ctrl.tabs.sort(function(t1, t2) {
      if (t1.index > t2.index) {
        return 1;
      }

      if (t1.index < t2.index) {
        return -1;
      }

      return 0;
    });

    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
      var newActiveIndex = findTabIndex(tab.index);
      ctrl.select(newActiveIndex);
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index;
    for (var i = 0; i < ctrl.tabs.length; i++) {
      if (ctrl.tabs[i].tab === tab) {
        index = i;
        break;
      }
    }

    if (ctrl.tabs[index].index === ctrl.active) {
      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?
        index - 1 : index + 1 % ctrl.tabs.length;
      ctrl.select(newActiveTabIndex);
    }

    ctrl.tabs.splice(index, 1);
  };

  $scope.$watch('tabset.active', function(val) {
    if (angular.isDefined(val) && val !== oldIndex) {
      ctrl.select(findTabIndex(val));
    }
  });

  var destroyed;
  $scope.$on('$destroy', function() {
    destroyed = true;
  });

  function findTabIndex(index) {
    for (var i = 0; i < ctrl.tabs.length; i++) {
      if (ctrl.tabs[i].index === index) {
        return i;
      }
    }
  }
}])

.directive('uibTabset', function() {
  return {
    transclude: true,
    replace: true,
    scope: {},
    bindToController: {
      active: '=?',
      type: '@'
    },
    controller: 'UibTabsetController',
    controllerAs: 'tabset',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/tabs/tabset.html';
    },
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ?
        scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ?
        scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

.directive('uibTab', ['$parse', function($parse) {
  return {
    require: '^uibTabset',
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/tabs/tab.html';
    },
    transclude: true,
    scope: {
      heading: '@',
      index: '=?',
      classes: '@?',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    controllerAs: 'tab',
    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
      scope.disabled = false;
      if (attrs.disable) {
        scope.$parent.$watch($parse(attrs.disable), function(value) {
          scope.disabled = !! value;
        });
      }

      if (angular.isUndefined(attrs.index)) {
        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;
        } else {
          scope.index = 0;
        }
      }

      if (angular.isUndefined(attrs.classes)) {
        scope.classes = '';
      }

      scope.select = function(evt) {
        if (!scope.disabled) {
          var index;
          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
            if (tabsetCtrl.tabs[i].tab === scope) {
              index = i;
              break;
            }
          }

          tabsetCtrl.select(index, evt);
        }
      };

      tabsetCtrl.addTab(scope);
      scope.$on('$destroy', function() {
        tabsetCtrl.removeTab(scope);
      });

      //We need to transclude later, once the content container is ready.
      //when this link happens, we're inside a tab heading.
      scope.$transcludeFn = transclude;
    }
  };
}])

.directive('uibTabHeadingTransclude', function() {
  return {
    restrict: 'A',
    require: '^uibTab',
    link: function(scope, elm) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
})

.directive('uibTabContentTransclude', function() {
  return {
    restrict: 'A',
    require: '^uibTabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };

  function isTabHeading(node) {
    return node.tagName && (
      node.hasAttribute('uib-tab-heading') ||
      node.hasAttribute('data-uib-tab-heading') ||
      node.hasAttribute('x-uib-tab-heading') ||
      node.tagName.toLowerCase() === 'uib-tab-heading' ||
      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'uib:tab-heading'
    );
  }
});

angular.module('ui.bootstrap.timepicker', [])

.constant('uibTimepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  secondStep: 1,
  showMeridian: true,
  showSeconds: false,
  meridians: null,
  readonlyInput: false,
  mousewheel: true,
  arrowkeys: true,
  showSpinners: true,
  templateUrl: 'uib/template/timepicker/timepicker.html'
})

.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
  var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;
  var selected = new Date(),
    watchers = [],
    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;

  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
  $element.removeAttr('tabindex');

  this.init = function(ngModelCtrl_, inputs) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.unshift(function(modelValue) {
      return modelValue ? new Date(modelValue) : null;
    });

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1),
        secondsInputEl = inputs.eq(2);

    hoursModelCtrl = hoursInputEl.controller('ngModel');
    minutesModelCtrl = minutesInputEl.controller('ngModel');
    secondsModelCtrl = secondsInputEl.controller('ngModel');

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

    if (mousewheel) {
      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    }

    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
    if (arrowkeys) {
      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = +value;
    }));
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = +value;
    }));
  }

  var min;
  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
    var dt = new Date(value);
    min = isNaN(dt) ? undefined : dt;
  }));

  var max;
  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
    var dt = new Date(value);
    max = isNaN(dt) ? undefined : dt;
  }));

  var disabled = false;
  if ($attrs.ngDisabled) {
    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
      disabled = value;
    }));
  }

  $scope.noIncrementHours = function() {
    var incrementedSelected = addMinutes(selected, hourStep * 60);
    return disabled || incrementedSelected > max ||
      incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementHours = function() {
    var decrementedSelected = addMinutes(selected, -hourStep * 60);
    return disabled || decrementedSelected < min ||
      decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noIncrementMinutes = function() {
    var incrementedSelected = addMinutes(selected, minuteStep);
    return disabled || incrementedSelected > max ||
      incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementMinutes = function() {
    var decrementedSelected = addMinutes(selected, -minuteStep);
    return disabled || decrementedSelected < min ||
      decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noIncrementSeconds = function() {
    var incrementedSelected = addSeconds(selected, secondStep);
    return disabled || incrementedSelected > max ||
      incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementSeconds = function() {
    var decrementedSelected = addSeconds(selected, -secondStep);
    return disabled || decrementedSelected < min ||
      decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noToggleMeridian = function() {
    if (selected.getHours() < 12) {
      return disabled || addMinutes(selected, 12 * 60) > max;
    }

    return disabled || addMinutes(selected, -12 * 60) < min;
  };

  var secondStep = timepickerConfig.secondStep;
  if ($attrs.secondStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
      secondStep = +value;
    }));
  }

  $scope.showSeconds = timepickerConfig.showSeconds;
  if ($attrs.showSeconds) {
    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
      $scope.showSeconds = !!value;
    }));
  }

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if (ngModelCtrl.$error.time) {
        // Evaluate from template
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
          selected.setHours(hours);
          refresh();
        }
      } else {
        updateTemplate();
      }
    }));
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate() {
    var hours = +$scope.hours;
    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
      hours >= 0 && hours < 24;
    if (!valid || $scope.hours === '') {
      return undefined;
    }

    if ($scope.showMeridian) {
      if (hours === 12) {
        hours = 0;
      }
      if ($scope.meridian === meridians[1]) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = +$scope.minutes;
    var valid = minutes >= 0 && minutes < 60;
    if (!valid || $scope.minutes === '') {
      return undefined;
    }
    return minutes;
  }

  function getSecondsFromTemplate() {
    var seconds = +$scope.seconds;
    return seconds >= 0 && seconds < 60 ? seconds : undefined;
  }

  function pad(value, noPad) {
    if (value === null) {
      return '';
    }

    return angular.isDefined(value) && value.toString().length < 2 && !noPad ?
      '0' + value : value.toString();
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
      return e.detail || delta > 0;
    };

    hoursInputEl.on('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
      }
      e.preventDefault();
    });

    minutesInputEl.on('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
      }
      e.preventDefault();
    });

     secondsInputEl.on('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
      }
      e.preventDefault();
    });
  };

  // Respond on up/down arrowkeys
  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    hoursInputEl.on('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { // up
          e.preventDefault();
          $scope.incrementHours();
          $scope.$apply();
        } else if (e.which === 40) { // down
          e.preventDefault();
          $scope.decrementHours();
          $scope.$apply();
        }
      }
    });

    minutesInputEl.on('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { // up
          e.preventDefault();
          $scope.incrementMinutes();
          $scope.$apply();
        } else if (e.which === 40) { // down
          e.preventDefault();
          $scope.decrementMinutes();
          $scope.$apply();
        }
      }
    });

    secondsInputEl.on('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { // up
          e.preventDefault();
          $scope.incrementSeconds();
          $scope.$apply();
        } else if (e.which === 40) { // down
          e.preventDefault();
          $scope.decrementSeconds();
          $scope.$apply();
        }
      }
    });
  };

  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    if ($scope.readonlyInput) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      $scope.updateSeconds = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
      ngModelCtrl.$setViewValue(null);
      ngModelCtrl.$setValidity('time', false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
        if (hoursModelCtrl) {
          hoursModelCtrl.$setValidity('hours', false);
        }
      }

      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
        if (minutesModelCtrl) {
          minutesModelCtrl.$setValidity('minutes', false);
        }
      }

      if (angular.isDefined(invalidSeconds)) {
        $scope.invalidSeconds = invalidSeconds;
        if (secondsModelCtrl) {
          secondsModelCtrl.$setValidity('seconds', false);
        }
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate(),
        minutes = getMinutesFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
        selected.setHours(hours);
        selected.setMinutes(minutes);
        if (selected < min || selected > max) {
          invalidate(true);
        } else {
          refresh('h');
        }
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.on('blur', function(e) {
      ngModelCtrl.$setTouched();
      if (modelIsEmpty()) {
        makeValid();
      } else if ($scope.hours === null || $scope.hours === '') {
        invalidate(true);
      } else if (!$scope.invalidHours && $scope.hours < 10) {
        $scope.$apply(function() {
          $scope.hours = pad($scope.hours, !padHours);
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
        selected.setHours(hours);
        selected.setMinutes(minutes);
        if (selected < min || selected > max) {
          invalidate(undefined, true);
        } else {
          refresh('m');
        }
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.on('blur', function(e) {
      ngModelCtrl.$setTouched();
      if (modelIsEmpty()) {
        makeValid();
      } else if ($scope.minutes === null) {
        invalidate(undefined, true);
      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
        $scope.$apply(function() {
          $scope.minutes = pad($scope.minutes);
        });
      }
    });

    $scope.updateSeconds = function() {
      var seconds = getSecondsFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(seconds)) {
        selected.setSeconds(seconds);
        refresh('s');
      } else {
        invalidate(undefined, undefined, true);
      }
    };

    secondsInputEl.on('blur', function(e) {
      if (modelIsEmpty()) {
        makeValid();
      } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
        $scope.$apply( function() {
          $scope.seconds = pad($scope.seconds);
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$viewValue;

    if (isNaN(date)) {
      ngModelCtrl.$setValidity('time', false);
      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
    } else {
      if (date) {
        selected = date;
      }

      if (selected < min || selected > max) {
        ngModelCtrl.$setValidity('time', false);
        $scope.invalidHours = true;
        $scope.invalidMinutes = true;
      } else {
        makeValid();
      }
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh(keyboardChange) {
    makeValid();
    ngModelCtrl.$setViewValue(new Date(selected));
    updateTemplate(keyboardChange);
  }

  function makeValid() {
    if (hoursModelCtrl) {
      hoursModelCtrl.$setValidity('hours', true);
    }

    if (minutesModelCtrl) {
      minutesModelCtrl.$setValidity('minutes', true);
    }

    if (secondsModelCtrl) {
      secondsModelCtrl.$setValidity('seconds', true);
    }

    ngModelCtrl.$setValidity('time', true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
    $scope.invalidSeconds = false;
  }

  function updateTemplate(keyboardChange) {
    if (!ngModelCtrl.$modelValue) {
      $scope.hours = null;
      $scope.minutes = null;
      $scope.seconds = null;
      $scope.meridian = meridians[0];
    } else {
      var hours = selected.getHours(),
        minutes = selected.getMinutes(),
        seconds = selected.getSeconds();

      if ($scope.showMeridian) {
        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
      }

      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
      if (keyboardChange !== 'm') {
        $scope.minutes = pad(minutes);
      }
      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];

      if (keyboardChange !== 's') {
        $scope.seconds = pad(seconds);
      }
      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
    }
  }

  function addSecondsToSelected(seconds) {
    selected = addSeconds(selected, seconds);
    refresh();
  }

  function addMinutes(selected, minutes) {
    return addSeconds(selected, minutes*60);
  }

  function addSeconds(date, seconds) {
    var dt = new Date(date.getTime() + seconds * 1000);
    var newDate = new Date(date);
    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
    return newDate;
  }

  function modelIsEmpty() {
    return ($scope.hours === null || $scope.hours === '') &&
      ($scope.minutes === null || $scope.minutes === '') &&
      (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
  }

  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

  $scope.incrementHours = function() {
    if (!$scope.noIncrementHours()) {
      addSecondsToSelected(hourStep * 60 * 60);
    }
  };

  $scope.decrementHours = function() {
    if (!$scope.noDecrementHours()) {
      addSecondsToSelected(-hourStep * 60 * 60);
    }
  };

  $scope.incrementMinutes = function() {
    if (!$scope.noIncrementMinutes()) {
      addSecondsToSelected(minuteStep * 60);
    }
  };

  $scope.decrementMinutes = function() {
    if (!$scope.noDecrementMinutes()) {
      addSecondsToSelected(-minuteStep * 60);
    }
  };

  $scope.incrementSeconds = function() {
    if (!$scope.noIncrementSeconds()) {
      addSecondsToSelected(secondStep);
    }
  };

  $scope.decrementSeconds = function() {
    if (!$scope.noDecrementSeconds()) {
      addSecondsToSelected(-secondStep);
    }
  };

  $scope.toggleMeridian = function() {
    var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

    if (!$scope.noToggleMeridian()) {
      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
      } else {
        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
      }
    }
  };

  $scope.blur = function() {
    ngModelCtrl.$setTouched();
  };

  $scope.$on('$destroy', function() {
    while (watchers.length) {
      watchers.shift()();
    }
  });
}])

.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
  return {
    require: ['uibTimepicker', '?^ngModel'],
    restrict: 'A',
    controller: 'UibTimepickerController',
    controllerAs: 'timepicker',
    scope: {},
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || uibTimepickerConfig.templateUrl;
    },
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find('input'));
      }
    }
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('uibTypeaheadParser', ['$parse', function($parse) {
    //                      000001111111100000000000002222222200000000000000003333333333333330000000000044444444000
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
      parse: function(input) {
        var match = input.match(TYPEAHEAD_REGEXP);
        if (!match) {
          throw new Error(
            'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
              ' but got "' + input + '".');
        }

        return {
          itemName: match[3],
          source: $parse(match[4]),
          viewMapper: $parse(match[2] || match[1]),
          modelMapper: $parse(match[1])
        };
      }
    };
  }])

  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    var eventDebounceTime = 200;
    var modelCtrl, ngModelOptions;
    //SUPPORTED ATTRIBUTES (OPTIONS)

    //minimal no of characters that needs to be entered before typeahead kicks-in
    var minLength = originalScope.$eval(attrs.typeaheadMinLength);
    if (!minLength && minLength !== 0) {
      minLength = 1;
    }

    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
        minLength = !newVal && newVal !== 0 ? 1 : newVal;
    });

    //minimal wait time after last character typed before typeahead kicks-in
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

    //should it restrict model values to the ones selected from the popup only?
    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
      isEditable = newVal !== false;
    });

    //binding to a variable that indicates if matches are being retrieved asynchronously
    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

    //a function to determine if an event should cause selection
    var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
      var evt = vals.$event;
      return evt.which === 13 || evt.which === 9;
    };

    //a callback executed when a match is selected
    var onSelectCallback = $parse(attrs.typeaheadOnSelect);

    //should it select highlighted popup value when losing focus?
    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

    //binding to a variable that indicates if there were no results after the query is completed
    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

    var appendTo = attrs.typeaheadAppendTo ?
      originalScope.$eval(attrs.typeaheadAppendTo) : null;

    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

    //If input matches an item of the list exactly, select it automatically
    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

    //binding to a variable that indicates if dropdown is open
    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

    //INTERNAL VARIABLES

    //model setter executed upon match selection
    var parsedModel = $parse(attrs.ngModel);
    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
    var $setModelValue = function(scope, newValue) {
      if (angular.isFunction(parsedModel(originalScope)) &&
        ngModelOptions.getOption('getterSetter')) {
        return invokeModelSetter(scope, {$$$p: newValue});
      }

      return parsedModel.assign(scope, newValue);
    };

    //expressions used by typeahead
    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

    var hasFocus;

    //Used to avoid bug in iOS webview where iOS keyboard does not fire
    //mousedown & mouseup events
    //Issue #3699
    var selected;

    //create a child scope for the typeahead directive so we are not polluting original scope
    //with typeahead-specific data (matches, query etc.)
    var scope = originalScope.$new();
    var offDestroy = originalScope.$on('$destroy', function() {
      scope.$destroy();
    });
    scope.$on('$destroy', offDestroy);

    // WAI-ARIA
    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
    element.attr({
      'aria-autocomplete': 'list',
      'aria-expanded': false,
      'aria-owns': popupId
    });

    var inputsContainer, hintInputElem;
    //add read-only input to show hint
    if (showHint) {
      inputsContainer = angular.element('<div></div>');
      inputsContainer.css('position', 'relative');
      element.after(inputsContainer);
      hintInputElem = element.clone();
      hintInputElem.attr('placeholder', '');
      hintInputElem.attr('tabindex', '-1');
      hintInputElem.val('');
      hintInputElem.css({
        'position': 'absolute',
        'top': '0px',
        'left': '0px',
        'border-color': 'transparent',
        'box-shadow': 'none',
        'opacity': 1,
        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
        'color': '#999'
      });
      element.css({
        'position': 'relative',
        'vertical-align': 'top',
        'background-color': 'transparent'
      });

      if (hintInputElem.attr('id')) {
        hintInputElem.removeAttr('id'); // remove duplicate id if present.
      }
      inputsContainer.append(hintInputElem);
      hintInputElem.after(element);
    }

    //pop-up element used to display matches
    var popUpEl = angular.element('<div uib-typeahead-popup></div>');
    popUpEl.attr({
      id: popupId,
      matches: 'matches',
      active: 'activeIdx',
      select: 'select(activeIdx, evt)',
      'move-in-progress': 'moveInProgress',
      query: 'query',
      position: 'position',
      'assign-is-open': 'assignIsOpen(isOpen)',
      debounce: 'debounceUpdate'
    });
    //custom item template
    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
    }

    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
    }

    var resetHint = function() {
      if (showHint) {
        hintInputElem.val('');
      }
    };

    var resetMatches = function() {
      scope.matches = [];
      scope.activeIdx = -1;
      element.attr('aria-expanded', false);
      resetHint();
    };

    var getMatchId = function(index) {
      return popupId + '-option-' + index;
    };

    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
    // This attribute is added or removed automatically when the `activeIdx` changes.
    scope.$watch('activeIdx', function(index) {
      if (index < 0) {
        element.removeAttr('aria-activedescendant');
      } else {
        element.attr('aria-activedescendant', getMatchId(index));
      }
    });

    var inputIsExactMatch = function(inputValue, index) {
      if (scope.matches.length > index && inputValue) {
        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
      }

      return false;
    };

    var getMatchesAsync = function(inputValue, evt) {
      var locals = {$viewValue: inputValue};
      isLoadingSetter(originalScope, true);
      isNoResultsSetter(originalScope, false);
      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
        //it might happen that several async queries were in progress if a user were typing fast
        //but we are interested only in responses that correspond to the current view value
        var onCurrentRequest = inputValue === modelCtrl.$viewValue;
        if (onCurrentRequest && hasFocus) {
          if (matches && matches.length > 0) {
            scope.activeIdx = focusFirst ? 0 : -1;
            isNoResultsSetter(originalScope, false);
            scope.matches.length = 0;

            //transform labels
            for (var i = 0; i < matches.length; i++) {
              locals[parserResult.itemName] = matches[i];
              scope.matches.push({
                id: getMatchId(i),
                label: parserResult.viewMapper(scope, locals),
                model: matches[i]
              });
            }

            scope.query = inputValue;
            //position pop-up with matches - we need to re-calculate its position each time we are opening a window
            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
            //due to other elements being rendered
            recalculatePosition();

            element.attr('aria-expanded', true);

            //Select the single remaining option if user input matches
            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(0, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
                scope.select(0, evt);
              }
            }

            if (showHint) {
              var firstLabel = scope.matches[0].label;
              if (angular.isString(inputValue) &&
                inputValue.length > 0 &&
                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
              } else {
                hintInputElem.val('');
              }
            }
          } else {
            resetMatches();
            isNoResultsSetter(originalScope, true);
          }
        }
        if (onCurrentRequest) {
          isLoadingSetter(originalScope, false);
        }
      }, function() {
        resetMatches();
        isLoadingSetter(originalScope, false);
        isNoResultsSetter(originalScope, true);
      });
    };

    // bind events only if appendToBody params exist - performance feature
    if (appendToBody) {
      angular.element($window).on('resize', fireRecalculating);
      $document.find('body').on('scroll', fireRecalculating);
    }

    // Declare the debounced function outside recalculating for
    // proper debouncing
    var debouncedRecalculate = $$debounce(function() {
      // if popup is visible
      if (scope.matches.length) {
        recalculatePosition();
      }

      scope.moveInProgress = false;
    }, eventDebounceTime);

    // Default progress type
    scope.moveInProgress = false;

    function fireRecalculating() {
      if (!scope.moveInProgress) {
        scope.moveInProgress = true;
        scope.$digest();
      }

      debouncedRecalculate();
    }

    // recalculate actual position and set new values to scope
    // after digest loop is popup in right position
    function recalculatePosition() {
      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
      scope.position.top += element.prop('offsetHeight');
    }

    //we need to propagate user's query so we can higlight matches
    scope.query = undefined;

    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
    var timeoutPromise;

    var scheduleSearchWithTimeout = function(inputValue) {
      timeoutPromise = $timeout(function() {
        getMatchesAsync(inputValue);
      }, waitTime);
    };

    var cancelPreviousTimeout = function() {
      if (timeoutPromise) {
        $timeout.cancel(timeoutPromise);
      }
    };

    resetMatches();

    scope.assignIsOpen = function (isOpen) {
      isOpenSetter(originalScope, isOpen);
    };

    scope.select = function(activeIdx, evt) {
      //called from within the $digest() cycle
      var locals = {};
      var model, item;

      selected = true;
      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
      model = parserResult.modelMapper(originalScope, locals);
      $setModelValue(originalScope, model);
      modelCtrl.$setValidity('editable', true);
      modelCtrl.$setValidity('parse', true);

      onSelectCallback(originalScope, {
        $item: item,
        $model: model,
        $label: parserResult.viewMapper(originalScope, locals),
        $event: evt
      });

      resetMatches();

      //return focus to the input element if a match was selected via a mouse click event
      // use timeout to avoid $rootScope:inprog error
      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
        $timeout(function() { element[0].focus(); }, 0, false);
      }
    };

    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
    element.on('keydown', function(evt) {
      //typeahead is open and an "interesting" key was pressed
      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
        return;
      }

      var shouldSelect = isSelectEvent(originalScope, {$event: evt});

      /**
       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit
       * or
       * shift + tab is pressed to bring focus to the previous element
       * then clear the results
       */
      if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
        resetMatches();
        scope.$digest();
        return;
      }

      evt.preventDefault();
      var target;
      switch (evt.which) {
        case 27: // escape
          evt.stopPropagation();

          resetMatches();
          originalScope.$digest();
          break;
        case 38: // up arrow
          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();
          target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
          target.parentNode.scrollTop = target.offsetTop;
          break;
        case 40: // down arrow
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();
          target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
          target.parentNode.scrollTop = target.offsetTop;
          break;
        default:
          if (shouldSelect) {
            scope.$apply(function() {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(scope.activeIdx, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
                scope.select(scope.activeIdx, evt);
              }
            });
          }
      }
    });

    element.on('focus', function (evt) {
      hasFocus = true;
      if (minLength === 0 && !modelCtrl.$viewValue) {
        $timeout(function() {
          getMatchesAsync(modelCtrl.$viewValue, evt);
        }, 0);
      }
    });

    element.on('blur', function(evt) {
      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
        selected = true;
        scope.$apply(function() {
          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
            $$debounce(function() {
              scope.select(scope.activeIdx, evt);
            }, scope.debounceUpdate.blur);
          } else {
            scope.select(scope.activeIdx, evt);
          }
        });
      }
      if (!isEditable && modelCtrl.$error.editable) {
        modelCtrl.$setViewValue();
        scope.$apply(function() {
          // Reset validity as we are clearing
          modelCtrl.$setValidity('editable', true);
          modelCtrl.$setValidity('parse', true);
        });
        element.val('');
      }
      hasFocus = false;
      selected = false;
    });

    // Keep reference to click handler to unbind it.
    var dismissClickHandler = function(evt) {
      // Issue #3973
      // Firefox treats right click as a click on document
      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
        resetMatches();
        if (!$rootScope.$$phase) {
          originalScope.$digest();
        }
      }
    };

    $document.on('click', dismissClickHandler);

    originalScope.$on('$destroy', function() {
      $document.off('click', dismissClickHandler);
      if (appendToBody || appendTo) {
        $popup.remove();
      }

      if (appendToBody) {
        angular.element($window).off('resize', fireRecalculating);
        $document.find('body').off('scroll', fireRecalculating);
      }
      // Prevent jQuery cache memory leak
      popUpEl.remove();

      if (showHint) {
          inputsContainer.remove();
      }
    });

    var $popup = $compile(popUpEl)(scope);

    if (appendToBody) {
      $document.find('body').append($popup);
    } else if (appendTo) {
      angular.element(appendTo).eq(0).append($popup);
    } else {
      element.after($popup);
    }

    this.init = function(_modelCtrl) {
      modelCtrl = _modelCtrl;
      ngModelOptions = extractOptions(modelCtrl);

      scope.debounceUpdate = $parse(ngModelOptions.getOption('debounce'))(originalScope);

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function(inputValue) {
        hasFocus = true;

        if (minLength === 0 || inputValue && inputValue.length >= minLength) {
          if (waitTime > 0) {
            cancelPreviousTimeout();
            scheduleSearchWithTimeout(inputValue);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          cancelPreviousTimeout();
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        }

        if (!inputValue) {
          // Reset in case user had typed something previously.
          modelCtrl.$setValidity('editable', true);
          return null;
        }

        modelCtrl.$setValidity('editable', false);
        return undefined;
      });

      modelCtrl.$formatters.push(function(modelValue) {
        var candidateViewValue, emptyViewValue;
        var locals = {};

        // The validity may be set to false via $parsers (see above) if
        // the model is restricted to selected values. If the model
        // is set manually it is considered to be valid.
        if (!isEditable) {
          modelCtrl.$setValidity('editable', true);
        }

        if (inputFormatter) {
          locals.$model = modelValue;
          return inputFormatter(originalScope, locals);
        }

        //it might happen that we don't have enough info to properly render input value
        //we need to check for this situation and simply return model value if we can't apply custom formatting
        locals[parserResult.itemName] = modelValue;
        candidateViewValue = parserResult.viewMapper(originalScope, locals);
        locals[parserResult.itemName] = undefined;
        emptyViewValue = parserResult.viewMapper(originalScope, locals);

        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
      });
    };

    function extractOptions(ngModelCtrl) {
      var ngModelOptions;

      if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing
        // guarantee a value
        ngModelOptions = ngModelCtrl.$options || {};

        // mimic 1.6+ api
        ngModelOptions.getOption = function (key) {
          return ngModelOptions[key];
        };
      } else { // in angular >=1.6 $options is always present
        ngModelOptions = ngModelCtrl.$options;
      }

      return ngModelOptions;
    }
  }])

  .directive('uibTypeahead', function() {
    return {
      controller: 'UibTypeaheadController',
      require: ['ngModel', 'uibTypeahead'],
      link: function(originalScope, element, attrs, ctrls) {
        ctrls[1].init(ctrls[0]);
      }
    };
  })

  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&',
        moveInProgress: '=',
        select: '&',
        assignIsOpen: '&',
        debounce: '&'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function() {
          var isDropdownOpen = scope.matches.length > 0;
          scope.assignIsOpen({ isOpen: isDropdownOpen });
          return isDropdownOpen;
        };

        scope.isActive = function(matchIdx) {
          return scope.active === matchIdx;
        };

        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function(activeIdx, evt) {
          var debounce = scope.debounce();
          if (angular.isNumber(debounce) || angular.isObject(debounce)) {
            $$debounce(function() {
              scope.select({activeIdx: activeIdx, evt: evt});
            }, angular.isNumber(debounce) ? debounce : debounce['default']);
          } else {
            scope.select({activeIdx: activeIdx, evt: evt});
          }
        };
      }
    };
  }])

  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
    return {
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link: function(scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          var tplEl = angular.element(tplContent.trim());
          element.replaceWith(tplEl);
          $compile(tplEl)(scope);
        });
      }
    };
  }])

  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
      // Regex: capture the whole query string and replace it with the string that will be used to match
      // the results, for example if the capture is "a" the result will be \a
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
      return /<.*>/g.test(matchItem);
    }

    return function(matchItem, query) {
      if (!isSanitizePresent && containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
      }
      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
      }
      return matchItem;
    };
  }]);

angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion-group.html",
    "<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
    "  <h4 class=\"panel-title\">\n" +
    "    <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
    "  </h4>\n" +
    "</div>\n" +
    "<div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
    "  <div class=\"panel-body\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion.html",
    "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
}]);

angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/alert/alert.html",
    "<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
    "  <span aria-hidden=\"true\">&times;</span>\n" +
    "  <span class=\"sr-only\">Close</span>\n" +
    "</button>\n" +
    "<div ng-transclude></div>\n" +
    "");
}]);

angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/carousel.html",
    "<div class=\"carousel-inner\" ng-transclude></div>\n" +
    "<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" +
    "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
    "  <span class=\"sr-only\">previous</span>\n" +
    "</a>\n" +
    "<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" +
    "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
    "  <span class=\"sr-only\">next</span>\n" +
    "</a>\n" +
    "<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
    "  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
    "    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
    "  </li>\n" +
    "</ol>\n" +
    "");
}]);

angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/slide.html",
    "<div class=\"text-center\" ng-transclude></div>\n" +
    "");
}]);

angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/datepicker.html",
    "<div ng-switch=\"datepickerMode\">\n" +
    "  <div uib-daypicker ng-switch-when=\"day\" tabindex=\"0\" class=\"uib-daypicker\"></div>\n" +
    "  <div uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\" class=\"uib-monthpicker\"></div>\n" +
    "  <div uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\" class=\"uib-yearpicker\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/day.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/month.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
    "      <th colspan=\"{{::yearHeaderColspan}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/year.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
    "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepickerPopup/popup.html",
    "<ul role=\"presentation\" class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
    "  <li ng-transclude></li>\n" +
    "  <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" +
    "    <span class=\"btn-group pull-left\">\n" +
    "      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
    "      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" +
    "    </span>\n" +
    "    <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" +
    "  </li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/modal/window.html",
    "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
    "");
}]);

angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pager/pager.html",
    "<li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
    "<li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
    "");
}]);

angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pagination/pagination.html",
    "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\n" +
    "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
    "<li role=\"menuitem\" ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\" ng-disabled=\"ngDisabled&&!page.active\" uib-tabindex-toggle>{{page.text}}</a></li>\n" +
    "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
    "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\n" +
    "");
}]);

angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-html-popup.html",
    "<div class=\"tooltip-arrow\"></div>\n" +
    "<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
    "");
}]);

angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-popup.html",
    "<div class=\"tooltip-arrow\"></div>\n" +
    "<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "");
}]);

angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-template-popup.html",
    "<div class=\"tooltip-arrow\"></div>\n" +
    "<div class=\"tooltip-inner\"\n" +
    "  uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "  tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "");
}]);

angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-html.html",
    "<div class=\"arrow\"></div>\n" +
    "\n" +
    "<div class=\"popover-inner\">\n" +
    "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
    "    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-template.html",
    "<div class=\"arrow\"></div>\n" +
    "\n" +
    "<div class=\"popover-inner\">\n" +
    "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
    "    <div class=\"popover-content\"\n" +
    "      uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "      tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover.html",
    "<div class=\"arrow\"></div>\n" +
    "\n" +
    "<div class=\"popover-inner\">\n" +
    "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
    "    <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/bar.html",
    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
    "");
}]);

angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progress.html",
    "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
}]);

angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progressbar.html",
    "<div class=\"progress\">\n" +
    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" +
    "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
    "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" +
    "</span>\n" +
    "");
}]);

angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tab.html",
    "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" +
    "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tabset.html",
    "<div>\n" +
    "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\"\n" +
    "         ng-repeat=\"tab in tabset.tabs\"\n" +
    "         ng-class=\"{active: tabset.active === tab.index}\"\n" +
    "         uib-tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/timepicker/timepicker.html",
    "<table class=\"uib-timepicker\">\n" +
    "  <tbody>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
    "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td class=\"uib-separator\">:</td>\n" +
    "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
    "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
    "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
    "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
    "    </tr>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-match.html",
    "<a href\n" +
    "   tabindex=\"-1\"\n" +
    "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" +
    "   ng-attr-title=\"{{match.label}}\"></a>\n" +
    "");
}]);

angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-popup.html",
    "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
    "    <li class=\"uib-typeahead-match\" ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" +
    "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
    "    </li>\n" +
    "</ul>\n" +
    "");
}]);
angular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });
angular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });
angular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });
angular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });
angular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });
angular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });
angular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });

/**
 * @license AngularJS v1.5.5
 * (c) 2010-2016 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

/**
 * @ngdoc module
 * @name ngRoute
 * @description
 *
 * # ngRoute
 *
 * The `ngRoute` module provides routing and deeplinking services and directives for angular apps.
 *
 * ## Example
 * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.
 *
 *
 * <div doc-module-components="ngRoute"></div>
 */
 /* global -ngRouteModule */
var ngRouteModule = angular.module('ngRoute', ['ng']).
                        provider('$route', $RouteProvider),
    $routeMinErr = angular.$$minErr('ngRoute');

/**
 * @ngdoc provider
 * @name $routeProvider
 *
 * @description
 *
 * Used for configuring routes.
 *
 * ## Example
 * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.
 *
 * ## Dependencies
 * Requires the {@link ngRoute `ngRoute`} module to be installed.
 */
function $RouteProvider() {
  function inherit(parent, extra) {
    return angular.extend(Object.create(parent), extra);
  }

  var routes = {};

  /**
   * @ngdoc method
   * @name $routeProvider#when
   *
   * @param {string} path Route path (matched against `$location.path`). If `$location.path`
   *    contains redundant trailing slash or is missing one, the route will still match and the
   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the
   *    route definition.
   *
   *    * `path` can contain named groups starting with a colon: e.g. `:name`. All characters up
   *        to the next slash are matched and stored in `$routeParams` under the given `name`
   *        when the route matches.
   *    * `path` can contain named groups starting with a colon and ending with a star:
   *        e.g.`:name*`. All characters are eagerly stored in `$routeParams` under the given `name`
   *        when the route matches.
   *    * `path` can contain optional named groups with a question mark: e.g.`:name?`.
   *
   *    For example, routes like `/color/:color/largecode/:largecode*\/edit` will match
   *    `/color/brown/largecode/code/with/slashes/edit` and extract:
   *
   *    * `color: brown`
   *    * `largecode: code/with/slashes`.
   *
   *
   * @param {Object} route Mapping information to be assigned to `$route.current` on route
   *    match.
   *
   *    Object properties:
   *
   *    - `controller`  `{(string|function()=}`  Controller fn that should be associated with
   *      newly created scope or the name of a {@link angular.Module#controller registered
   *      controller} if passed as a string.
   *    - `controllerAs`  `{string=}`  An identifier name for a reference to the controller.
   *      If present, the controller will be published to scope under the `controllerAs` name.
   *    - `template`  `{string=|function()=}`  html template as a string or a function that
   *      returns an html template as a string which should be used by {@link
   *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.
   *      This property takes precedence over `templateUrl`.
   *
   *      If `template` is a function, it will be called with the following parameters:
   *
   *      - `{Array.<Object>}` - route parameters extracted from the current
   *        `$location.path()` by applying the current route
   *
   *    - `templateUrl`  `{string=|function()=}`  path or function that returns a path to an html
   *      template that should be used by {@link ngRoute.directive:ngView ngView}.
   *
   *      If `templateUrl` is a function, it will be called with the following parameters:
   *
   *      - `{Array.<Object>}` - route parameters extracted from the current
   *        `$location.path()` by applying the current route
   *
   *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should
   *      be injected into the controller. If any of these dependencies are promises, the router
   *      will wait for them all to be resolved or one to be rejected before the controller is
   *      instantiated.
   *      If all the promises are resolved successfully, the values of the resolved promises are
   *      injected and {@link ngRoute.$route#$routeChangeSuccess $routeChangeSuccess} event is
   *      fired. If any of the promises are rejected the
   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event is fired.
   *      For easier access to the resolved dependencies from the template, the `resolve` map will
   *      be available on the scope of the route, under `$resolve` (by default) or a custom name
   *      specified by the `resolveAs` property (see below). This can be particularly useful, when
   *      working with {@link angular.Module#component components} as route templates.<br />
   *      <div class="alert alert-warning">
   *        **Note:** If your scope already contains a property with this name, it will be hidden
   *        or overwritten. Make sure, you specify an appropriate name for this property, that
   *        does not collide with other properties on the scope.
   *      </div>
   *      The map object is:
   *
   *      - `key`  `{string}`: a name of a dependency to be injected into the controller.
   *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.
   *        Otherwise if function, then it is {@link auto.$injector#invoke injected}
   *        and the return value is treated as the dependency. If the result is a promise, it is
   *        resolved before its value is injected into the controller. Be aware that
   *        `ngRoute.$routeParams` will still refer to the previous route within these resolve
   *        functions.  Use `$route.current.params` to access the new route parameters, instead.
   *
   *    - `resolveAs` - `{string=}` - The name under which the `resolve` map will be available on
   *      the scope of the route. If omitted, defaults to `$resolve`.
   *
   *    - `redirectTo`  `{(string|function())=}`  value to update
   *      {@link ng.$location $location} path with and trigger route redirection.
   *
   *      If `redirectTo` is a function, it will be called with the following parameters:
   *
   *      - `{Object.<string>}` - route parameters extracted from the current
   *        `$location.path()` by applying the current route templateUrl.
   *      - `{string}` - current `$location.path()`
   *      - `{Object}` - current `$location.search()`
   *
   *      The custom `redirectTo` function is expected to return a string which will be used
   *      to update `$location.path()` and `$location.search()`.
   *
   *    - `[reloadOnSearch=true]` - `{boolean=}` - reload route when only `$location.search()`
   *      or `$location.hash()` changes.
   *
   *      If the option is set to `false` and url in the browser changes, then
   *      `$routeUpdate` event is broadcasted on the root scope.
   *
   *    - `[caseInsensitiveMatch=false]` - `{boolean=}` - match routes without being case sensitive
   *
   *      If the option is set to `true`, then the particular route can be matched without being
   *      case sensitive
   *
   * @returns {Object} self
   *
   * @description
   * Adds a new route definition to the `$route` service.
   */
  this.when = function(path, route) {
    //copy original route object to preserve params inherited from proto chain
    var routeCopy = angular.copy(route);
    if (angular.isUndefined(routeCopy.reloadOnSearch)) {
      routeCopy.reloadOnSearch = true;
    }
    if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {
      routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;
    }
    routes[path] = angular.extend(
      routeCopy,
      path && pathRegExp(path, routeCopy)
    );

    // create redirection for trailing slashes
    if (path) {
      var redirectPath = (path[path.length - 1] == '/')
            ? path.substr(0, path.length - 1)
            : path + '/';

      routes[redirectPath] = angular.extend(
        {redirectTo: path},
        pathRegExp(redirectPath, routeCopy)
      );
    }

    return this;
  };

  /**
   * @ngdoc property
   * @name $routeProvider#caseInsensitiveMatch
   * @description
   *
   * A boolean property indicating if routes defined
   * using this provider should be matched using a case insensitive
   * algorithm. Defaults to `false`.
   */
  this.caseInsensitiveMatch = false;

   /**
    * @param path {string} path
    * @param opts {Object} options
    * @return {?Object}
    *
    * @description
    * Normalizes the given path, returning a regular expression
    * and the original path.
    *
    * Inspired by pathRexp in visionmedia/express/lib/utils.js.
    */
  function pathRegExp(path, opts) {
    var insensitive = opts.caseInsensitiveMatch,
        ret = {
          originalPath: path,
          regexp: path
        },
        keys = ret.keys = [];

    path = path
      .replace(/([().])/g, '\\$1')
      .replace(/(\/)?:(\w+)(\*\?|[\?\*])?/g, function(_, slash, key, option) {
        var optional = (option === '?' || option === '*?') ? '?' : null;
        var star = (option === '*' || option === '*?') ? '*' : null;
        keys.push({ name: key, optional: !!optional });
        slash = slash || '';
        return ''
          + (optional ? '' : slash)
          + '(?:'
          + (optional ? slash : '')
          + (star && '(.+?)' || '([^/]+)')
          + (optional || '')
          + ')'
          + (optional || '');
      })
      .replace(/([\/$\*])/g, '\\$1');

    ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');
    return ret;
  }

  /**
   * @ngdoc method
   * @name $routeProvider#otherwise
   *
   * @description
   * Sets route definition that will be used on route change when no other route definition
   * is matched.
   *
   * @param {Object|string} params Mapping information to be assigned to `$route.current`.
   * If called with a string, the value maps to `redirectTo`.
   * @returns {Object} self
   */
  this.otherwise = function(params) {
    if (typeof params === 'string') {
      params = {redirectTo: params};
    }
    this.when(null, params);
    return this;
  };


  this.$get = ['$rootScope',
               '$location',
               '$routeParams',
               '$q',
               '$injector',
               '$templateRequest',
               '$sce',
      function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {

    /**
     * @ngdoc service
     * @name $route
     * @requires $location
     * @requires $routeParams
     *
     * @property {Object} current Reference to the current route definition.
     * The route definition contains:
     *
     *   - `controller`: The controller constructor as defined in the route definition.
     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for
     *     controller instantiation. The `locals` contain
     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:
     *
     *     - `$scope` - The current route scope.
     *     - `$template` - The current route template HTML.
     *
     *     The `locals` will be assigned to the route scope's `$resolve` property. You can override
     *     the property name, using `resolveAs` in the route definition. See
     *     {@link ngRoute.$routeProvider $routeProvider} for more info.
     *
     * @property {Object} routes Object with all route configuration Objects as its properties.
     *
     * @description
     * `$route` is used for deep-linking URLs to controllers and views (HTML partials).
     * It watches `$location.url()` and tries to map the path to an existing route definition.
     *
     * Requires the {@link ngRoute `ngRoute`} module to be installed.
     *
     * You can define routes through {@link ngRoute.$routeProvider $routeProvider}'s API.
     *
     * The `$route` service is typically used in conjunction with the
     * {@link ngRoute.directive:ngView `ngView`} directive and the
     * {@link ngRoute.$routeParams `$routeParams`} service.
     *
     * @example
     * This example shows how changing the URL hash causes the `$route` to match a route against the
     * URL, and the `ngView` pulls in the partial.
     *
     * <example name="$route-service" module="ngRouteExample"
     *          deps="angular-route.js" fixBase="true">
     *   <file name="index.html">
     *     <div ng-controller="MainController">
     *       Choose:
     *       <a href="Book/Moby">Moby</a> |
     *       <a href="Book/Moby/ch/1">Moby: Ch1</a> |
     *       <a href="Book/Gatsby">Gatsby</a> |
     *       <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
     *       <a href="Book/Scarlet">Scarlet Letter</a><br/>
     *
     *       <div ng-view></div>
     *
     *       <hr />
     *
     *       <pre>$location.path() = {{$location.path()}}</pre>
     *       <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>
     *       <pre>$route.current.params = {{$route.current.params}}</pre>
     *       <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>
     *       <pre>$routeParams = {{$routeParams}}</pre>
     *     </div>
     *   </file>
     *
     *   <file name="book.html">
     *     controller: {{name}}<br />
     *     Book Id: {{params.bookId}}<br />
     *   </file>
     *
     *   <file name="chapter.html">
     *     controller: {{name}}<br />
     *     Book Id: {{params.bookId}}<br />
     *     Chapter Id: {{params.chapterId}}
     *   </file>
     *
     *   <file name="script.js">
     *     angular.module('ngRouteExample', ['ngRoute'])
     *
     *      .controller('MainController', function($scope, $route, $routeParams, $location) {
     *          $scope.$route = $route;
     *          $scope.$location = $location;
     *          $scope.$routeParams = $routeParams;
     *      })
     *
     *      .controller('BookController', function($scope, $routeParams) {
     *          $scope.name = "BookController";
     *          $scope.params = $routeParams;
     *      })
     *
     *      .controller('ChapterController', function($scope, $routeParams) {
     *          $scope.name = "ChapterController";
     *          $scope.params = $routeParams;
     *      })
     *
     *     .config(function($routeProvider, $locationProvider) {
     *       $routeProvider
     *        .when('/Book/:bookId', {
     *         templateUrl: 'book.html',
     *         controller: 'BookController',
     *         resolve: {
     *           // I will cause a 1 second delay
     *           delay: function($q, $timeout) {
     *             var delay = $q.defer();
     *             $timeout(delay.resolve, 1000);
     *             return delay.promise;
     *           }
     *         }
     *       })
     *       .when('/Book/:bookId/ch/:chapterId', {
     *         templateUrl: 'chapter.html',
     *         controller: 'ChapterController'
     *       });
     *
     *       // configure html5 to get links working on jsfiddle
     *       $locationProvider.html5Mode(true);
     *     });
     *
     *   </file>
     *
     *   <file name="protractor.js" type="protractor">
     *     it('should load and compile correct template', function() {
     *       element(by.linkText('Moby: Ch1')).click();
     *       var content = element(by.css('[ng-view]')).getText();
     *       expect(content).toMatch(/controller\: ChapterController/);
     *       expect(content).toMatch(/Book Id\: Moby/);
     *       expect(content).toMatch(/Chapter Id\: 1/);
     *
     *       element(by.partialLinkText('Scarlet')).click();
     *
     *       content = element(by.css('[ng-view]')).getText();
     *       expect(content).toMatch(/controller\: BookController/);
     *       expect(content).toMatch(/Book Id\: Scarlet/);
     *     });
     *   </file>
     * </example>
     */

    /**
     * @ngdoc event
     * @name $route#$routeChangeStart
     * @eventType broadcast on root scope
     * @description
     * Broadcasted before a route change. At this  point the route services starts
     * resolving all of the dependencies needed for the route change to occur.
     * Typically this involves fetching the view template as well as any dependencies
     * defined in `resolve` route property. Once  all of the dependencies are resolved
     * `$routeChangeSuccess` is fired.
     *
     * The route change (and the `$location` change that triggered it) can be prevented
     * by calling `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on}
     * for more details about event object.
     *
     * @param {Object} angularEvent Synthetic event object.
     * @param {Route} next Future route information.
     * @param {Route} current Current route information.
     */

    /**
     * @ngdoc event
     * @name $route#$routeChangeSuccess
     * @eventType broadcast on root scope
     * @description
     * Broadcasted after a route change has happened successfully.
     * The `resolve` dependencies are now available in the `current.locals` property.
     *
     * {@link ngRoute.directive:ngView ngView} listens for the directive
     * to instantiate the controller and render the view.
     *
     * @param {Object} angularEvent Synthetic event object.
     * @param {Route} current Current route information.
     * @param {Route|Undefined} previous Previous route information, or undefined if current is
     * first route entered.
     */

    /**
     * @ngdoc event
     * @name $route#$routeChangeError
     * @eventType broadcast on root scope
     * @description
     * Broadcasted if any of the resolve promises are rejected.
     *
     * @param {Object} angularEvent Synthetic event object
     * @param {Route} current Current route information.
     * @param {Route} previous Previous route information.
     * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.
     */

    /**
     * @ngdoc event
     * @name $route#$routeUpdate
     * @eventType broadcast on root scope
     * @description
     * The `reloadOnSearch` property has been set to false, and we are reusing the same
     * instance of the Controller.
     *
     * @param {Object} angularEvent Synthetic event object
     * @param {Route} current Current/previous route information.
     */

    var forceReload = false,
        preparedRoute,
        preparedRouteIsUpdateOnly,
        $route = {
          routes: routes,

          /**
           * @ngdoc method
           * @name $route#reload
           *
           * @description
           * Causes `$route` service to reload the current route even if
           * {@link ng.$location $location} hasn't changed.
           *
           * As a result of that, {@link ngRoute.directive:ngView ngView}
           * creates new scope and reinstantiates the controller.
           */
          reload: function() {
            forceReload = true;

            var fakeLocationEvent = {
              defaultPrevented: false,
              preventDefault: function fakePreventDefault() {
                this.defaultPrevented = true;
                forceReload = false;
              }
            };

            $rootScope.$evalAsync(function() {
              prepareRoute(fakeLocationEvent);
              if (!fakeLocationEvent.defaultPrevented) commitRoute();
            });
          },

          /**
           * @ngdoc method
           * @name $route#updateParams
           *
           * @description
           * Causes `$route` service to update the current URL, replacing
           * current route parameters with those specified in `newParams`.
           * Provided property names that match the route's path segment
           * definitions will be interpolated into the location's path, while
           * remaining properties will be treated as query params.
           *
           * @param {!Object<string, string>} newParams mapping of URL parameter names to values
           */
          updateParams: function(newParams) {
            if (this.current && this.current.$$route) {
              newParams = angular.extend({}, this.current.params, newParams);
              $location.path(interpolate(this.current.$$route.originalPath, newParams));
              // interpolate modifies newParams, only query params are left
              $location.search(newParams);
            } else {
              throw $routeMinErr('norout', 'Tried updating route when with no current route');
            }
          }
        };

    $rootScope.$on('$locationChangeStart', prepareRoute);
    $rootScope.$on('$locationChangeSuccess', commitRoute);

    return $route;

    /////////////////////////////////////////////////////

    /**
     * @param on {string} current url
     * @param route {Object} route regexp to match the url against
     * @return {?Object}
     *
     * @description
     * Check if the route matches the current url.
     *
     * Inspired by match in
     * visionmedia/express/lib/router/router.js.
     */
    function switchRouteMatcher(on, route) {
      var keys = route.keys,
          params = {};

      if (!route.regexp) return null;

      var m = route.regexp.exec(on);
      if (!m) return null;

      for (var i = 1, len = m.length; i < len; ++i) {
        var key = keys[i - 1];

        var val = m[i];

        if (key && val) {
          params[key.name] = val;
        }
      }
      return params;
    }

    function prepareRoute($locationEvent) {
      var lastRoute = $route.current;

      preparedRoute = parseRoute();
      preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route
          && angular.equals(preparedRoute.pathParams, lastRoute.pathParams)
          && !preparedRoute.reloadOnSearch && !forceReload;

      if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {
        if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {
          if ($locationEvent) {
            $locationEvent.preventDefault();
          }
        }
      }
    }

    function commitRoute() {
      var lastRoute = $route.current;
      var nextRoute = preparedRoute;

      if (preparedRouteIsUpdateOnly) {
        lastRoute.params = nextRoute.params;
        angular.copy(lastRoute.params, $routeParams);
        $rootScope.$broadcast('$routeUpdate', lastRoute);
      } else if (nextRoute || lastRoute) {
        forceReload = false;
        $route.current = nextRoute;
        if (nextRoute) {
          if (nextRoute.redirectTo) {
            if (angular.isString(nextRoute.redirectTo)) {
              $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params)
                       .replace();
            } else {
              $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search()))
                       .replace();
            }
          }
        }

        $q.when(nextRoute).
          then(function() {
            if (nextRoute) {
              var locals = angular.extend({}, nextRoute.resolve),
                  template, templateUrl;

              angular.forEach(locals, function(value, key) {
                locals[key] = angular.isString(value) ?
                    $injector.get(value) : $injector.invoke(value, null, null, key);
              });

              if (angular.isDefined(template = nextRoute.template)) {
                if (angular.isFunction(template)) {
                  template = template(nextRoute.params);
                }
              } else if (angular.isDefined(templateUrl = nextRoute.templateUrl)) {
                if (angular.isFunction(templateUrl)) {
                  templateUrl = templateUrl(nextRoute.params);
                }
                if (angular.isDefined(templateUrl)) {
                  nextRoute.loadedTemplateUrl = $sce.valueOf(templateUrl);
                  template = $templateRequest(templateUrl);
                }
              }
              if (angular.isDefined(template)) {
                locals['$template'] = template;
              }
              return $q.all(locals);
            }
          }).
          then(function(locals) {
            // after route change
            if (nextRoute == $route.current) {
              if (nextRoute) {
                nextRoute.locals = locals;
                angular.copy(nextRoute.params, $routeParams);
              }
              $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);
            }
          }, function(error) {
            if (nextRoute == $route.current) {
              $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);
            }
          });
      }
    }


    /**
     * @returns {Object} the current active route, by matching it against the URL
     */
    function parseRoute() {
      // Match a route
      var params, match;
      angular.forEach(routes, function(route, path) {
        if (!match && (params = switchRouteMatcher($location.path(), route))) {
          match = inherit(route, {
            params: angular.extend({}, $location.search(), params),
            pathParams: params});
          match.$$route = route;
        }
      });
      // No route matched; fallback to "otherwise" route
      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});
    }

    /**
     * @returns {string} interpolation of the redirect path with the parameters
     */
    function interpolate(string, params) {
      var result = [];
      angular.forEach((string || '').split(':'), function(segment, i) {
        if (i === 0) {
          result.push(segment);
        } else {
          var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/);
          var key = segmentMatch[1];
          result.push(params[key]);
          result.push(segmentMatch[2] || '');
          delete params[key];
        }
      });
      return result.join('');
    }
  }];
}

ngRouteModule.provider('$routeParams', $RouteParamsProvider);


/**
 * @ngdoc service
 * @name $routeParams
 * @requires $route
 *
 * @description
 * The `$routeParams` service allows you to retrieve the current set of route parameters.
 *
 * Requires the {@link ngRoute `ngRoute`} module to be installed.
 *
 * The route parameters are a combination of {@link ng.$location `$location`}'s
 * {@link ng.$location#search `search()`} and {@link ng.$location#path `path()`}.
 * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.
 *
 * In case of parameter name collision, `path` params take precedence over `search` params.
 *
 * The service guarantees that the identity of the `$routeParams` object will remain unchanged
 * (but its properties will likely change) even when a route change occurs.
 *
 * Note that the `$routeParams` are only updated *after* a route change completes successfully.
 * This means that you cannot rely on `$routeParams` being correct in route resolve functions.
 * Instead you can use `$route.current.params` to access the new route's parameters.
 *
 * @example
 * ```js
 *  // Given:
 *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby
 *  // Route: /Chapter/:chapterId/Section/:sectionId
 *  //
 *  // Then
 *  $routeParams ==> {chapterId:'1', sectionId:'2', search:'moby'}
 * ```
 */
function $RouteParamsProvider() {
  this.$get = function() { return {}; };
}

ngRouteModule.directive('ngView', ngViewFactory);
ngRouteModule.directive('ngView', ngViewFillContentFactory);


/**
 * @ngdoc directive
 * @name ngView
 * @restrict ECA
 *
 * @description
 * # Overview
 * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by
 * including the rendered template of the current route into the main layout (`index.html`) file.
 * Every time the current route changes, the included view changes with it according to the
 * configuration of the `$route` service.
 *
 * Requires the {@link ngRoute `ngRoute`} module to be installed.
 *
 * @animations
 * | Animation                        | Occurs                              |
 * |----------------------------------|-------------------------------------|
 * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM |
 * | {@link ng.$animate#leave leave}  | when the old element is removed from to the DOM  |
 *
 * The enter and leave animation occur concurrently.
 *
 * @knownIssue If `ngView` is contained in an asynchronously loaded template (e.g. in another
 *             directive's templateUrl or in a template loaded using `ngInclude`), then you need to
 *             make sure that `$route` is instantiated in time to capture the initial
 *             `$locationChangeStart` event and load the appropriate view. One way to achieve this
 *             is to have it as a dependency in a `.run` block:
 *             `myModule.run(['$route', function() {}]);`
 *
 * @scope
 * @priority 400
 * @param {string=} onload Expression to evaluate whenever the view updates.
 *
 * @param {string=} autoscroll Whether `ngView` should call {@link ng.$anchorScroll
 *                  $anchorScroll} to scroll the viewport after the view is updated.
 *
 *                  - If the attribute is not set, disable scrolling.
 *                  - If the attribute is set without value, enable scrolling.
 *                  - Otherwise enable scrolling only if the `autoscroll` attribute value evaluated
 *                    as an expression yields a truthy value.
 * @example
    <example name="ngView-directive" module="ngViewExample"
             deps="angular-route.js;angular-animate.js"
             animations="true" fixBase="true">
      <file name="index.html">
        <div ng-controller="MainCtrl as main">
          Choose:
          <a href="Book/Moby">Moby</a> |
          <a href="Book/Moby/ch/1">Moby: Ch1</a> |
          <a href="Book/Gatsby">Gatsby</a> |
          <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
          <a href="Book/Scarlet">Scarlet Letter</a><br/>

          <div class="view-animate-container">
            <div ng-view class="view-animate"></div>
          </div>
          <hr />

          <pre>$location.path() = {{main.$location.path()}}</pre>
          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>
          <pre>$route.current.params = {{main.$route.current.params}}</pre>
          <pre>$routeParams = {{main.$routeParams}}</pre>
        </div>
      </file>

      <file name="book.html">
        <div>
          controller: {{book.name}}<br />
          Book Id: {{book.params.bookId}}<br />
        </div>
      </file>

      <file name="chapter.html">
        <div>
          controller: {{chapter.name}}<br />
          Book Id: {{chapter.params.bookId}}<br />
          Chapter Id: {{chapter.params.chapterId}}
        </div>
      </file>

      <file name="animations.css">
        .view-animate-container {
          position:relative;
          height:100px!important;
          background:white;
          border:1px solid black;
          height:40px;
          overflow:hidden;
        }

        .view-animate {
          padding:10px;
        }

        .view-animate.ng-enter, .view-animate.ng-leave {
          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;

          display:block;
          width:100%;
          border-left:1px solid black;

          position:absolute;
          top:0;
          left:0;
          right:0;
          bottom:0;
          padding:10px;
        }

        .view-animate.ng-enter {
          left:100%;
        }
        .view-animate.ng-enter.ng-enter-active {
          left:0;
        }
        .view-animate.ng-leave.ng-leave-active {
          left:-100%;
        }
      </file>

      <file name="script.js">
        angular.module('ngViewExample', ['ngRoute', 'ngAnimate'])
          .config(['$routeProvider', '$locationProvider',
            function($routeProvider, $locationProvider) {
              $routeProvider
                .when('/Book/:bookId', {
                  templateUrl: 'book.html',
                  controller: 'BookCtrl',
                  controllerAs: 'book'
                })
                .when('/Book/:bookId/ch/:chapterId', {
                  templateUrl: 'chapter.html',
                  controller: 'ChapterCtrl',
                  controllerAs: 'chapter'
                });

              $locationProvider.html5Mode(true);
          }])
          .controller('MainCtrl', ['$route', '$routeParams', '$location',
            function($route, $routeParams, $location) {
              this.$route = $route;
              this.$location = $location;
              this.$routeParams = $routeParams;
          }])
          .controller('BookCtrl', ['$routeParams', function($routeParams) {
            this.name = "BookCtrl";
            this.params = $routeParams;
          }])
          .controller('ChapterCtrl', ['$routeParams', function($routeParams) {
            this.name = "ChapterCtrl";
            this.params = $routeParams;
          }]);

      </file>

      <file name="protractor.js" type="protractor">
        it('should load and compile correct template', function() {
          element(by.linkText('Moby: Ch1')).click();
          var content = element(by.css('[ng-view]')).getText();
          expect(content).toMatch(/controller\: ChapterCtrl/);
          expect(content).toMatch(/Book Id\: Moby/);
          expect(content).toMatch(/Chapter Id\: 1/);

          element(by.partialLinkText('Scarlet')).click();

          content = element(by.css('[ng-view]')).getText();
          expect(content).toMatch(/controller\: BookCtrl/);
          expect(content).toMatch(/Book Id\: Scarlet/);
        });
      </file>
    </example>
 */


/**
 * @ngdoc event
 * @name ngView#$viewContentLoaded
 * @eventType emit on the current ngView scope
 * @description
 * Emitted every time the ngView content is reloaded.
 */
ngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];
function ngViewFactory($route, $anchorScroll, $animate) {
  return {
    restrict: 'ECA',
    terminal: true,
    priority: 400,
    transclude: 'element',
    link: function(scope, $element, attr, ctrl, $transclude) {
        var currentScope,
            currentElement,
            previousLeaveAnimation,
            autoScrollExp = attr.autoscroll,
            onloadExp = attr.onload || '';

        scope.$on('$routeChangeSuccess', update);
        update();

        function cleanupLastView() {
          if (previousLeaveAnimation) {
            $animate.cancel(previousLeaveAnimation);
            previousLeaveAnimation = null;
          }

          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if (currentElement) {
            previousLeaveAnimation = $animate.leave(currentElement);
            previousLeaveAnimation.then(function() {
              previousLeaveAnimation = null;
            });
            currentElement = null;
          }
        }

        function update() {
          var locals = $route.current && $route.current.locals,
              template = locals && locals.$template;

          if (angular.isDefined(template)) {
            var newScope = scope.$new();
            var current = $route.current;

            // Note: This will also link all children of ng-view that were contained in the original
            // html. If that content contains controllers, ... they could pollute/change the scope.
            // However, using ng-view on an element with additional content does not make sense...
            // Note: We can't remove them in the cloneAttchFn of $transclude as that
            // function is called before linking the content, which would apply child
            // directives to non existing elements.
            var clone = $transclude(newScope, function(clone) {
              $animate.enter(clone, null, currentElement || $element).then(function onNgViewEnter() {
                if (angular.isDefined(autoScrollExp)
                  && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }
              });
              cleanupLastView();
            });

            currentElement = clone;
            currentScope = current.scope = newScope;
            currentScope.$emit('$viewContentLoaded');
            currentScope.$eval(onloadExp);
          } else {
            cleanupLastView();
          }
        }
    }
  };
}

// This directive is called during the $transclude call of the first `ngView` directive.
// It will replace and compile the content of the element with the loaded template.
// We need this directive so that the element content is already filled when
// the link function of another directive on the same element as ngView
// is called.
ngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];
function ngViewFillContentFactory($compile, $controller, $route) {
  return {
    restrict: 'ECA',
    priority: -400,
    link: function(scope, $element) {
      var current = $route.current,
          locals = current.locals;

      $element.html(locals.$template);

      var link = $compile($element.contents());

      if (current.controller) {
        locals.$scope = scope;
        var controller = $controller(current.controller, locals);
        if (current.controllerAs) {
          scope[current.controllerAs] = controller;
        }
        $element.data('$ngControllerController', controller);
        $element.children().data('$ngControllerController', controller);
      }
      scope[current.resolveAs || '$resolve'] = locals;

      link(scope);
    }
  };
}


})(window, window.angular);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0): modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */
var Modal = function ($) {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'modal';
  var VERSION = '4.0.0';
  var DATA_KEY = 'bs.modal';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 300;
  var BACKDROP_TRANSITION_DURATION = 150;
  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

  var Default = {
    backdrop: true,
    keyboard: true,
    focus: true,
    show: true
  };
  var DefaultType = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean',
    show: 'boolean'
  };
  var Event = {
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    FOCUSIN: "focusin" + EVENT_KEY,
    RESIZE: "resize" + EVENT_KEY,
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY,
    KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY,
    MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY,
    MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector = {
    DIALOG: '.modal-dialog',
    DATA_TOGGLE: '[data-toggle="modal"]',
    DATA_DISMISS: '[data-dismiss="modal"]',
    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
    STICKY_CONTENT: '.sticky-top',
    NAVBAR_TOGGLER: '.navbar-toggler'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Modal =
  /*#__PURE__*/
  function () {
    function Modal(element, config) {
      this._config = this._getConfig(config);
      this._element = element;
      this._dialog = $(element).find(Selector.DIALOG)[0];
      this._backdrop = null;
      this._isShown = false;
      this._isBodyOverflowing = false;
      this._ignoreBackdropClick = false;
      this._originalBodyPadding = 0;
      this._scrollbarWidth = 0;
    } // Getters


    var _proto = Modal.prototype;

    // Public
    _proto.toggle = function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    };

    _proto.show = function show(relatedTarget) {
      var _this = this;

      if (this._isTransitioning || this._isShown) {
        return;
      }

      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
        this._isTransitioning = true;
      }

      var showEvent = $.Event(Event.SHOW, {
        relatedTarget: relatedTarget
      });
      $(this._element).trigger(showEvent);

      if (this._isShown || showEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = true;

      this._checkScrollbar();

      this._setScrollbar();

      this._adjustDialog();

      $(document.body).addClass(ClassName.OPEN);

      this._setEscapeEvent();

      this._setResizeEvent();

      $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
        return _this.hide(event);
      });
      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
        $(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {
          if ($(event.target).is(_this._element)) {
            _this._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () {
        return _this._showElement(relatedTarget);
      });
    };

    _proto.hide = function hide(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      if (this._isTransitioning || !this._isShown) {
        return;
      }

      var hideEvent = $.Event(Event.HIDE);
      $(this._element).trigger(hideEvent);

      if (!this._isShown || hideEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = false;
      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

      if (transition) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      $(document).off(Event.FOCUSIN);
      $(this._element).removeClass(ClassName.SHOW);
      $(this._element).off(Event.CLICK_DISMISS);
      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);

      if (transition) {
        $(this._element).one(Util.TRANSITION_END, function (event) {
          return _this2._hideModal(event);
        }).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        this._hideModal();
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      $(window, document, this._element, this._backdrop).off(EVENT_KEY);
      this._config = null;
      this._element = null;
      this._dialog = null;
      this._backdrop = null;
      this._isShown = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._scrollbarWidth = null;
    };

    _proto.handleUpdate = function handleUpdate() {
      this._adjustDialog();
    }; // Private


    _proto._getConfig = function _getConfig(config) {
      config = _extends({}, Default, config);
      Util.typeCheckConfig(NAME, config, DefaultType);
      return config;
    };

    _proto._showElement = function _showElement(relatedTarget) {
      var _this3 = this;

      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // Don't move modal's DOM position
        document.body.appendChild(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.scrollTop = 0;

      if (transition) {
        Util.reflow(this._element);
      }

      $(this._element).addClass(ClassName.SHOW);

      if (this._config.focus) {
        this._enforceFocus();
      }

      var shownEvent = $.Event(Event.SHOWN, {
        relatedTarget: relatedTarget
      });

      var transitionComplete = function transitionComplete() {
        if (_this3._config.focus) {
          _this3._element.focus();
        }

        _this3._isTransitioning = false;
        $(_this3._element).trigger(shownEvent);
      };

      if (transition) {
        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        transitionComplete();
      }
    };

    _proto._enforceFocus = function _enforceFocus() {
      var _this4 = this;

      $(document).off(Event.FOCUSIN) // Guard against infinite focus loop
      .on(Event.FOCUSIN, function (event) {
        if (document !== event.target && _this4._element !== event.target && $(_this4._element).has(event.target).length === 0) {
          _this4._element.focus();
        }
      });
    };

    _proto._setEscapeEvent = function _setEscapeEvent() {
      var _this5 = this;

      if (this._isShown && this._config.keyboard) {
        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
          if (event.which === ESCAPE_KEYCODE) {
            event.preventDefault();

            _this5.hide();
          }
        });
      } else if (!this._isShown) {
        $(this._element).off(Event.KEYDOWN_DISMISS);
      }
    };

    _proto._setResizeEvent = function _setResizeEvent() {
      var _this6 = this;

      if (this._isShown) {
        $(window).on(Event.RESIZE, function (event) {
          return _this6.handleUpdate(event);
        });
      } else {
        $(window).off(Event.RESIZE);
      }
    };

    _proto._hideModal = function _hideModal() {
      var _this7 = this;

      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._isTransitioning = false;

      this._showBackdrop(function () {
        $(document.body).removeClass(ClassName.OPEN);

        _this7._resetAdjustments();

        _this7._resetScrollbar();

        $(_this7._element).trigger(Event.HIDDEN);
      });
    };

    _proto._removeBackdrop = function _removeBackdrop() {
      if (this._backdrop) {
        $(this._backdrop).remove();
        this._backdrop = null;
      }
    };

    _proto._showBackdrop = function _showBackdrop(callback) {
      var _this8 = this;

      var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';

      if (this._isShown && this._config.backdrop) {
        var doAnimate = Util.supportsTransitionEnd() && animate;
        this._backdrop = document.createElement('div');
        this._backdrop.className = ClassName.BACKDROP;

        if (animate) {
          $(this._backdrop).addClass(animate);
        }

        $(this._backdrop).appendTo(document.body);
        $(this._element).on(Event.CLICK_DISMISS, function (event) {
          if (_this8._ignoreBackdropClick) {
            _this8._ignoreBackdropClick = false;
            return;
          }

          if (event.target !== event.currentTarget) {
            return;
          }

          if (_this8._config.backdrop === 'static') {
            _this8._element.focus();
          } else {
            _this8.hide();
          }
        });

        if (doAnimate) {
          Util.reflow(this._backdrop);
        }

        $(this._backdrop).addClass(ClassName.SHOW);

        if (!callback) {
          return;
        }

        if (!doAnimate) {
          callback();
          return;
        }

        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
      } else if (!this._isShown && this._backdrop) {
        $(this._backdrop).removeClass(ClassName.SHOW);

        var callbackRemove = function callbackRemove() {
          _this8._removeBackdrop();

          if (callback) {
            callback();
          }
        };

        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
        } else {
          callbackRemove();
        }
      } else if (callback) {
        callback();
      }
    }; // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // todo (fat): these should probably be refactored out of modal.js
    // ----------------------------------------------------------------------


    _proto._adjustDialog = function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!this._isBodyOverflowing && isModalOverflowing) {
        this._element.style.paddingLeft = this._scrollbarWidth + "px";
      }

      if (this._isBodyOverflowing && !isModalOverflowing) {
        this._element.style.paddingRight = this._scrollbarWidth + "px";
      }
    };

    _proto._resetAdjustments = function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    };

    _proto._checkScrollbar = function _checkScrollbar() {
      var rect = document.body.getBoundingClientRect();
      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
    };

    _proto._setScrollbar = function _setScrollbar() {
      var _this9 = this;

      if (this._isBodyOverflowing) {
        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
        // Adjust fixed content padding
        $(Selector.FIXED_CONTENT).each(function (index, element) {
          var actualPadding = $(element)[0].style.paddingRight;
          var calculatedPadding = $(element).css('padding-right');
          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px");
        }); // Adjust sticky content margin

        $(Selector.STICKY_CONTENT).each(function (index, element) {
          var actualMargin = $(element)[0].style.marginRight;
          var calculatedMargin = $(element).css('margin-right');
          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");
        }); // Adjust navbar-toggler margin

        $(Selector.NAVBAR_TOGGLER).each(function (index, element) {
          var actualMargin = $(element)[0].style.marginRight;
          var calculatedMargin = $(element).css('margin-right');
          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this9._scrollbarWidth + "px");
        }); // Adjust body padding

        var actualPadding = document.body.style.paddingRight;
        var calculatedPadding = $('body').css('padding-right');
        $('body').data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
      }
    };

    _proto._resetScrollbar = function _resetScrollbar() {
      // Restore fixed content padding
      $(Selector.FIXED_CONTENT).each(function (index, element) {
        var padding = $(element).data('padding-right');

        if (typeof padding !== 'undefined') {
          $(element).css('padding-right', padding).removeData('padding-right');
        }
      }); // Restore sticky content and navbar-toggler margin

      $(Selector.STICKY_CONTENT + ", " + Selector.NAVBAR_TOGGLER).each(function (index, element) {
        var margin = $(element).data('margin-right');

        if (typeof margin !== 'undefined') {
          $(element).css('margin-right', margin).removeData('margin-right');
        }
      }); // Restore body padding

      var padding = $('body').data('padding-right');

      if (typeof padding !== 'undefined') {
        $('body').css('padding-right', padding).removeData('padding-right');
      }
    };

    _proto._getScrollbarWidth = function _getScrollbarWidth() {
      // thx d.walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
      document.body.appendChild(scrollDiv);
      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    }; // Static


    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        var _config = _extends({}, Modal.Default, $(this).data(), typeof config === 'object' && config);

        if (!data) {
          data = new Modal(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config](relatedTarget);
        } else if (_config.show) {
          data.show(relatedTarget);
        }
      });
    };

    _createClass(Modal, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);

    return Modal;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
    var _this10 = this;

    var target;
    var selector = Util.getSelectorFromElement(this);

    if (selector) {
      target = $(selector)[0];
    }

    var config = $(target).data(DATA_KEY) ? 'toggle' : _extends({}, $(target).data(), $(this).data());

    if (this.tagName === 'A' || this.tagName === 'AREA') {
      event.preventDefault();
    }

    var $target = $(target).one(Event.SHOW, function (showEvent) {
      if (showEvent.isDefaultPrevented()) {
        // Only register focus restorer if modal will actually get shown
        return;
      }

      $target.one(Event.HIDDEN, function () {
        if ($(_this10).is(':visible')) {
          _this10.focus();
        }
      });
    });

    Modal._jQueryInterface.call($(target), config, this);
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Modal._jQueryInterface;
  $.fn[NAME].Constructor = Modal;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Modal._jQueryInterface;
  };

  return Modal;
}($);
//# sourceMappingURL=modal.js.map
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0): tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */
var Tab = function ($) {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'tab';
  var VERSION = '4.0.0';
  var DATA_KEY = 'bs.tab';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 150;
  var Event = {
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active',
    DISABLED: 'disabled',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector = {
    DROPDOWN: '.dropdown',
    NAV_LIST_GROUP: '.nav, .list-group',
    ACTIVE: '.active',
    ACTIVE_UL: '> li > .active',
    DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
    DROPDOWN_TOGGLE: '.dropdown-toggle',
    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(element) {
      this._element = element;
    } // Getters


    var _proto = Tab.prototype;

    // Public
    _proto.show = function show() {
      var _this = this;

      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {
        return;
      }

      var target;
      var previous;
      var listElement = $(this._element).closest(Selector.NAV_LIST_GROUP)[0];
      var selector = Util.getSelectorFromElement(this._element);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;
        previous = $.makeArray($(listElement).find(itemSelector));
        previous = previous[previous.length - 1];
      }

      var hideEvent = $.Event(Event.HIDE, {
        relatedTarget: this._element
      });
      var showEvent = $.Event(Event.SHOW, {
        relatedTarget: previous
      });

      if (previous) {
        $(previous).trigger(hideEvent);
      }

      $(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
        return;
      }

      if (selector) {
        target = $(selector)[0];
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        var hiddenEvent = $.Event(Event.HIDDEN, {
          relatedTarget: _this._element
        });
        var shownEvent = $.Event(Event.SHOWN, {
          relatedTarget: previous
        });
        $(previous).trigger(hiddenEvent);
        $(_this._element).trigger(shownEvent);
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._element = null;
    }; // Private


    _proto._activate = function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements;

      if (container.nodeName === 'UL') {
        activeElements = $(container).find(Selector.ACTIVE_UL);
      } else {
        activeElements = $(container).children(Selector.ACTIVE);
      }

      var active = activeElements[0];
      var isTransitioning = callback && Util.supportsTransitionEnd() && active && $(active).hasClass(ClassName.FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, callback);
      };

      if (active && isTransitioning) {
        $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        complete();
      }
    };

    _proto._transitionComplete = function _transitionComplete(element, active, callback) {
      if (active) {
        $(active).removeClass(ClassName.SHOW + " " + ClassName.ACTIVE);
        var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

        if (dropdownChild) {
          $(dropdownChild).removeClass(ClassName.ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      $(element).addClass(ClassName.ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      Util.reflow(element);
      $(element).addClass(ClassName.SHOW);

      if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];

        if (dropdownElement) {
          $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    }; // Static


    Tab._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY);

        if (!data) {
          data = new Tab(this);
          $this.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tab, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }]);

    return Tab;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
    event.preventDefault();

    Tab._jQueryInterface.call($(this), 'show');
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Tab._jQueryInterface;
  $.fn[NAME].Constructor = Tab;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Tab._jQueryInterface;
  };

  return Tab;
}($);
//# sourceMappingURL=tab.js.map
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0): collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */
var Collapse = function ($) {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'collapse';
  var VERSION = '4.0.0';
  var DATA_KEY = 'bs.collapse';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 600;
  var Default = {
    toggle: true,
    parent: ''
  };
  var DefaultType = {
    toggle: 'boolean',
    parent: '(string|element)'
  };
  var Event = {
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    SHOW: 'show',
    COLLAPSE: 'collapse',
    COLLAPSING: 'collapsing',
    COLLAPSED: 'collapsed'
  };
  var Dimension = {
    WIDTH: 'width',
    HEIGHT: 'height'
  };
  var Selector = {
    ACTIVES: '.show, .collapsing',
    DATA_TOGGLE: '[data-toggle="collapse"]'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Collapse =
  /*#__PURE__*/
  function () {
    function Collapse(element, config) {
      this._isTransitioning = false;
      this._element = element;
      this._config = this._getConfig(config);
      this._triggerArray = $.makeArray($("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
      var tabToggles = $(Selector.DATA_TOGGLE);

      for (var i = 0; i < tabToggles.length; i++) {
        var elem = tabToggles[i];
        var selector = Util.getSelectorFromElement(elem);

        if (selector !== null && $(selector).filter(element).length > 0) {
          this._selector = selector;

          this._triggerArray.push(elem);
        }
      }

      this._parent = this._config.parent ? this._getParent() : null;

      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
      }

      if (this._config.toggle) {
        this.toggle();
      }
    } // Getters


    var _proto = Collapse.prototype;

    // Public
    _proto.toggle = function toggle() {
      if ($(this._element).hasClass(ClassName.SHOW)) {
        this.hide();
      } else {
        this.show();
      }
    };

    _proto.show = function show() {
      var _this = this;

      if (this._isTransitioning || $(this._element).hasClass(ClassName.SHOW)) {
        return;
      }

      var actives;
      var activesData;

      if (this._parent) {
        actives = $.makeArray($(this._parent).find(Selector.ACTIVES).filter("[data-parent=\"" + this._config.parent + "\"]"));

        if (actives.length === 0) {
          actives = null;
        }
      }

      if (actives) {
        activesData = $(actives).not(this._selector).data(DATA_KEY);

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      var startEvent = $.Event(Event.SHOW);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      if (actives) {
        Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');

        if (!activesData) {
          $(actives).data(DATA_KEY, null);
        }
      }

      var dimension = this._getDimension();

      $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
      this._element.style[dimension] = 0;

      if (this._triggerArray.length > 0) {
        $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
      }

      this.setTransitioning(true);

      var complete = function complete() {
        $(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
        _this._element.style[dimension] = '';

        _this.setTransitioning(false);

        $(_this._element).trigger(Event.SHOWN);
      };

      if (!Util.supportsTransitionEnd()) {
        complete();
        return;
      }

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll" + capitalizedDimension;
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
      this._element.style[dimension] = this._element[scrollSize] + "px";
    };

    _proto.hide = function hide() {
      var _this2 = this;

      if (this._isTransitioning || !$(this._element).hasClass(ClassName.SHOW)) {
        return;
      }

      var startEvent = $.Event(Event.HIDE);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      var dimension = this._getDimension();

      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
      Util.reflow(this._element);
      $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);

      if (this._triggerArray.length > 0) {
        for (var i = 0; i < this._triggerArray.length; i++) {
          var trigger = this._triggerArray[i];
          var selector = Util.getSelectorFromElement(trigger);

          if (selector !== null) {
            var $elem = $(selector);

            if (!$elem.hasClass(ClassName.SHOW)) {
              $(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
            }
          }
        }
      }

      this.setTransitioning(true);

      var complete = function complete() {
        _this2.setTransitioning(false);

        $(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
      };

      this._element.style[dimension] = '';

      if (!Util.supportsTransitionEnd()) {
        complete();
        return;
      }

      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
    };

    _proto.setTransitioning = function setTransitioning(isTransitioning) {
      this._isTransitioning = isTransitioning;
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._config = null;
      this._parent = null;
      this._element = null;
      this._triggerArray = null;
      this._isTransitioning = null;
    }; // Private


    _proto._getConfig = function _getConfig(config) {
      config = _extends({}, Default, config);
      config.toggle = Boolean(config.toggle); // Coerce string values

      Util.typeCheckConfig(NAME, config, DefaultType);
      return config;
    };

    _proto._getDimension = function _getDimension() {
      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
    };

    _proto._getParent = function _getParent() {
      var _this3 = this;

      var parent = null;

      if (Util.isElement(this._config.parent)) {
        parent = this._config.parent; // It's a jQuery object

        if (typeof this._config.parent.jquery !== 'undefined') {
          parent = this._config.parent[0];
        }
      } else {
        parent = $(this._config.parent)[0];
      }

      var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
      $(parent).find(selector).each(function (i, element) {
        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
      });
      return parent;
    };

    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
      if (element) {
        var isOpen = $(element).hasClass(ClassName.SHOW);

        if (triggerArray.length > 0) {
          $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
        }
      }
    }; // Static


    Collapse._getTargetFromElement = function _getTargetFromElement(element) {
      var selector = Util.getSelectorFromElement(element);
      return selector ? $(selector)[0] : null;
    };

    Collapse._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY);

        var _config = _extends({}, Default, $this.data(), typeof config === 'object' && config);

        if (!data && _config.toggle && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        if (!data) {
          data = new Collapse(this, _config);
          $this.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Collapse, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);

    return Collapse;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.currentTarget.tagName === 'A') {
      event.preventDefault();
    }

    var $trigger = $(this);
    var selector = Util.getSelectorFromElement(this);
    $(selector).each(function () {
      var $target = $(this);
      var data = $target.data(DATA_KEY);
      var config = data ? 'toggle' : $trigger.data();

      Collapse._jQueryInterface.call($target, config);
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Collapse._jQueryInterface;
  $.fn[NAME].Constructor = Collapse;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Collapse._jQueryInterface;
  };

  return Collapse;
}($);
//# sourceMappingURL=collapse.js.map
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0): util.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */
var Util = function ($) {
  /**
   * ------------------------------------------------------------------------
   * Private TransitionEnd Helpers
   * ------------------------------------------------------------------------
   */
  var transition = false;
  var MAX_UID = 1000000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  function toType(obj) {
    return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
  }

  function getSpecialTransitionEndEvent() {
    return {
      bindType: transition.end,
      delegateType: transition.end,
      handle: function handle(event) {
        if ($(event.target).is(this)) {
          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }

        return undefined; // eslint-disable-line no-undefined
      }
    };
  }

  function transitionEndTest() {
    if (typeof window !== 'undefined' && window.QUnit) {
      return false;
    }

    return {
      end: 'transitionend'
    };
  }

  function transitionEndEmulator(duration) {
    var _this = this;

    var called = false;
    $(this).one(Util.TRANSITION_END, function () {
      called = true;
    });
    setTimeout(function () {
      if (!called) {
        Util.triggerTransitionEnd(_this);
      }
    }, duration);
    return this;
  }

  function setTransitionEndSupport() {
    transition = transitionEndTest();
    $.fn.emulateTransitionEnd = transitionEndEmulator;

    if (Util.supportsTransitionEnd()) {
      $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
    }
  }

  function escapeId(selector) {
    // We escape IDs in case of special selectors (selector = '#myId:something')
    // $.escapeSelector does not exist in jQuery < 3
    selector = typeof $.escapeSelector === 'function' ? $.escapeSelector(selector).substr(1) : selector.replace(/(:|\.|\[|\]|,|=|@)/g, '\\$1');
    return selector;
  }
  /**
   * --------------------------------------------------------------------------
   * Public Util Api
   * --------------------------------------------------------------------------
   */


  var Util = {
    TRANSITION_END: 'bsTransitionEnd',
    getUID: function getUID(prefix) {
      do {
        // eslint-disable-next-line no-bitwise
        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
      } while (document.getElementById(prefix));

      return prefix;
    },
    getSelectorFromElement: function getSelectorFromElement(element) {
      var selector = element.getAttribute('data-target');

      if (!selector || selector === '#') {
        selector = element.getAttribute('href') || '';
      } // If it's an ID


      if (selector.charAt(0) === '#') {
        selector = escapeId(selector);
      }

      try {
        var $selector = $(document).find(selector);
        return $selector.length > 0 ? selector : null;
      } catch (err) {
        return null;
      }
    },
    reflow: function reflow(element) {
      return element.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(element) {
      $(element).trigger(transition.end);
    },
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(transition);
    },
    isElement: function isElement(obj) {
      return (obj[0] || obj).nodeType;
    },
    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
      for (var property in configTypes) {
        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
          var expectedTypes = configTypes[property];
          var value = config[property];
          var valueType = value && Util.isElement(value) ? 'element' : toType(value);

          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
          }
        }
      }
    }
  };
  setTransitionEndSupport();
  return Util;
}($);
//# sourceMappingURL=util.js.map
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0): tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */
var Tooltip = function ($) {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'tooltip';
  var VERSION = '4.0.0';
  var DATA_KEY = 'bs.tooltip';
  var EVENT_KEY = "." + DATA_KEY;
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 150;
  var CLASS_PREFIX = 'bs-tooltip';
  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
  var DefaultType = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    offset: '(number|string)',
    container: '(string|element|boolean)',
    fallbackPlacement: '(string|array)',
    boundary: '(string|element)'
  };
  var AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    LEFT: 'left'
  };
  var Default = {
    animation: true,
    template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: true,
    selector: false,
    placement: 'top',
    offset: 0,
    container: false,
    fallbackPlacement: 'flip',
    boundary: 'scrollParent'
  };
  var HoverState = {
    SHOW: 'show',
    OUT: 'out'
  };
  var Event = {
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    INSERTED: "inserted" + EVENT_KEY,
    CLICK: "click" + EVENT_KEY,
    FOCUSIN: "focusin" + EVENT_KEY,
    FOCUSOUT: "focusout" + EVENT_KEY,
    MOUSEENTER: "mouseenter" + EVENT_KEY,
    MOUSELEAVE: "mouseleave" + EVENT_KEY
  };
  var ClassName = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector = {
    TOOLTIP: '.tooltip',
    TOOLTIP_INNER: '.tooltip-inner',
    ARROW: '.arrow'
  };
  var Trigger = {
    HOVER: 'hover',
    FOCUS: 'focus',
    CLICK: 'click',
    MANUAL: 'manual'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Tooltip =
  /*#__PURE__*/
  function () {
    function Tooltip(element, config) {
      /**
       * Check for Popper dependency
       * Popper - https://popper.js.org
       */
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)');
      } // private


      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = '';
      this._activeTrigger = {};
      this._popper = null; // Protected

      this.element = element;
      this.config = this._getConfig(config);
      this.tip = null;

      this._setListeners();
    } // Getters


    var _proto = Tooltip.prototype;

    // Public
    _proto.enable = function enable() {
      this._isEnabled = true;
    };

    _proto.disable = function disable() {
      this._isEnabled = false;
    };

    _proto.toggleEnabled = function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    };

    _proto.toggle = function toggle(event) {
      if (!this._isEnabled) {
        return;
      }

      if (event) {
        var dataKey = this.constructor.DATA_KEY;
        var context = $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {
          this._leave(null, this);

          return;
        }

        this._enter(null, this);
      }
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      $.removeData(this.element, this.constructor.DATA_KEY);
      $(this.element).off(this.constructor.EVENT_KEY);
      $(this.element).closest('.modal').off('hide.bs.modal');

      if (this.tip) {
        $(this.tip).remove();
      }

      this._isEnabled = null;
      this._timeout = null;
      this._hoverState = null;
      this._activeTrigger = null;

      if (this._popper !== null) {
        this._popper.destroy();
      }

      this._popper = null;
      this.element = null;
      this.config = null;
      this.tip = null;
    };

    _proto.show = function show() {
      var _this = this;

      if ($(this.element).css('display') === 'none') {
        throw new Error('Please use show on visible elements');
      }

      var showEvent = $.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        $(this.element).trigger(showEvent);
        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);

        if (showEvent.isDefaultPrevented() || !isInTheDom) {
          return;
        }

        var tip = this.getTipElement();
        var tipId = Util.getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);
        this.element.setAttribute('aria-describedby', tipId);
        this.setContent();

        if (this.config.animation) {
          $(tip).addClass(ClassName.FADE);
        }

        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

        var attachment = this._getAttachment(placement);

        this.addAttachmentClass(attachment);
        var container = this.config.container === false ? document.body : $(this.config.container);
        $(tip).data(this.constructor.DATA_KEY, this);

        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
          $(tip).appendTo(container);
        }

        $(this.element).trigger(this.constructor.Event.INSERTED);
        this._popper = new Popper(this.element, tip, {
          placement: attachment,
          modifiers: {
            offset: {
              offset: this.config.offset
            },
            flip: {
              behavior: this.config.fallbackPlacement
            },
            arrow: {
              element: Selector.ARROW
            },
            preventOverflow: {
              boundariesElement: this.config.boundary
            }
          },
          onCreate: function onCreate(data) {
            if (data.originalPlacement !== data.placement) {
              _this._handlePopperPlacementChange(data);
            }
          },
          onUpdate: function onUpdate(data) {
            _this._handlePopperPlacementChange(data);
          }
        });
        $(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

        if ('ontouchstart' in document.documentElement) {
          $('body').children().on('mouseover', null, $.noop);
        }

        var complete = function complete() {
          if (_this.config.animation) {
            _this._fixTransition();
          }

          var prevHoverState = _this._hoverState;
          _this._hoverState = null;
          $(_this.element).trigger(_this.constructor.Event.SHOWN);

          if (prevHoverState === HoverState.OUT) {
            _this._leave(null, _this);
          }
        };

        if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
        } else {
          complete();
        }
      }
    };

    _proto.hide = function hide(callback) {
      var _this2 = this;

      var tip = this.getTipElement();
      var hideEvent = $.Event(this.constructor.Event.HIDE);

      var complete = function complete() {
        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
          tip.parentNode.removeChild(tip);
        }

        _this2._cleanTipClass();

        _this2.element.removeAttribute('aria-describedby');

        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

        if (_this2._popper !== null) {
          _this2._popper.destroy();
        }

        if (callback) {
          callback();
        }
      };

      $(this.element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      $(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support

      if ('ontouchstart' in document.documentElement) {
        $('body').children().off('mouseover', null, $.noop);
      }

      this._activeTrigger[Trigger.CLICK] = false;
      this._activeTrigger[Trigger.FOCUS] = false;
      this._activeTrigger[Trigger.HOVER] = false;

      if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        complete();
      }

      this._hoverState = '';
    };

    _proto.update = function update() {
      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    }; // Protected


    _proto.isWithContent = function isWithContent() {
      return Boolean(this.getTitle());
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var $tip = $(this.getTipElement());
      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
      $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
    };

    _proto.setElementContent = function setElementContent($element, content) {
      var html = this.config.html;

      if (typeof content === 'object' && (content.nodeType || content.jquery)) {
        // Content is a DOM node or a jQuery
        if (html) {
          if (!$(content).parent().is($element)) {
            $element.empty().append(content);
          }
        } else {
          $element.text($(content).text());
        }
      } else {
        $element[html ? 'html' : 'text'](content);
      }
    };

    _proto.getTitle = function getTitle() {
      var title = this.element.getAttribute('data-original-title');

      if (!title) {
        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
      }

      return title;
    }; // Private


    _proto._getAttachment = function _getAttachment(placement) {
      return AttachmentMap[placement.toUpperCase()];
    };

    _proto._setListeners = function _setListeners() {
      var _this3 = this;

      var triggers = this.config.trigger.split(' ');
      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
            return _this3.toggle(event);
          });
        } else if (trigger !== Trigger.MANUAL) {
          var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
          var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
          $(_this3.element).on(eventIn, _this3.config.selector, function (event) {
            return _this3._enter(event);
          }).on(eventOut, _this3.config.selector, function (event) {
            return _this3._leave(event);
          });
        }

        $(_this3.element).closest('.modal').on('hide.bs.modal', function () {
          return _this3.hide();
        });
      });

      if (this.config.selector) {
        this.config = _extends({}, this.config, {
          trigger: 'manual',
          selector: ''
        });
      } else {
        this._fixTitle();
      }
    };

    _proto._fixTitle = function _fixTitle() {
      var titleType = typeof this.element.getAttribute('data-original-title');

      if (this.element.getAttribute('title') || titleType !== 'string') {
        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
        this.element.setAttribute('title', '');
      }
    };

    _proto._enter = function _enter(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
      }

      if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
        context._hoverState = HoverState.SHOW;
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.SHOW;

      if (!context.config.delay || !context.config.delay.show) {
        context.show();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.SHOW) {
          context.show();
        }
      }, context.config.delay.show);
    };

    _proto._leave = function _leave(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
      }

      if (context._isWithActiveTrigger()) {
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.OUT;

      if (!context.config.delay || !context.config.delay.hide) {
        context.hide();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.OUT) {
          context.hide();
        }
      }, context.config.delay.hide);
    };

    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
      for (var trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    };

    _proto._getConfig = function _getConfig(config) {
      config = _extends({}, this.constructor.Default, $(this.element).data(), config);

      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }

      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }

      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }

      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
      return config;
    };

    _proto._getDelegateConfig = function _getDelegateConfig() {
      var config = {};

      if (this.config) {
        for (var key in this.config) {
          if (this.constructor.Default[key] !== this.config[key]) {
            config[key] = this.config[key];
          }
        }
      }

      return config;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length > 0) {
        $tip.removeClass(tabClass.join(''));
      }
    };

    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {
      this._cleanTipClass();

      this.addAttachmentClass(this._getAttachment(data.placement));
    };

    _proto._fixTransition = function _fixTransition() {
      var tip = this.getTipElement();
      var initConfigAnimation = this.config.animation;

      if (tip.getAttribute('x-placement') !== null) {
        return;
      }

      $(tip).removeClass(ClassName.FADE);
      this.config.animation = false;
      this.hide();
      this.show();
      this.config.animation = initConfigAnimation;
    }; // Static


    Tooltip._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        var _config = typeof config === 'object' && config;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Tooltip(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tooltip, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }]);

    return Tooltip;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME] = Tooltip._jQueryInterface;
  $.fn[NAME].Constructor = Tooltip;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Tooltip._jQueryInterface;
  };

  return Tooltip;
}($, Popper);
//# sourceMappingURL=tooltip.js.map
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0): popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */
var Popover = function ($) {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'popover';
  var VERSION = '4.0.0';
  var DATA_KEY = 'bs.popover';
  var EVENT_KEY = "." + DATA_KEY;
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var CLASS_PREFIX = 'bs-popover';
  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');

  var Default = _extends({}, Tooltip.Default, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
  });

  var DefaultType = _extends({}, Tooltip.DefaultType, {
    content: '(string|element|function)'
  });

  var ClassName = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector = {
    TITLE: '.popover-header',
    CONTENT: '.popover-body'
  };
  var Event = {
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    INSERTED: "inserted" + EVENT_KEY,
    CLICK: "click" + EVENT_KEY,
    FOCUSIN: "focusin" + EVENT_KEY,
    FOCUSOUT: "focusout" + EVENT_KEY,
    MOUSEENTER: "mouseenter" + EVENT_KEY,
    MOUSELEAVE: "mouseleave" + EVENT_KEY
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Popover =
  /*#__PURE__*/
  function (_Tooltip) {
    _inheritsLoose(Popover, _Tooltip);

    function Popover() {
      return _Tooltip.apply(this, arguments) || this;
    }

    var _proto = Popover.prototype;

    // Overrides
    _proto.isWithContent = function isWithContent() {
      return this.getTitle() || this._getContent();
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events

      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());

      var content = this._getContent();

      if (typeof content === 'function') {
        content = content.call(this.element);
      }

      this.setElementContent($tip.find(Selector.CONTENT), content);
      $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
    }; // Private


    _proto._getContent = function _getContent() {
      return this.element.getAttribute('data-content') || this.config.content;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length > 0) {
        $tip.removeClass(tabClass.join(''));
      }
    }; // Static


    Popover._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        var _config = typeof config === 'object' ? config : null;

        if (!data && /destroy|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Popover(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Popover, null, [{
      key: "VERSION",
      // Getters
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }]);

    return Popover;
  }(Tooltip);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME] = Popover._jQueryInterface;
  $.fn[NAME].Constructor = Popover;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Popover._jQueryInterface;
  };

  return Popover;
}($);
//# sourceMappingURL=popover.js.map
$("document").ready(function () {
  if (Modernizr.mq("(min-width: 768px)")) {
    /* Function on expand the navigation menu on clicking profile Initials/Pic  */
    $(".header__nav a").on("click", function () {
      $(".header__nav").toggleClass("open");
      if (!$(".header__nav").hasClass("open"))
        $(".header__nav .profile a").attr("aria-expanded", "false");
      else $(".header__nav .profile a").attr("aria-expanded", "true");
    });
    /* Function on check the event target and collpase the menu  */
    $("body").on("click touchstart", function (e) {
      if (
        !$(e.target).is(".header__nav a") &&
        !$(e.target).is(".header__nav a img") &&
        $(".header__nav").hasClass("open")) {
          $(".header__nav").removeClass("open");
          $(".header__nav .profile a").attr("aria-expanded", "false");
        
      }
    });
  } else {
    /* Function on expand the navigation menu on clicking hamburger in mobile  */
    $(".mobile-nav").click(function () {
      $(".sidenav").css("width", "75%");
      $(".mask").addClass("is-active");
    });
    /* Homepage specific navigation menu on clicking hamburger  */
    $(".homepage.mobile-nav").click(function () {
      $(".homepage__sidenav--mobile").css({
        display: "block",
        width: "75%",
      });
      $(".mask").addClass("is-active");
    });
    /* Function on collpase the navigation menu on clicking outside of the menu  */
    $(".mask").click(function () {
      $(".sidenav").css("width", "0");
      $(".homepage__sidenav--mobile").css("width", "0");
      $(".mask").removeClass("is-active");
    });
  }

  (function ($) {
    /* Adjustments for Safari on Mac */
    if (
      navigator.userAgent.indexOf("Safari") !== -1 &&
      navigator.userAgent.indexOf("Mac") !== -1 &&
      navigator.userAgent.indexOf("Chrome") === -1
    ) {
      $("html").addClass("safari-mac"); // provide a class for the safari-mac specific css to filter with
    }
  })(jQuery);

  /* To check the navigation links height is more than window height*/
  if (
    $(window).height() <
    $(".profile").height() + $(".nav-content").height()
  ) {
    $(".nav-content li:last-child").css("position", "relative");
  }
  if ($(".profile .profile__image").length) {
    $(".profile .profile__image").text("");
  }

  // for interests menu item in profile options dropdown
  $(".sidenav .nav-content .interests-count")
    .parent()
    .html(
      "<button class='interests-count'>1</button><a href='#' class='icon-tag-o'><span>Interests</span></a>"
    );

  // ======== Commenting this since it forces links to be _blank targeted - @bharat ================== //
  // To open the external anchor links in a new tab
  //$('a[href^="http://"],a[href^="https://"]').attr('target','_blank');
});
$(document).ready(function () {
  //Login - Keep me loggedin enable and disabled.
  $(document).on('OTReady', function(){
    //if Cookie function is enabled
    if(cookieComplianceHelperJS.isCookieCategorySelected(3)){
      $(".gigya-keep-me-logged-in").removeClass("stay-signin-checkbox__disabled");
      $(".myD-login-form .gigya-input-checkbox").removeAttr("disabled");
      $(".myD-cookie-setting-link").attr("hidden", "true");
    }else {
      //if Cookie function is disabled
      $(".gigya-keep-me-logged-in").addClass("stay-signin-checkbox__disabled");
      $(".myD-login-form .gigya-input-checkbox").attr("disabled", "disabled");
      $(".myD-cookie-setting-link").removeAttr("hidden");
    }
  });

  $("#business-email").keyup(function () {
    $(".business-email-field").removeClass("error-msg email-error");
    $(".business-email-field").removeClass("email-error");
    $(".email-error").remove();
    $(".business-email-field .bar").css("border-color", "#999");
    $(".business-email-field").removeClass("email-exists-error");
    $(".email-exists-error").remove();
    if (!$(".email-error").length && $(this.value !== "")) {
      if (!validateEmailInputType(this.value)) {
        $(".business-email-field").append(
          "<p class='error-msg email-error'>" + businessEmailError + "</p>"
        );
        $(".business-email-field .bar").css("border-color", "red");
      } else {
        $(".business-email-field").removeClass("error-msg email-error");
        $(".business-email-field").removeClass("email-error");
        $(".email-error").remove();
        $(".business-email-field .bar").css("border-color", "#999");
        getEmailIDInfo(this.value);
      }
    }
  });

  $("#signin-features").hide();
  $(".myD-register__link").click(function () {
    $("#signin-features").hide();
    $("#registration-features, #privacy-statement-section").show();
    $("#myD-reg-signin-nav-tabs a.myD-register-tab").tab("show");
  });
  $(".myD-signin__link").on("click", function () {
    $("#registration-features, #privacy-statement-section").hide();
    $("#signin-features").show();
    $("#myD-reg-signin-nav-tabs a.myD-signin-tab").tab("show");
  });

  $(".myD-register-tab").click(function () {
    $("#signin-features").hide();
    $("#registration-features, #privacy-statement-section").show();
    $("#myD-reg-signin-nav-tabs a.myD-register-tab").tab("show");
  });
  $(".myD-signin-tab").click(function () {
    $("#registration-features, #privacy-statement-section").hide();
    $("#signin-features").show();
    $("#myD-reg-signin-nav-tabs a.myD-signin-tab").tab("show");
    checkSocial();
  });

  $("li[role='tab']").click(function () {
    $("li[role='tab']").attr("aria-selected", "false"); //deselect all the tabs
    $(this).attr("aria-selected", "true"); // select this tab
    var tabpanid = $(this).attr("aria-controls"); //find out what tab panel this tab controls
    var tabpan = $("#" + tabpanid);
    $("div[role='tabpanel']").attr("aria-hidden", "true"); //hide all the panels
    tabpan.attr("aria-hidden", "false"); // show our panel
  });

  // Hide and show for country dropdown
  $("input#country-check").click(function () {
    $(".country-dropdown").toggle();
  });

  // To check if registration tab is open with no cookie or site value present
  var siteParamValue = $.urlParam("site");
  var securedlocInfo = getCookie("myD_siteSelector");
 
  var userFlow = $.urlParam("newUser");

  if (
    siteParamValue === 0 &&
    securedlocInfo === "" &&
    $("#registration").is(":visible") === true &&
    userFlow === 0
  ) {
    $("#modal-site-confirm-language").modal("show");
  }
});
if (pagetype === "registration") {
  jQuery(document).ready(checkSocial);
}
function gatedEmailNotificationCheckQR(response) {
	if (OPTIN_EMAIL_NOTIFICATION === 'true'
			&& response.data.myDeloitte.consent !== undefined
			&& response.data.myDeloitte.consent.profile === true
			&& (response.data.myDeloitte.consent.profileFreq === ""|| response.data.myDeloitte.consent.profileFreq === undefined || response.data.myDeloitte.consent.profileFreq === "undefined" ) ) {
		return true;
	} else {
		return false;
	}
  }
function checkSocial() {
  if (
    $(".myD-reg-signin-wrapper .gigya-screen .gigya-login-provider img").length
  ) {
    $(".myD-reg-signin-wrapper .gigya-screen .gigya-login-provider img").attr(
      "src",
      ""
    );
    $(".myD-reg-signin-wrapper .gigya-screen .gigya-login-provider img").attr(
      "alt",
      ""
    );
    $(
      ".myD-reg-signin-wrapper .gigya-screen .gigya-login-provider img"
    ).replaceWith("<div></div>");
  } else {
    setTimeout(checkSocial, 50);
  }
}

if (pagetype === "registration" || pagetype === "accountsettings") {
  jQuery(document).ready(checkSiteLanguage);
}




function checkSiteLanguage() {
  var siteInfo = getCookie("myD_siteSelector");
  if (
    $(".site-language").length &&
    siteInfo !== "" &&
    $("#site-selector ul li a span").length
  ) {
    // Set Language selector dropdown value on page load
    if (siteInfo) {
      localStorage.setItem("prevSite", siteInfo);
      var langInfo = $(
        "#site-selector ul li a[data-lang=" + siteInfo + "] span"
      ).html();
      $(
        ".myD-registration-headline .site-language, .accounts-settings .site-language"
      ).html(langInfo);

      if (siteInfo === "global-en") {
        $("#country-check").removeAttr("checked");
        $(".country-dropdown").show();
      }
    }
  } else {
    setTimeout(checkSiteLanguage, 50);
  }
}

function encodeHTML(s) {
  return s.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//, "&#x2F;");
}
//akamai will redirect based on the cookie value.
/* When the user clicks on the dropdown value, 
set cookie setSiteSelector and refresh the page. */
function setSiteSelector(val) {
  var siteVal = encodeHTML(val);
  var PAGE_URL = window.location.href;
  var newURL;
  /*Setting the myD_siteSelector cookie value to 1 year from the date of acceptence instead of 2099*/
	var expireDate = new Date();
	expireDate.setFullYear(expireDate.getFullYear() + 1); 
	var expires = "expires=" + expireDate.toUTCString();
  document.cookie =
    "myD_siteSelector=" +
    siteVal +
    "; expires= " + expires; "path=/; secure";
	
  if (PAGE_URL.indexOf("action=qr") > -1 && pagetype === "registration") {
      newURL = PAGE_URL.replace(
      PAGE_URL.substring(PAGE_URL.indexOf("site"), PAGE_URL.indexOf("&p")),
      "site=" + siteVal
    );
    window.location.href = newURL;
  } else if (
    PAGE_URL.indexOf("action=optin") > -1 &&
    pagetype === "registration"
  ) {
      newURL = PAGE_URL.replace(
      PAGE_URL.substring(PAGE_URL.indexOf("site"), PAGE_URL.indexOf("&action")),
      "site=" + siteVal
    );
    window.location.href = newURL;
  } else if (PAGE_URL.indexOf("eventid") > -1 && pagetype === "registration") {
      newURL = PAGE_URL.replace(
      PAGE_URL.substring(PAGE_URL.indexOf("site"), PAGE_URL.indexOf("&pl")),
      "site=" + siteVal
    );
    window.location.href = newURL;
  } else if (
    PAGE_URL.indexOf("resetpwd=true") > -1 &&
    pagetype === "registration"
  ) {
    var refinedPath =
      "https://" + window.location.host + window.location.search;
    window.location.href = refinedPath + "&site=" + val;
  } else if (
    /** Masking the URL refresh for Mydaas in the existing flow of MyD **/
    pagetype !== "accountsettings" &&
    PAGE_URL.indexOf("action=qr") === -1 &&
    mydaas_action === ""
  ) {
    //Updating URL site param since cookie depends on site value
    window.location.href =
      "https://" + document.location.hostname + "/?site=" + val;
  }
}

/*Function to dismiss popover on click of outside*/
$("body").on("click", function (e) {
  //did not click a popover toggle or popover
  if (
    $(e.target).data("toggle") !== "popover" &&
    $(e.target).parents(".popover.in").length === 0
  ) {
    $('[data-toggle="popover"]').popover("hide");
  }
});

$("#confirmSiteLanguage-close").on("click", function () {
  $(".site-language-dropdown,.location-container").removeClass("open");
  $(".location-container").hide();
  $("#modal-site-confirm-language").modal("show");
});

/*function for first and lastname */
function ValidateInput() {
  // Regex to check the valid first and last name
  var Regex = /[!"#$%&()*+\/:;<=>?@[\]^_`{|}\\\~]/;
  if (
    Regex.test($("[name='profile.firstName']").val()) ||
    Regex.test($("[name='profile.lastName']").val())
  ) {
    Regex.test($("[name='profile.firstName']").val())
      ? $(".valid-inputs-first-name").show()
      : $(".valid-inputs-first-name").hide();
    Regex.test($("[name='profile.lastName']").val())
      ? $(".valid-inputs-last-name").show()
      : $(".valid-inputs-last-name").hide();
    return false;
  } else {
    $(".valid-inputs-first-name").hide();
    $(".valid-inputs-last-name").hide();
    return true;
  }
}

//show message if email-id already exists
function showEmailIDInfo(response) {
  $(".business-email-field").removeClass("email-exists-error");
  $(".email-exists-error").remove();
  $(".business-email-field .bar").css("border-color", "#999");

  if (response.isAvailable === false) {
    $(".business-email-field").append(
      "<p class='email-exists-error'>" + email_already_inuse + "</p>"
    );
    $(".business-email-field .bar").css("border-color", "red");
  } else {
    $(".business-email-field").removeClass("email-exists-error");
    $(".email-exists-error").remove();
  }
}
//check if email-id already exists
function getEmailIDInfo(email) {
  var idParams = {
    loginID: email,
    callback: showEmailIDInfo,
  };
  gigya.accounts.isAvailableLoginID(idParams);
}

//VA: Move to registration screen.js
function ssologin(_input) {
  validateEmailInput(_input);
  if (!($("#logindiv").val() === "")) {
    var str1 = $("#logindiv").val().toLowerCase();
    var str2 = "@deloitte";
    var retiredDstring = "@deloitteretired";
    if (str1.indexOf(str2) !== -1 && str1.indexOf(retiredDstring) === -1) {
      var deloitte = $(
        "#myD-login-screenset-container_content button[title='Deloitte']"
      );
      $("#logindiv, #passworddiv").val("");
      deloitte.click();
    }
  }
}

//VA: Move to registration screen.js
function ssojoin(_input) {
  validateEmailInput(_input);
  if (!($("#logindivjoin").val() === "")) {
    var str1 = $("#logindivjoin").val().toLowerCase();
    var str2 = "@deloitte";
    var retiredDstring = "@deloitteretired";
    if (str1.indexOf(str2) !== -1 && str1.indexOf(retiredDstring) === -1) {
      var deloitte = $(
        "#myD-reg-screenset-container_content button[title='Deloitte']"
      );
      $("#logindivjoin").val("");
      deloitte.click();
    }
  }
}

//VA: Move to registration screen.js
function validatefpscreen() {
  var deloitteID = readCookie("DeloitteID");
  if (deloitteID !== "true") {
    $("#modal-forgot-password").modal("show");
    gigya.accounts.showScreenSet(fpParams);
  }
}

/* validates emailid and show error */
//VA: Move to registration screen.js
function validateuser() {
  var emailid = $("#gigya-textbox-loginID").val().toLowerCase();
  var str2 = "@deloitte";
  var retiredDstring = "@deloitteretired";
  if (emailid.indexOf(str2) !== -1 && emailid.indexOf(retiredDstring) === -1) {
    $("#fwd-validataion-msg").show();
    $(".gigya-error-msg-active").hide();
    return false;
  }
}

//VA: Move to registration-screen.js
function setCountryLocation(response) {
  try {
    if (
      locationOfResidence !== "undefined" &&
      locationOfResidence != null &&
      response.loginProvider !== "undefined" &&
      response.loginProvider !== "site"
    ) {
      response.data.myDeloitte.country = locationOfResidence;
    } else {
      if (
        country !== "undefined" &&
        country != null &&
        response.loginProvider !== "undefined" &&
        response.loginProvider !== "site"
      ) {
        var CountryLocale = country.split("-");
        var CountryCode = CountryLocale[0].toUpperCase();
        if (CountryCode != null && CountryCode !== "GLOBAL") {
          response.data.myDeloitte.country = CountryCode;
        } else {
          response.data.myDeloitte.country = "ZZ";
        }
      }
    }
  } catch (err) {
   
  }
}

//VA : shoulbe moved to registration screen
function newUserRedirectIfStateIsIsOptinOrDbrief(response) {
  try {
    var EVENTID = "eventId";
    var step2_page_URL;
    if (
      isOptinOrDbriefOrMyDaaSUser(response) &&
      !fieldCompletionCheck(response)
    ) {
      _satellite.track("registrationSuccess");
      setParametersForNewUser(response);
      var regStateStr = response.data.myDeloitte.regState;
      if (
        regStateStr !== null &&
        regStateStr.indexOf("registration.mydaas") > -1
      ) {
        var mydaas_param = regStateStr.substring(
          regStateStr.lastIndexOf(".mydaas") + 1,
          regStateStr.indexOf("?")
        );
        step2_page_URL =
          regStateStr.indexOf("flow=gated") > -1
            ? "./optin/gated-optsin." + mydaas_param
            : "./progressiveprofile." + mydaas_param;
      } else {
        step2_page_URL = "./optin/gated-optsin.html";
      }

      window.location.replace(step2_page_URL);
    }
    if (
      sessionStorage.getItem(EVENTID) !== null &&
      sessionStorage.getItem(EVENTID) !== ""
    ) {
      setParametersForNewUser(response);
      // redirect
      step2_page_URL = "./optin/gated-optsin.html";
      window.location.replace(step2_page_URL);
    } else {
      if (step2_page_URL === "") {
        // take new user to dashboard if nothing satisfies
        window.location.href = "./dashboard.html";
      }
    }
  } catch (err) {
    
  }
}

//VA: Move to registration-screen.js
function redirectIfReqDomainIsDcomOrDi(response) {
  var PAGETYPE_PROFILE = "profile";
  var PAGETYPE_BOOKMARKS = "bookmarks";
  var PAGETYPE_ACCOUNTSETTINGS = "accountsettings";
  var PAGETYPE_DASHBOARD = "dashboard";
  var PAGETYPE_FEED = "feed";
  var PAGETYPE_SUBSCRIPTIONS = "subscriptions";
  var PAGE_REDIRECT = "pageredirect";
  localStorage.setItem("loggedIn", "true");
  var userProfileFromDCOM = readCookie("USER_DCOM");
  SOCIAL_PROFILE = response;
  userProfileFromDCOM = readCookie("USER_DCOM");
  resetResponseInSessionStorage(response);

  var url = location.href;
  var pageRedirectString;

  try {
    if (url.indexOf("/dashboard.html?requestedBy=" + requestorDomain) !== -1) {
      setItemInSessionStorage(PAGE_REDIRECT, PAGETYPE_DASHBOARD);
      pageRedirectString = "./dashboard.html";
    } else if (
      url.indexOf("/bookmarks.html?requestedBy=" + requestorDomain) !== -1
    ) {
      setItemInSessionStorage(PAGE_REDIRECT, PAGETYPE_BOOKMARKS);
      pageRedirectString = "./bookmarks.html";
    } else if (url.indexOf("/feed.html?requestedBy=" + requestorDomain) !== -1) {
      setItemInSessionStorage(PAGE_REDIRECT, PAGETYPE_FEED);
      pageRedirectString = "./feed.html";
    } else if (
      url.indexOf("/subscriptions.html?requestedBy=" + requestorDomain) !== -1
    ) {
      setItemInSessionStorage(PAGE_REDIRECT, PAGETYPE_SUBSCRIPTIONS);
      pageRedirectString = "./subscriptions.html";
    } else if (
      url.indexOf("/profile.html?requestedBy=" + requestorDomain) !== -1
    ) {
      setItemInSessionStorage(PAGE_REDIRECT, PAGETYPE_PROFILE);
      pageRedirectString = "./profile.html";
    } else if (
      url.indexOf("/accountsettings.html?requestedBy=" + requestorDomain) !== -1
    ) {
      setItemInSessionStorage(PAGE_REDIRECT, PAGETYPE_ACCOUNTSETTINGS);
      pageRedirectString = "./accountsettings.html";
    } else {
      if (
        setItemInSessionStorage.getItem(PAGE_REDIRECT) != null &&
        setItemInSessionStorage.getItem(PAGE_REDIRECT) !== ""
      ) {
        var pageName = setItemInSessionStorage.getItem(PAGE_REDIRECT);
        pageRedirectString = "./" + pageName + ".html";
      } else {
        window.location.reload();
      }
    }
    window.location.href = pageRedirectString;
  } catch (err) {
    
  }
}

/** This calls the generic list serlvet and stores the all select list (drop-down) options values into one JSON array  **/
//VA: Move to registration-screen.js
function loadMyDeloitteGlobalSelectList() {
  var globalSelectListJson = JSON.parse(
    sessionStorage.getItem("globalSelectListJson")
  );
  if (globalSelectListJson == null) {
    var urlpath = window.location.href.replace(
      window.location.pathname.substring(
        window.location.pathname.indexOf("."),
        window.location.pathname.lastIndexOf(".html")
      ),
      ""
    );
    var servletUrl =
      urlpath.substring(0, urlpath.lastIndexOf(".html")) +
      ".deloitte-genlist.json";
    $.ajax({
      async: false,
      global: false,
      url: servletUrl,
      data: {
        site: myDelLocale,
      },
      dataType: "json",
      success: function (data) {
        globalSelectListJson = sessionStorage.setItem(
          "globalSelectListJson",
          JSON.stringify(data)
        );

      },
      error: function () {
      },
    });
  }
}

// DBRIEFS RELATED FUNCTION ON REGISTRATION PAGE - moved on 09/01/2020

//VA: Move to registration-screen.js
function makeDbriefCallForExistingUser(response) {
  try {
    if (response.data.myDeloitte.consent.profile !== null &&
        !(
          typeof response.data.myDeloitte.consent.eventInfoDate.length ===
            "undefined" &&
          typeof response.data.myDeloitte.consent.eventInfoDate === "object"
        )
      ) {
        sessionStorage.removeItem("DbriefErrorMessage");
        localStorage.removeItem("DbriefErrorMessage");
        sessionStorage.removeItem("DbriefSuccessMessage");
        localStorage.removeItem("DbriefSuccessMessage");

        if (pagetype === "registration") {
          $("div.gigya-screen-loader-container").show();
        }
        if (fieldCompletionCheck(response)) {
          if (
            !(
              localStorage.getItem("isRedirectToAoi") === "true" ||
              localStorage.getItem("isRedirectToSub") === "true"
            )
          ) {
            makeDbriefCall(response);
          }
        }
      
    }
  } catch (err) {
   
  }
}

//VA: Move to registration-screen.js
function redirectNewUserWithOutEventId(response) {
  try {
    setItemInSessionStorage("isNewUser", true);
    /** If all mandatory data is available with the USER   .
      per current business logic, take them to Dashboard page else take them to progressive profile     .
        **/
    /**This if condition will redirects the mydaas user from registration page to Gated/Progressive profile page based on the flow param **/

    // set regstate to "state=signin" (default) if undefined
    if (response.data.myDeloitte.regState === undefined) {
      response.data.myDeloitte.regState = "state=signin";
    }

    regStateStr = response.data.myDeloitte.regState;
    if (
      (mydaas_action !== "" && mydaasApp_ID !== "") ||
      (regStateStr !== undefined &&
        regStateStr.indexOf("registration.mydaas") > -1)
    ) {
      mydaas_param = regStateStr.substring(
        regStateStr.lastIndexOf(".mydaas") + 1,
        regStateStr.indexOf("?")
      );
      var profile_URL =
        regStateStr.indexOf("flow=gated") > -1
          ? "./optin/gated-optsin." + mydaas_param
          : "./progressiveprofile." + mydaas_param;
      sessionStorage.setItem("isMyDaaSFlow", "true");
      if (getParameterByName("bm", regStateStr) != "") {
        sessionStorage.setItem(
          "bookmark",
          getParameterByName("bm", regStateStr)
        );
      }
    } else if (fieldCompletionCheckQR(response)) {
      profile_URL = "./dashboard.html";
    } else if (fieldCompletionCheck(response)) {
      profile_URL = "./dashboard.html";
    } else if (regStateStr.indexOf("action=optin") > -1) {
      // adding condition for optin and redirecting to gated screen bug-663632
      profile_URL = "./optin/gated-optsin.html";
    } else {
      profile_URL = "./progressiveprofile.html";
      if (response.loginProvider !== "undefined") {
        response.loginProvider === "site"
          ? (profile_URL = "./progressiveprofile.html?icid=success_reg_email")
          : (profile_URL =
              "./progressiveprofile.html?icid=success_reg_" +
              response.loginProvider);
      }
    }
    $(location).attr("href", profile_URL);
  } catch (err) {
    window.location.reload();
  }
}
/** Gets the airship email notification value from account settings config page. **/
function getNotificationValfromPrefSite(pref_site){
	pref_site = pref_site ? pref_site : "us-en";
	domain = domain ? domain : "my.deloitte.com";
	var siteStr = pref_site.replace(/\-/g, "/");
	var path = "https://"+domain+"/content/mydeloitte/"+siteStr+"/translations/account-setting-config.deloitte-model.json";
	    $.ajax({
	      async: false,
	      global: false,
	      url: path,    
	      dataType: "json",
	      success: function (data) {       
	      sessionStorage.setItem("pageJSON", JSON.stringify(data));
	      
	      },
	      error: function () {
	       
	      },
	    });
}
var myDeloitteApp = angular.module("myApp", [
  "ngAnimate",
  "ngSanitize",
  "ngRoute",
  "ui.bootstrap",
]);
myDeloitteApp.controller("myfeedCtrl", [
  "$scope",
  "$http",
  "$q",
  "transformService",
  "utilityService",
  function ($scope, $http, $q, transformService, utilityService) {
    getSessionResponse().then(function (response) {
      $scope.isCategorySelected = false;


    //function to handle fallback of interest recommendation section
    $scope.promoFallback = function(){

      $scope.tagetPromoShow = true;     
      $scope.interestSectionShow = true;

      if($scope.isTargetCategorySelected){      //if target cookies accepted

        if($scope.curateddata.all.length !== 0){          //if there is some curated data
            
          $scope.interestSectionShow = true;
              
        }else{ 
      
          if($("#dashboard-curated-target--reco-all-promos, #dashboard-curated-target--reco-event-promos, #dashboard-curated-target--reco-non-event-promos").html()== "" || $("#dashboard-curated-target--reco-all-promos, #dashboard-curated-target--reco-event-promos, #dashboard-curated-target--reco-non-event-promos").html() === undefined){         
              $scope.tagetPromoShow = false;     // hiding whole section when no curated or target promo
              $scope.interestSectionShow = false;
            }
          else{
            $scope.interestSectionShow = true;
            $scope.tagetPromoShow = true; 
          } 
      
        } 
      }
      else{      
          $scope.tagetPromoShow = false;          // hiding target promo
          
          if($scope.curateddata.all.length !== 0){    
            $scope.interestSectionShow = true;
          }
          else{
              $scope.interestSectionShow = false;  //hiding whole section when no curated promo
            }
      }
      
      }
      //curated promo fallback end

      $(document).on('OTReady', function(){
        $scope.isCategorySelected = cookieComplianceHelperJS.isCookieCategorySelected(3);
        $scope.isTargetCategorySelected = cookieComplianceHelperJS.isCookieCategorySelected(4);
        $scope.promoFallback();
        $scope.$apply();
      })

      var interestsTags = "";
      var sessionResponse = response;
      var globalSelectListJson = JSON.parse(
        sessionStorage.getItem("globalSelectListJson")
      );
      var pageNum = 1;

      $scope.curateddata = JSON.parse(sessionStorage.getItem("curated-results"));
      $scope.randomCurateddata = JSON.parse(
        sessionStorage.getItem("random-curated-results")
      );
      var isRandomCuratedSnPURL = false; // 609851: to avoid making multiple snp calls
      var count = 9; //changed count from 8 to 9 as initial count must be set from 8 to 9 for defect 471353
      var promoDataToBeStored;
      var promoDataToBeInserted;
      var queryTag1;
      var initialPromosContainerHeight;
      var interestList;
      var interestListArray;
      $scope.getdata = function () {
        var params = window.location.search.substr(1).split("?");
        for (var i = 0; i < params.length; i++) {
          var p = params[i].split("=");
          if (p[0] === "q") {
            var query = p[1];
            var interestsQuery = query.split(",");
            if (typeof interestsQuery != "undefined") {
              for (var j = 0; j < interestsQuery.length; j++) {
                if (interestsQuery[j].indexOf(":") > -1) {
                  interestsTags =
                    interestsTags +
                    interestsQuery[j].substring(
                      interestsQuery[j].indexOf(":") + 1
                    );
                } else {
                  interestsTags = interestsTags + interestsQuery[j];
                }
              }
              var queryParamTag = interestsTags;
            }
            /*Ramana = Can use the url q param instead of localstorage*/
            /* Variable to store the topic name when came from dashboard page*/
            var paramsTopic = localStorage.getItem("dashboardTopic");
          }
        }


        /*profileTagsForSNP can be moved to SS*/
        if (localStorage.getItem("profileTagsForSNP") !== null) {
          queryTag1 = localStorage.getItem("profileTagsForSNP");
        }
        if (
          queryParamTag !== "" &&
          queryParamTag != null &&
          queryParamTag !== undefined
        ) {

          var paramsTopicTitle = paramsTopic;
          var filterList = document.getElementById("filterByTopic");
          for (var k = 0; k < filterList.options.length; k++) {
            if (filterList.options[k].text === paramsTopicTitle) {
              filterList.selectedIndex = k;
              break;
            }
          }
          $scope.filterTopicTitle = ": " + paramsTopicTitle;
          $(".myfeed-page__subtitle").hide();
          $scope.queryParam = queryParamTag;
          $scope.getResults($scope.queryParam, pageNum, count);
          queryParamTag = "";
          
        } else {
          if (
            queryTag1 != null &&
            queryTag1 !== undefined
          ) {
            $scope.interestTags = queryTag1;
            $scope.getResults($scope.interestTags, pageNum, count);
            queryTag1 = "";

          } else {
            $(".loadMoreButton").hide();
          }
        }
      };

      // set profile tags and interests
      populateInterestsAndTags(response);

      if (localStorage.getItem("profileInterestsForSNP") !== null) {
        $scope.interestTopics = localStorage.getItem("profileInterestsForSNP");
        $scope.interestList = $scope.interestTopics;
        $scope.interestListArray = $scope.interestList.split(",");
        $scope.numOfInterests = $scope.interestListArray.length;
      }
      /*Populating Filter dropdown*/
      var interestTopics = JSON.parse(sessionStorage.getItem("interestsDetails"));
      if (
        $scope.numOfInterests !== 0 &&
        $scope.numOfInterests != "null" &&
        $scope.numOfInterests !== "undefined"
      ) {
        if (pagetype === "feed" && $scope.numOfInterests > 1) {
          var select = document.getElementById("filterByTopic");
          var UniqueNames = [];
          for (var i = 0; i < interestTopics.length; i++) {
            var topics = interestTopics[i];
            /*logic to create optgroup*/
            var optGroup = document.createElement("optgroup");
            optGroup.label = topics.interestSecTitle;
            optGroup.id = topics.interestSecTitle;
            if (UniqueNames.indexOf(optGroup.label) == -1) {
              UniqueNames.push(optGroup.label);
              select.appendChild(optGroup);
            }
            /*logic to create opttions under respective optgroup*/
            var optGroupId = document.getElementById(topics.interestSecTitle);
            var option = document.createElement("option");
            option.textContent = topics.interestTitle;
            option.value = topics.value;
            optGroupId.appendChild(option);
          }
        } else {
          $("#filterByTopic,.myfeed-content__filter-label").hide();
          $(".myfeed-page__subtitle").hide();
          if (interestTopics !== null && interestTopics[0]) {
            $scope.filterTopicTitle = ": " + interestTopics[0].interestTitle;
          }
        }
      } else {
        $(
          "#filterByTopic,.myfeed-content__filter-label,.myfeed-content__filter-link"
        ).hide();
        $(".myfeed-page__subtitle").hide();
        $scope.filterTopicTitle = "";
      }
      /*Function to get the bookmark date*/
      $scope.getbookmarkDate = function (promo) {
        return utilityService.getbookmarkDate(promo);
      };
      /*Function to  send the bookmark date*/
      $scope.sendBookmark = function (promoId, $event) {
        utilityService.sendBookmark(promoId, $event);
      };
      /*Function to trim the html tags in description*/
      $scope.getDescription = function (promo) {
        return utilityService.getDescription(promo);
      };
      /*Function to get the page url*/
      $scope.getPageURL = function (promoPageURL) {
        return utilityService.getPageURL(promoPageURL);
      };
      /*Function to add the additional class for insights promos*/
      $scope.getPromoClass = function (promo) {
        return utilityService.getPromoClass(promo);
      };
      $scope.getEventPromoClass = function (promo) {
        return utilityService.getEventPromoClass(promo);
      };

      $scope.getStartMonthForEvents = function (promo) {
        return utilityService.getStartMonthForEvents(promo);
      };

      $scope.getStartDateForEvents = function (promo) {
        return utilityService.getStartDateForEvents(promo);
      };

      $scope.getPublishedDateFormatted = function (promo) {
        return utilityService.getPublishedDateFormatted(promo);
      };

      /*Function to get the pagetype to differetiate DCOM & Insights promos*/
      $scope.getPageType = function (promo) {
        return utilityService.getPageType(promo);
      };

      /*Funciton to get the thumbnail*/
      $scope.getThumbnail = function (promo) {
        return utilityService.getThumbnail(promo);
      };

      /*Funciton to get the IE thumbnail*/
      $scope.getIEThumbnail = function (promo) {
        return utilityService.getIEThumbnail(promo);
      };
      /*Funciton to get the mobile rendition of the thumbnail*/
      $scope.getMobileThumbnail = function (promo) {
        return utilityService.getMobileThumbnail(promo);
      };
      /* US 262849: Function to show the Deloitte Insights text for Deloitee Insights promos*/
      $scope.showText = function () {
        return utilityService.showText();
      };
      /*  US 262849: Function to show the Deloitte Insights Logo for Deloitee Insights promos*/
      $scope.showLogo = function () {
        return utilityService.showLogo();
      };
      /*Funciton to do the Elastic Query and get the results*/
      $scope.getResults = function (query, pageNum, count) {
        if (query === "All") {
          $scope.query = $scope.interestTopics;
        }
        if (query === "") {
          $scope.query = $scope.query;
        }
        if (pageNum === "") {
          pageNum = 1;
        }

        var PersonalizationProperties = "";
        if (sessionResponse.data.myDeloitte.industry !== "") {
          PersonalizationProperties =
            PersonalizationProperties +
            sessionResponse.data.myDeloitte.industry +
            ", ";
        } 
        if (sessionResponse.data.myDeloitte.function !== "") {
          PersonalizationProperties =
            PersonalizationProperties +
            sessionResponse.data.myDeloitte.function +
            ", ";
        }
        if (sessionResponse.data.myDeloitte.level !== "") {
          PersonalizationProperties =
            PersonalizationProperties + sessionResponse.data.myDeloitte.level;
        }

        $scope.query = query + " " + PersonalizationProperties;
        $scope.query = $scope.query.replaceAll(",", " ");

        // US: 521647: Events section on Dashboard (Registered user)-> adding conditions here before API calls
        if (pagetype !== "feed") {
          $scope.showEventTargetDiv = false;
          $("#interests-side-link").css("display", "block");
          if (isEventEnabled === "true") {
            $q.all([
              $scope.getArticles(count, false),
              $scope.getEvents(count),
            ]).then(function (results) {
              if (results[0] && results[1]) {
                $scope.interestTopics = localStorage.getItem(
                  "profileInterestsForSNP"
                );
                var interestList = $scope.interestTopics;
                var interestListArray = interestList.split(",");
                interestListArray = interestListArray.filter(function (entry) {
                  return entry.trim() !== "";
                });
                $scope.interestsCount = interestListArray.length;

                var queryTag1 = localStorage.getItem("profileTagsForSNP");
                if (queryTag1.length >= 1) {
                  $("#bookmarks-container").css("display", "none");
                  $scope.displayButton = false;
                }
                //adding curated content here to events
                if (
                  $scope.finalResultsForEvents.length === 0 &&
                  $scope.finalResults.length >= 1 &&
                  $scope.interestsCount >= 1
                ) {
                  $scope.showEventTargetDiv = true;
                }
                if (
                  $scope.finalResultsForEvents.length === 0 &&
                  $scope.finalResults.length === 0 &&
                  $scope.interestsCount === 0
                ) {
                  $scope.showEventTargetDiv = true;
                }
                if (
                  $scope.finalResultsForEvents.length >= 1 &&
                  $scope.finalResults.length === 0 &&
                  $scope.interestsCount >= 1
                ) {
                  $scope.showEventTargetDiv = true;
                }
                if (
                  $scope.finalResultsForEvents &&
                  $scope.finalResultsForEvents.length === 0 &&
                  $scope.finalResults &&
                  $scope.finalResults.length === 0
                ) {
                  $scope.showEmptyEventArticleContainer = true;
                }
              }
            });
          } else {
            $scope.getArticles(count, false).then(function () {
              $scope.interestTopics = localStorage.getItem(
                "profileInterestsForSNP"
              );
              interestList = $scope.interestTopics;
              interestListArray = interestList.split(",");
              interestListArray = interestListArray.filter(function (entry) {
                return entry.trim() !== "";
              });
              $scope.interestsCount = interestListArray.length;

              var queryTag1 = localStorage.getItem("profileTagsForSNP");
              $scope.finalResultsForEvents = [];
              if (queryTag1.length >= 1) {
                $("#bookmarks-container").css("display", "none");
                $scope.displayButton = false;
              }
              $("#empty-events-container").css("display", "none");
              if ($scope.finalResults && $scope.finalResults.length === 0) {
                $scope.showEmptyEventArticleContainer = true;
              }
            });
          }
        } else {
          $scope.getArticles(count, true).then(function () {
            if (pageNum >= 2) {
              var calculatedHeight = initialPromosContainerHeight + 150;
              //reducing 350px manaully so that the old promo and new promo are populated together
              window.scroll(0, calculatedHeight);
            } else {
              $(window).scrollTop();
            }
          });
        }
        $scope.$apply($scope.finished);
      };
      /**The below logic is for to excludes/hide the curated event promo from dynamic content feed starts from here**/
      var excluded_event_promo =
        globalSelectListJson &&
        globalSelectListJson["random-curated-json"] &&
        globalSelectListJson["random-curated-json"] !== "null"
          ? JSON.parse(globalSelectListJson["random-curated-json"])[
              "random-curated-event"
            ]
          : "";
      if (pagetype === "dashboard" && excluded_event_promo) {
        if (!sessionStorage.getItem("excluded_event_promo")) {
          sessionStorage.setItem("excluded_event_promo", excluded_event_promo);
        } else {
          excluded_event_promo = sessionStorage.getItem("excluded_event_promo");
        }
      }
      excluded_event_promo =
        excluded_event_promo !== null ? excluded_event_promo : "";
      /** Logic to excludes/hide the curated event promo from dynamic content feed ends here**/

      $scope.getEvents = function (count) {

        $scope.eventCount = 0;
        return new Promise(function (resolve) {
          transformService
            .getEventsFromElastic(
              count,
              $scope.query,
              excluded_event_promo,
              pageNum
            )
            .then(function (data) {
              if (data && data["result-sets"] && data["result-sets"].length) {
                var responseData = data["result-sets"][0];
                var newData = responseData["mydeloitte_articles"];
                $scope.eventCount = parseInt(data["total-results"]);
                $scope.eventCount =
                    $scope.curateddata && $scope.curateddata.events && $scope.curateddata.events.length > 0
                    ? $scope.eventCount + 1
                    : $scope.eventCount;
                var hideNum = responseData["mydeloitte_articles"].length - 1;
                promoDataToBeStored =
                  responseData["mydeloitte_articles"][hideNum];
                if (responseData["mydeloitte_articles"].length < count) {
                  $(".loadMoreButton").hide();
                } else {
                  responseData["mydeloitte_articles"].pop();
                  $(".loadMoreButton").show();
                }
                if (!$scope.finalResultsForEvents == "") {
                  responseData["mydeloitte_articles"].unshift(
                    promoDataToBeInserted
                  );

                  var displayPastLabel='';
                  for (var j = 0; j < newData.length; j++) {
                    displayPastLabel =
                      new Date() > new Date(newData[j]["start-date"]);
                    newData[j].pastEvent = displayPastLabel;
                    $scope.finalResultsForEvents.push(newData[j]);
                  }
                } else {
                  $scope.finalResultsForEvents = [];

                  for (var l = 0; l < newData.length; l++) {
                    displayPastLabel =
                      new Date() > new Date(newData[l]["start-date"]);
                    newData[l].pastEvent = displayPastLabel;
                    $scope.finalResultsForEvents.push(newData[l]);
                  }
                }
                $scope.setRandomCuratedPromo(); // adding random curated promo-600351
                $scope.finished();
              } else {
                $scope.getCuratedPromo(); //empty response article
              }
              resolve(true);
            });
        });
      };
      /**The below logic is for to excludes/hide the curated article/non-events promo from dynamic content feed starts from here**/
      var excluded_article_promo =
        globalSelectListJson &&
        globalSelectListJson["random-curated-json"] &&
        globalSelectListJson["random-curated-json"] !== "null"
          ? JSON.parse(globalSelectListJson["random-curated-json"])[
              "random-curated-article"
            ]
          : "";
      if (pagetype === "dashboard" && excluded_article_promo) {
        if (!sessionStorage.getItem("excluded_article_promo")) {
          sessionStorage.setItem(
            "excluded_article_promo",
            excluded_article_promo
          );
        } else {
          excluded_article_promo = sessionStorage.getItem(
            "excluded_article_promo"
          );
        }
      }
      excluded_article_promo =
        excluded_article_promo !== null ? excluded_article_promo : "";

      var newData;
      /** Logic to excludes/hide the curated article/non-event promo from dynamic content feed ends here**/
      $scope.getArticles = function (count, isMyFeed) {

        $scope.articlesCount = 0;
        return new Promise(function (resolve) {
          transformService
            .getArticlesFromElastic(
              count,
              $scope.query,
              excluded_article_promo,
              pageNum,
              isMyFeed
            )
            .then(function (data) {
              if (
                data &&
                data["result-sets"] &&
                data["result-sets"].length >= 1
              ) {
                var responseData = data["result-sets"][0];
                $scope.articlesCount = parseInt(data["total-results"]);
                $scope.articlesCount =
                    $scope.curateddata && $scope.curateddata.nonEvents && $scope.curateddata.nonEvents.length > 0
                    ? $scope.articlesCount + 1
                    : $scope.articlesCount;
                if (
                  responseData &&
                  responseData.mydeloitte_articles &&
                  responseData.mydeloitte_articles.length === 0 &&
                  promoDataToBeInserted !== undefined
                ) {
                  $scope.promosdata.push(promoDataToBeInserted);
                  $(".loadMoreButton").hide();
                  $scope.renderJson();
                } else if (
                  responseData &&
                  responseData.mydeloitte_articles &&
                  responseData.mydeloitte_articles.length === 0
                ) {
                  $scope.finalResults = [];
                  $scope.promosdata = [];
                  $scope.renderJson();
                  $scope.getCuratedPromo(); //empty response article
                } else {
                  var hideNum = responseData["mydeloitte_articles"].length - 1;
                  promoDataToBeStored =
                    responseData["mydeloitte_articles"][hideNum];
                  if (responseData["mydeloitte_articles"].length < count) {
                    $(".loadMoreButton").hide();
                  } else {
                    responseData["mydeloitte_articles"].pop();
                    $(".loadMoreButton").show();
                    $(".viewall-feed-link").css("display", "block");
                  }
                  if (!$scope.promosdata == "") {
                    //Injecting the previously stored value to the responseData(tempDatal<- promoDataToBeStored)
                    responseData["mydeloitte_articles"].unshift(
                      promoDataToBeInserted
                    );
                    newData = responseData["mydeloitte_articles"];
                    for (var m = 0; m < newData.length; m++) {
                      $scope.promosdata.push(newData[m]);
                    }
                  } else {
                    $scope.promosdata = responseData["mydeloitte_articles"];
                  }
                  $scope.renderJson();
                }
              }
              resolve(true);
            });
        });
      };

      $scope.renderJson = function () {
        $scope.finalResults = $scope.promosdata;
        if (!$scope.finalResults.length) {
          if ($scope.numOfInterests === 0) {
            $(".myfeed-content .no-interests").show();
          } else {
            $(".myfeed-content .no-results").show();
          }
          $(".loadMoreButton").hide();
        } else {
          $(".myfeed-content .no-results").hide();
        }
        $scope.setRandomCuratedPromo(); // adding random curated promo - 600351
        $scope.$apply();
        $scope.finished();
      };
      $(".loadMore").click(function () {
        promoDataToBeInserted = promoDataToBeStored;
        pageNum = pageNum + 1;
        count = 9;
        var filterTopic = $("#filterByTopic option:selected").val();
        var filterTopicCheck = filterTopic
          .replace(/[^a-z0-9\s]/gi, "")
          .replace(/[_\s]/g, "-");

        /* To check if filter option is null */
        if (filterTopicCheck === "") {
          if (
            $scope.queryParam !== "" &&
            $scope.queryParam != null &&
            $scope.queryParam !== undefined
          ) {
            $scope.getResults($scope.queryParam, pageNum, count);
          } else {
            $scope.getResults($scope.interestTags, pageNum, count);
          }
        } else {
          if (filterTopicCheck !== "All") {
            $scope.getResults(filterTopic, pageNum, count);
          } else {
            $scope.getResults($scope.interestTags, pageNum, count);
          }
        }
        if (pageNum >= 2) {
          initialPromosContainerHeight = $(
            ".myfeed-content__container"
          ).height();
        }
      });
      //Filter Function
      $("#filterByTopic").change(function () {
        pageNum = 1;
        //Changed count from 8 to 9 as initial count must be set to 9
        count = 9;
        var filterTopic = $("#filterByTopic option:selected").val();
        var filterTopicCheck = filterTopic
          .replace(/[^a-z0-9\s]/gi, "")
          .replace(/[_\s]/g, "-");
        var filterTopicTitle = $("#filterByTopic option:selected").html();
        if (filterTopicCheck !== "All") {
          $scope.promosdata = "";
          $scope.getResults(filterTopic, pageNum, count);
          $scope.filterTopicTitle = ": " + filterTopicTitle;
          $(".myfeed-page__subtitle").hide();
        }
        //resets the results call getdata function if filter options removed
        else {
          $scope.promosdata = "";
          $scope.getdata();
          $scope.filterTopicTitle = "";
          $(".myfeed-page__subtitle").show();
        }
      });
      /*Function to render the dotdotdot*/
      $scope.finished = function () {
        angular.element("div.skeleton").fadeOut("slow");
        angular.element(".myfeed-content").fadeIn("slow");
        if (window.matchMedia("(max-width: 767px)").matches) {
          return;
        }
        customShave(".dot-ellipsis", 70);
      };
      /** gets random index **/
      $scope.getRandomIndex = function (length) {
        return Math.floor(Math.random() * length);
      };

      // for shuffling events & articles curated data
      $scope.shuffleArray = function (array) {
        var m = array.length,
          t,
          i;
        // While there remain elements to shuffle
        while (m) {
          // Pick a remaining element
          i = Math.floor(Math.random() * m--);
          // And swap it with the current element.
          t = array[m];
          array[m] = array[i];
          array[i] = t;
        }
        return array;
      };

      // US-590917: Events section on Dashboard - Empty state promos (Registered user)
      /** gets all curated promo for dashboard */

      $scope.getCuratedPromo = function () {
        if (pagetype === "dashboard" && !$scope.curateddata) {
          $scope.curateddata = {
            all: [],
            events: [],
            nonEvents: [],
          };
          if (curatedContentSnPURL !== "") {
            var pageIdList = curatedContentSnPURL.split(",");
            return new Promise(function (resolve) {
              transformService.getCuratedPromosForDashboard(pageIdList).then(
                function (response) {
                  var resultSet = response["result-sets"];
                  if (resultSet !== undefined && resultSet.length) {
                    $scope.curateddata["all"] = $scope.shuffleArray(resultSet);

                    for (let i = 0; i < resultSet.length; i++) {
                      resultSet[i]['published-date-formatted'] = '';
                      resultSet[i]['published-date-formatted'] = $scope.getPublishedDateFormatted(resultSet[i]);
                      resultSet[i]['curated-promo'] = '';
                      resultSet[i]['curated-promo'] = 'true';
                      if (resultSet[i]["page-type"] == "flex-eventdetails") {
                        var displayPastLabel =
                          new Date() > new Date(resultSet[i]["start-date"]);
                        resultSet[i].pastEvent = displayPastLabel;
                        $scope.curateddata["events"].push(resultSet[i]);
                      }else{
                        $scope.curateddata["nonEvents"].push(resultSet[i]);
                      }
                      $scope.curateddata["all"] = $scope.shuffleArray(
                        resultSet
                      );

                      sessionStorage.setItem(
                        "curated-results",
                        JSON.stringify($scope.curateddata)
                      );
                    }


                    if($scope.curateddata.all.length !== 0){
                      $scope.interestSectionShow = true;
                    }

                  }
                  resolve(true);
                },function(error) {

                });
            });
          }
        }

      };
      $scope.getCuratedPromo(); // getting Curated Promos onload

      // 600351
      // reusable function for setting random proms
      $scope.setRandomPromos = function (data) {
        for (let i = 0; i < data.length; i++) {
          if (data[i]["page-type"] === "flex-eventdetails") {
            if (
              $scope.finalResultsForEvents !== "undefined" &&
              $scope.finalResultsForEvents != null &&
              $scope.finalResultsForEvents.length
            ) {
              var displayPastLabel =
                new Date() > new Date(data[i]["start-date"]);
              data[i].pastEvent = displayPastLabel;
              if ($scope.finalResultsForEvents[0] && !$scope.finalResultsForEvents[0]['curated-promo']) {
                $scope.finalResultsForEvents.splice(0, 0, data[i]);
                break;
              }              
            }
          } else {
            if (
              $scope.finalResults !== "undefined" &&
              $scope.finalResults != null &&
              $scope.finalResults.length
            ) {
              if ($scope.finalResults[0] && !$scope.finalResults[0]['curated-promo']) {
                $scope.finalResults.splice(0, 0, data[i]);
                break;
              }              
            }
          }
        }
        //fetch unique records
        var uniqueRecords=[];
        if ($scope.finalResults && $scope.finalResults.length > 0) {
          uniqueRecords = $scope.finalResults.filter(function (v, i, a) {
            return a.indexOf(v) === i;
          });
          $scope.finalResults = uniqueRecords;
        }
        if (
          $scope.finalResultsForEvents &&
          $scope.finalResultsForEvents.length > 0
        ) {
          uniqueRecords = $scope.finalResultsForEvents.filter(function (
            v,
            i,
            a
          ) {
            return a.indexOf(v) === i;
          });
          $scope.finalResultsForEvents = uniqueRecords;
        }
      };

      // 600351
      /* sets the random promo to `events and non-events` promos data */
      $scope.setRandomCuratedPromo = function () {
        if (pagetype === "dashboard") {
          if (
            $scope.randomCurateddata !== "undefined" &&
            $scope.randomCurateddata !== null &&
            $scope.randomCurateddata.length
          ) {
            $scope.setRandomPromos($scope.randomCurateddata);
          } else {
            var randomCuratedPromoSnPURL =
              globalSelectListJson &&
              globalSelectListJson["random-curated-json"] &&
              globalSelectListJson["random-curated-json"] !== "null"
                ? JSON.parse(globalSelectListJson["random-curated-json"])[
                    "random-curated-snpURL"
                  ]
                : "";
            if($scope.curateddata){
              $scope.randomCurateddata = $scope.curateddata.all;
              $scope.setRandomPromos($scope.randomCurateddata);
              sessionStorage.setItem(
                "random-curated-results",
                JSON.stringify($scope.randomCurateddata)
              );
            }

          }
          if(
            $scope.interestListArray.length == 0 &&
            $scope.curateddata.all.length !== 0
          ){
            $scope.interestSectionShow = true;
          }
        }
      };
      // get objects length for iteration
      $scope.findKeysLength = function (data) {
        if (data) {
          return Object.keys(data).length;
        }
      };

      $scope.getdata();
      // get screen name to curate content feed according to screens: Dashboard or content feed
      var sitePathName = window.location.pathname;
      var IsDashboardScreen = sitePathName.indexOf("dashboard");
      // get interests count
      $scope.interestTopics = localStorage.getItem("profileInterestsForSNP");
      $scope.interestList = $scope.interestTopics;
      $scope.interestListArray = $scope.interestList.split(",");
      $scope.interestListArray = $scope.interestListArray.filter(function (entry) {
        return entry.trim() !== "";
      });
      $scope.interestsCount = $scope.interestListArray.length;
      
      response = response && response.data ? response : sessionResponse;
      if (IsDashboardScreen > 0) {
        curateDashboardFeed();
      } else {
        $scope.professionalDetailCount = getProfessionalCount(response);
        curateContentFeedPage();
      }

      // US:575470: Dashboard: Content Feed section label (Registered user)
      function curateDashboardFeed() {
        $scope.showFeedLabel = false;
        $scope.professionalDetailCount = getProfessionalCount(response);
        $scope.showFeedLabel = true;
        $scope.displayButton = false; //show me how button flag
        var redirectionUrl = "";
        if (
          ($scope.interestsCount === 0 && $scope.professionalDetailCount === 0) ||
          ($scope.interestsCount >= 1 && $scope.professionalDetailCount === 0)
        ) {
          redirectionUrl = "./profile.html";
        } else if (
          $scope.interestsCount === 0 &&
          $scope.professionalDetailCount >= 1
        ) {
          redirectionUrl = "./profile.html#profile-interest";
        } else if (
          $scope.interestsCount >= 1 &&
          $scope.professionalDetailCount >= 1
        ) {
          redirectionUrl = "./profile.html#profile-interest";
          $scope.showFeedLabel = false;
        } else {
          $scope.showFeedLabel = false;
        }
        $(document).ready(function () {
          $("#content-feed-redirect").attr("href", redirectionUrl);
          if ($scope.showFeedLabel) {
            $("#myFeed-noResults").hide();
            $("#content-feed-no-results").hide();
            if ($scope.interestsCount === 0) {
              $scope.displayButton = $scope.professionalDetailCount === 0;
              $(".myfeed-page .bookmarks").hide();
              $("#view-feed-button").hide();
            }
          }
        });
      }
      function getProfessionalCount(response) {
        if (response.status !== "FAIL" && typeof response != undefined) {
          var professionDetailsObject = {
            function: response.data.myDeloitte.function,
            industry: response.data.myDeloitte.industry,
            level: response.data.myDeloitte.level,
          };
          var count = 0;
          for (var key in professionDetailsObject) {
            if (
              professionDetailsObject[key] &&
              professionDetailsObject[key].length > 1
            ) {
              count++;
            }
          }
          return count;
        }
      }
      //US:575530 :Content feed : Section label - (Registered user) this is for myfeed html file
      function curateContentFeedPage() {
        $scope.redirectionLink = "./profile.html";
        $scope.filterLink = $("#update-profile-content-feed").attr(
          "data-profile"
        );
        $("#update-profile-content-feed").show();
        if (
          ($scope.interestsCount === 0 && $scope.professionalDetailCount >= 1) ||
          ($scope.interestsCount === 1 && $scope.professionalDetailCount >= 1) ||
          ($scope.interestsCount >= 1 && $scope.professionalDetailCount >= 1)
        ) {
          $scope.redirectionLink = "./profile.html#profile-interest";
          $scope.filterLink = $("#update-profile-content-feed").attr(
            "data-topic"
          );
          $("#update-profile-content-feed").show();
        }
        $(document).ready(function () {
          $("#update-profile-content-feed").attr(
            "href",
            $scope.redirectionLink
          );
          $("#update-profile-content-feed").show();
          if (
            $scope.interestsCount === 0 &&
            $scope.professionalDetailCount >= 1
          ) {
            $(".no-results__content").hide();
            $(".myfeed-content__filter-link").css("display", "block");
          }
          //if no professional details and interests hide side link:
          if (
            $scope.interestsCount === 0 &&
            $scope.professionalDetailCount === 0
          ) {
            $("#update-profile-content-feed").hide();
          }
        });
      }
      // apply all changes
      $scope.$apply();
    });
  },
]);


var subscriptionJson = "";
var recommendedSubscriptionJson = "";

myDeloitteApp.controller("subscriptionsCtrl", [
  "$scope",
  function ($scope) {
    $scope.content = [];
    $scope.tab = [];
    getSessionResponse().then(function (response) {
      $scope.getData = function () {
        var langLocle = myDelLocale;
        langLocle = langLocle.replace(/\//g, "_");

        if (typeof (langLocle == "undefined") || langLocle === "") {
          langLocle = "global_en";
        }
        var selectedInterests = getInterestsAndSubscriptions(
          response,
          "interests"
        );
        selectedInterests = JSON.stringify(selectedInterests);
        if (selectedInterests !== null && selectedInterests !== undefined) {
          selectedInterests = selectedInterests.replace(/[^a-z\d\s,]+/gi, "");
        }
        langLocle = myDelLocale;
        langLocle = langLocle.replace(/\//g, "_");
         var servletUrl = window.location.href.split(".html")[0];
        if(servletUrl.indexOf("mydaas") >0){
		 	servletUrl = window.location.href.split(".mydaas")[0];
        }
       
        $.ajax({
          async: false,
          global: false,
          url: servletUrl+".deloitte-subscriptionpage.json",
          data: {
            site: langLocle,
          },
          dataType: "json",
          success: function (data) {
            subscriptionJson = data;
          },
          error: function () {
            
          },
        });
        /** AJAX call for to get the recommended subscriptions data from the MyDeloitteRecommendedSubscriptionServlet starts **/
        $.ajax({
          async: false,
          global: false,
          url: window.location.href.split(".html")[0]+".deloitte-recommendedsubscription.json",
          data: {
            site: langLocle,
            selectedInterests: selectedInterests,
          },
          dataType: "json",
          success: function (data) {
            recommendedSubscriptionJson = data;
          },
          error: function () {
           
          },
        });
        /** AJAX call for to get the recommended subscriptions data from the MyDeloitteRecommendedSubscriptionServlet ends **/
        if (
          typeof subscriptionJson !== "undefined" &&
          subscriptionJson !== ""
        ) {
          subscriptionJson = JSON.stringify(subscriptionJson);
        }
        subscriptionJson = JSON.parse(subscriptionJson);
        $scope.content = subscriptionJson;
        $scope.content = $scope.content.content;

        //recommended subcription json
        if (
          typeof recommendedSubscriptionJson !== "undefined" &&
          recommendedSubscriptionJson !== ""
        ) {
          recommendedSubscriptionJson = JSON.stringify(
            recommendedSubscriptionJson
          );
          recommendedSubscriptionJson = JSON.parse(recommendedSubscriptionJson);
          $scope.reccontent = recommendedSubscriptionJson;
          $scope.reccontent = $scope.reccontent.content;
        }
      };
      $scope.getData();
      $scope.showSubscription = function (contentArray) {
        var checkSubLength = contentArray.tab.length - 1;
        if (checkSubLength > 0) {
          return true;
        } else {
          return false;
        }
      };
      $scope.$apply();
    });
  },
]);

var navigateToPageFromSub;
$.urlParam = function (name) {
  var results = new RegExp("[?&]" + name + "=([^&#]*)").exec(
    window.location.href
  );

  if (results) {
    return results[1];
  }
  return 0;
};
var subVal;
$(document).ready(function () {
  subVal = $.urlParam("sub");
  if (subVal !== 0) {
    var reqid = $("input[value='" + subVal + "']")
      .closest(".tab-pane")
      .attr("id");
    if (window.matchMedia("(min-width:768px)").matches) {
      $("#subscriptions-tab-list li:first-child a")
        .removeClass("active")
        .removeClass("show");
      $(".tab-content #panel0").removeClass("active").removeClass("show");
      $("#subscriptions-tab-list")
        .find("a[href='#" + reqid + "']")
        .addClass("active")
        .addClass("show");
      $("input[value='" + subVal + "']")
        .closest(".tab-pane")
        .addClass("active")
        .addClass("show");
    } else {
      $(".tab-content #panel0 h5 a[href='#collapse-0']").addClass("collapsed");
      $(".tab-content #panel0 #collapse-0").removeClass("show");
      $("input[value='" + subVal + "']")
        .closest(".tab-pane")
        .find("a")
        .removeClass("collapsed");
      $("input[value='" + subVal + "']")
        .closest(".card-body")
        .parent()
        .addClass("show");
    }
  }

  $('.subscriptions-select-all input[type="checkbox"]').on(
    "click",
    function () {
      if ($(this).is(":checked")) {
        $(this)
          .closest(".row")
          .next()
          .find("input[type='checkbox']")
          .prop("checked", true);
      } else {
        $(this)
          .closest(".row")
          .next()
          .find("input[type='checkbox']")
          .prop("checked", false);
      }
    }
  );
  $('.tab-pane div:not(".subscriptions-select-all") input[type="checkbox"]').on(
    "click",
    function () {
      if (
        !$(this).is(":checked") &&
        $(this)
          .closest(".tab-pane")
          .find(".subscriptions-select-all input[type='checkbox']")
          .is(":checked")
      ) {
        $(this)
          .closest(".tab-pane")
          .find(".subscriptions-select-all input[type='checkbox']")
          .prop("checked", false);
      }
      var noOfOptions = $(this).closest(".row").find('input[type="checkbox"]')
        .length;
      var i = noOfOptions;
      $(this)
        .closest(".row")
        .find('input[type="checkbox"]')
        .each(function () {
          if ($(this).is(":checked")) {
            i = i - 1;
          }
        });
      if (i === 0) {
        $(this)
          .closest(".tab-pane")
          .find(".subscriptions-select-all input[type='checkbox']")
          .prop("checked", true);
      }
    }
  );

  if (pagetype === "subscription") {
    //leaving page

    stayOnPageSub = function () {
      aModalIsPresent = false;
      $("#modal-unsaved-subscription").removeClass("show");
      $("#modal-unsaved-subscription").css("display", "none");
      $("#modal-backdrop-unsaved-subscription").css("display", "none");
      $("#modal-backdrop-unsaved-subscription").removeClass("show");
      $("#modal-profile-incomplete-subscription").removeClass("show");
      $("#modal-profile-incomplete-subscription").css("display", "none");
    };
    leaveThePageSub = function () {
      aModalIsPresent = false;
      try {
        if (navigateToPageFromSub.indexOf("www") >= 0) {
          window.location.href = navigateToPageFromSub;
        } else {
          location.pathname = navigateToPageFromSub;
        }
      } catch (err) {
        logOut();
      }
    };
    $("button.close").on("click", function () {
      stayOnPageSub();
    });

    $(
      "a:not(a[href^='#']):not(a[class='profile__pic']):not(a[id='profile-initials'])"
    ).on("click", function (event) {
      var isChanged = false;
      if (
        typeof $(this).attr("target") != "undefined" &&
        $(this).attr("target").indexOf("_blank") >= 0
      ) {
        isChanged = false;
      } else {
        navigateToPageFromSub = $(this).attr("href");
        $(":checkbox").each(function () {
          if ($(this).data("initialValue") !== $(this).is(":checked")) {
            isChanged = true;
          }
        });
        var len = 0;
        $(".tab-content .tab-pane").each(function () {
          len = len + $(this).find("div.optin-checked").length;
        });
        if (len > 0) {
          isChanged = true;
        }
      }

      if (isChanged === true) {
        event.preventDefault();
        aModalIsPresent = true;
        $("#modal-unsaved-subscription").addClass("show");
        $("#modal-backdrop-unsaved-subscription").addClass("show");
        $("#modal-unsaved-subscription").css("display", "block");
        $("#modal-backdrop-unsaved-subscription").css("display", "block");
      }
    });
  }

  $(".subscriptions__preview").on("click", function () {
    $("#modal-preview-newsletter").addClass("show");
    $("#modal-backdrop-unsaved-subscription").addClass("show");
    $("#modal-preview-newsletter").css("display", "block");
    $("#modal-backdrop-unsaved-subscription").css("display", "block");
    $("#modal-preview-newsletter .modal-body img").attr(
      "src",
      $(this).attr("data-img-link")
    );
  });
  $("#modal-preview-newsletter button.close").on("click", function () {
    $("#modal-preview-newsletter").removeClass("show");
    $("#modal-preview-newsletter").css("display", "none");
  });

  //We are trying to calculate the subscriptions and unsubscriptions
  //ids , titles and related flags here on the Click event handler of the checkboxes.
  $("input[name='subscription-topics']").on("click", function () {
    var subIds = [];
    var subscribedItemsOnSubscriptions = ";";
    $.each($("input[name='subscription-topics']:checked"), function () {
      subIds.push($(this).val().replace(/["']/g, ""));
    });

    if (resObj !== undefined && resObj.data.myDeloitte.sites !== undefined) {
      
      var originalSubscriptions = getInterestsAndSubscriptions(
        resObj,
        "subscriptions"
      );
    }


    var newlyAddedSubscriptions = populateNewlyAddedElements(
      subIds,
      originalSubscriptions
    );
    subscribedItemsOnSubscriptions = ";";

    if (
      typeof newlyAddedSubscriptions != "undefined" &&
      newlyAddedSubscriptions.length > 0
    ) {
      for (var k = 0; k < newlyAddedSubscriptions.length; k++) {
        subscribedItemsOnSubscriptions =
          subscribedItemsOnSubscriptions +
          "" +
          $("input[value='" + newlyAddedSubscriptions[k] + "']")
            .closest(".checkbox.subscriptions")
            .find(".subscriptions__title")
            .text() +
          ",;";
      }
      
    } 
    if (subscribedItemsOnSubscriptions != ";") {
      subscribedItemsOnSubscriptions = subscribedItemsOnSubscriptions.substring(
        0,
        subscribedItemsOnSubscriptions.lastIndexOf(",;")
      );
      subscribedItemsOnSubscriptions = subscribedItemsOnSubscriptions.replace(
        /;/g,
        ""
      );
    } else {
      subscribedItemsOnSubscriptions = "";
    }

    var unsubscribedElements = findUnsubscribedElements(
      subIds,
      originalSubscriptions
    );
    var unSubscribedItemTitlesArray = [];
    // Creating a list of titles for unsubscribed elements.
    $.each($("input[name='subscription-topics']"), function () {
      if (
        $.inArray($(this).val().replace(/["']/g, ""), unsubscribedElements) >= 0
      ) {
        unSubscribedItemTitlesArray.push(
          $(this)
            .closest(".checkbox.subscriptions")
            .find(".subscriptions__title")
            .text()
        );
      }
    });

    var unSubscribedItemsOnSubscriptions = ";";
    for (var index = 0; index < unSubscribedItemTitlesArray.length; ++index) {
      unSubscribedItemsOnSubscriptions =
        unSubscribedItemsOnSubscriptions +
        unSubscribedItemTitlesArray[index] +
        ",;";
    }
    if (unSubscribedItemsOnSubscriptions != ";") {
      unSubscribedItemsOnSubscriptions = unSubscribedItemsOnSubscriptions.substring(
        0,
        unSubscribedItemsOnSubscriptions.lastIndexOf(",;")
      );
      unSubscribedItemsOnSubscriptions = unSubscribedItemsOnSubscriptions.replace(
        /;/g,
        ""
      );
      unsubChangesMadeOnSubscriptionsPage = true;
    } else {
      unSubscribedItemsOnSubscriptions = "";
      unsubChangesMadeOnSubscriptionsPage = false;
    }
  });
});

$(window).load(function () {
  if (pagetype === "subscription") {
    if (subVal !== 0) {
      $("html, body").animate(
        {
          scrollTop: $("#accordion.tab-content").offset().top,
        },
        1000
      );
    }
    // This highlights the tab in subscription page
    var subKeyVal = localStorage.getItem("subKey");
    if (subKeyVal !== null) {
      $("html, body").animate(
        {
          scrollTop:
            $("#subscriptions-tab-list").offset().top -
            $("#header").outerHeight(true),
        },
        1000
      );
      setFocusToTab();
      if (localStorage.getItem("nocheck") === "true") {
        localStorage.removeItem("subKey");
        localStorage.removeItem("nocheck");
      }
    }
  }
});

var resObj;
var API_KEY = "";
var originalSubscriptions = [];
var subChangesMadeOnSubscriptionsPage = false;
var subscribedItemsOnSubscriptions = "";
var unSubscribedItemsOnSubscriptions = "";

/* code for back button functionality */
window
  .addEventListener(
    "pageshow",
    function(event) {
      var historyTraversal = event.persisted ||
        (typeof window.performance != "undefined" && window.performance.navigation.type === 2);
      if (historyTraversal && pagetype === 'subscription') {
        // Handle page restore.
        window.location.reload();
      }
    });
/* code for back button functionality ends */
function forwardResponseForSubPage(response, SOCIAL_API) {
  loadJobFunctions();
  loadCurrentJobLevelForProfile();
  loadIndustryForProfile();
  loadMemeberfirms();
  resObj = response;
  API_KEY = SOCIAL_API;
  var subKeyArray = [];
  if (typeof(resObj.data) !== 'undefined' && typeof(resObj.data.myDeloitte.sites) !== 'undefined') {
    subKeyArray = getInterestsAndSubscriptions(response, 'subscriptions');
    originalSubscriptions = subKeyArray;
    if (typeof(subKeyArray) !== 'undefined' && subKeyArray.length > 0) {
      var subIdValue = subKeyArray;
      $.each($("input[name='subscription-topics']"), function() {
        var attrib = $(this).attr("value");
        if (subIdValue.length > 0) {
          for (var x = 0; x < subIdValue.length; x++) {
            if (subIdValue[x] === attrib) {
              $(this).attr("checked", "checked");
            }
          }
        }
      });

    }
  }
  var subOptSInKey = localStorage.getItem("subKey");
  localStorage.removeItem("isRedirectToSub");
  var subOptSInKeyArray = [];
  if (typeof(subOptSInKey) !== 'undefined' && localStorage.getItem("nocheck") !== "true") {
    subOptSInKeyArray = subOptSInKey;
    if (subOptSInKeyArray !== 'undefined' && subOptSInKeyArray !== null) {
      localStorage.removeItem("isRedirectToSub");
      var subOptsInKeyValue = subOptSInKeyArray.split("+");
      $.each($("input[name='subscription-topics']"), function() {
        var attribute = $(this).attr("value");
        if (subOptsInKeyValue) {
          for (var x = 0; x < subOptsInKeyValue.length; x++) {
            if (subOptsInKeyValue[x] === attribute) {
              // Code for highlight feature
              $(this).parents(".checkbox.subscriptions").parent().addClass("optin-checked").addClass("optin-origin");
              $(this).attr("checked", "checked");
            }
          }
        }
      });
    }
  }
  $(':checkbox').each(function() {
    $(this).data('initialValue', $(this).is(':checked'));

  });
}


/*
 A function to calculate unsubscribed ids and return the same
 in an array. 
 */
function findUnsubscribedElements(CurrentArray, PreviousArray) {
  var CurrentArrSize = CurrentArray.length;
  var PreviousArrSize = PreviousArray.length;
  var unSubcriptionsIds = [];
  for (var i = 0; i < PreviousArrSize; i++) {
    var isMatch = false;
    var prevIndex = 0;
    for (var y = 0; y < CurrentArrSize; y++) {

      var tempCurrentVal = CurrentArray[y];
      var tempPreviousVal = PreviousArray[i];

      if (tempCurrentVal === tempPreviousVal) {

        isMatch = true;
        break;

      } else {

        prevIndex = i;
      }
    }
    if (!isMatch) {

      var missing = PreviousArray[prevIndex];
      unSubcriptionsIds.push(missing);

    } // Current[i] isn't in prev
  }

  return unSubcriptionsIds;

}




function arraysAreEqual(arr1, arr2) {
  if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length !== arr2.length) {

    return false;
  }
  for (var i = 0; i < arr1.length; i++) {

    if (arr1[i] !== arr2[i])
      return false;

  }
  return true;

}


function populateNewlyAddedElements(array1, array2) {

  var unique = [];

  for (var i = 0; i < array1.length; i++) {
    var found = false;

    for (var j = 0; j < array2.length; j++) { // j < is missed;
      if (array1[i] == array2[j]) {
        found = true;
        break;
      }
    }
    if (found == false) {
      unique.push(array1[i]);
    }
  }

  return unique;

}

function subscriptiondatavalidate() {
  var subIds = [];

  $.each($("input[name='subscription-topics']:checked"), function() {
    subIds.push($(this).val().replace(/["']/g, ""));

  });
  var subidsize = subIds.length;
  if (subidsize > 0) {
    if (!((typeof(resObj.data.myDeloitte.company) != 'undefined' && resObj.data.myDeloitte.company !== "") &&
        (typeof(resObj.data.myDeloitte.jobTitle) != 'undefined' && resObj.data.myDeloitte.jobTitle !== "") && (typeof(resObj.data.myDeloitte.function) != 'undefined' && resObj.data.myDeloitte.function !== "") &&
        (typeof(resObj.data.myDeloitte.country) != 'undefined' && resObj.data.myDeloitte.country !== "") && (typeof(resObj.data.myDeloitte.industry) != 'undefined' && resObj.data.myDeloitte.industry !== ""))) {
      $("#modal-profile-incomplete-subscription").modal('show');
      try {
        
        _satellite.track("subscriptionIncomplete");
      } catch (err) {
      }
      if (typeof(resObj.data.myDeloitte.company) !== 'undefined' && $("#company-name")) {
        $("#company-name").val(resObj.data.myDeloitte.company);
      }
      if (typeof(resObj.data.myDeloitte.zip) !== 'undefined' && $("#zip")) {
        $("#zip").val(resObj.data.myDeloitte.zip);
      }

      if (typeof(resObj.data.myDeloitte.industry) !== 'undefined' && $("#industry-config-for-profile")) {
        $("#industry-config-for-profile").val(resObj.data.myDeloitte.industry);
      }
      if (typeof(resObj.data.myDeloitte.jobTitle) !== 'undefined' && $("#job-title")) {
        $("#job-title").val(resObj.data.myDeloitte.jobTitle);
      }

      if (typeof(resObj.data.myDeloitte.function) !== 'undefined' && $("#job-function-in-professional")) {
        $("#job-function-in-professional").val(resObj.data.myDeloitte.function);
      }
      if (typeof(resObj.data.myDeloitte.country) !== 'undefined' && $("#country-config")) {
        $("#country-config").val(resObj.data.myDeloitte.country);
      }

    } else {

      sendSubscriptionsToGigya();
    }
  } else {
    sendSubscriptionsToGigya();
  }
}

function storerequired() {
  var emptyExists = false;
  $(".form-field .bar").removeClass("error-field");
  $(".form-field p.error-msg").remove();
  if (!$.trim($("#company-name").val()))
    emptyExists = displayError($("#company-name"), emptyExists);
  if (!$("#job-title").val())
    emptyExists = displayError($("#job-title"), emptyExists);
  if (!$("#job-function-in-professional").val())
    emptyExists = displayError($("#job-function-in-professional"), emptyExists);

  if (!$("#country-config").val())
    emptyExists = displayError($("#country-config"), emptyExists);
  if (!$("#industry-config-for-profile").val())
    emptyExists = displayError($("#industry-config-for-profile"), emptyExists);
  if (!emptyExists) {
    try {
      
      _satellite.track("profileSavedOnSubscription");
    } catch (e) {
    }
    resObj.data.myDeloitte.jobTitle = $("#job-title").val();
    resObj.data.myDeloitte.function = $("#job-function-in-professional").val();
    resObj.data.myDeloitte.country = $("#country-config").val();
    resObj.data.myDeloitte.industry = $("#industry-config-for-profile").val();
    resObj.data.myDeloitte.zip = $("#zip").val();
    $("#modal-profile-incomplete-subscription").modal('hide');

    sendSubscriptionsToGigya();
  }
}

function displayError(obj, emptyE) {
  $(obj).closest(".form-field").find(".bar").addClass("error-field");
  $(obj).closest(".form-field").append("<p class='error-msg'>This field is required.</p>");
  if (emptyE == false) {
    emptyE = true;
    $(obj).focus();
  }
  if ($(obj)[0] === $("#country-config")[0])
    $(obj).closest(".form-field").find("p.error-msg").css("margin-top", "-25px");
  return emptyE;
}
if (pagetype === "accountsettings" && accountSetResp !== null) {

    var resObj = accountSetResp;
    var remove = removevar;
    var makemeprimary = makeprimaryvar;
    var reverificationve = reverificationvevar;
  
}
var API_KEY = "";
var subscriptiondata;
var subscribedArticlesArray = [];
var unsubscribedArticlesArray = [];
var originalSubscriptionDataArray = [];
var subscribedArticles = "";
var unsubscribedArticles = "";
var prevSubscribedArticles = "";
var prevUnsubscribedArticles = "";
var subChangesMadeOnAccountSettings = false;
var changedValueNotifi=false;
var changedValueMail=false;

function forwardResponse(response, SOCIAL_API) {
  resObj = response;
  API_KEY = SOCIAL_API;
  sessionStorage.removeItem("subscriptiondata");
}

//Evaluate Session..
var evalAccountSettingsSession = function () {
  var evalParams = {
    apiKey: SOCIAL_API,
    include: "profile,data,emails",
    extraProfileFields: "work,phones",
    callback: evalAccountResponse,
  };
  gigya.accounts.getAccountInfo(evalParams);
};

function evalAccountResponse(response) {
  if (response.errorCode === 0) {
    if (pagetype === "accountsettings" && response !== "undefined") {
      var gigyaSessionCookie = "glt_" + SOCIAL_API;
      var gigyaSessionCookieCheck = getCookie(gigyaSessionCookie);
      if (gigyaSessionCookieCheck !== "" || null != gigyaSessionCookieCheck) {
        var primaryEmail = response.profile.email;
        $("p#primaryemail_id").text(primaryEmail);
        sessionStorage.removeItem("primaryemailid");
        sessionStorage.setItem("primaryemailid", primaryEmail);
        var businessEmail = response.data.myDeloitte.businessEmail;
        $("p#businessemail_id").text(businessEmail);
        var verifiedemails = response.emails.verified;
        var unverifiedemails = response.emails.unverified;
        if (response.data.myDeloitte.consent !== undefined && response.data.myDeloitte.consent.profileFreq) {        	
        $("input:radio[name='myDeloitte.consent.profileFreq'][value="+response.data.myDeloitte.consent.profileFreq+"]").attr('checked',true);
        }
        if (typeof response.data.myDeloitte.sites !== "undefined") {
          if (
            typeof getInterestsAndSubscriptions(response, "subscriptions") !==
              "undefined" &&
            getInterestsAndSubscriptions(response, "subscriptions") !== null
          ) {
            originalSubscriptionDataArray = getInterestsAndSubscriptions(
              response,
              "subscriptions"
            );
          }

          sessionStorage.removeItem("subscriptiondata");
          sessionStorage.setItem(
            "subscriptiondata",
            getInterestsAndSubscriptions(response, "subscriptions")
          );
        }

        if (businessEmail !== null && businessEmail !== "") {
          $("#business-email-add-link").hide();
        }

        if (verifiedemails.length > 0) {
          for (var i = 0; i < verifiedemails.length; i++) {
            if (verifiedemails.length >= 2) {
              var verifyemail = verifiedemails[i];
              if (verifyemail !== primaryEmail) {
                if (verifyemail === businessEmail) {
                  document.getElementById("alternate-email-group").innerHTML +=
                    "<div class='col-md-6'> <p id='" +
                    verifiedemails[i] +
                    "' class='helper__text--smaller'>" +
                    verifiedemails[i] +
                    "<span class='business-email'> (Business email)</span></p></div><div class='col-md-6'><div class='card-body__controls'><p><a href='javascript:void(0);' onclick='updatePrimaryEmail(\"" +
                    verifiedemails[i] +
                    "\")'>" +
                    makemeprimary +
                    "</a> | <a href='javascript:void(0);' onclick='removeEmailmodal(\"" +
                    verifiedemails[i] +
                    "\")'>" +
                    remove +
                    "</a></p></div></div>";
                } else {
                  document.getElementById("alternate-email-group").innerHTML +=
                    "<div class='col-md-6'> <p id='" +
                    verifiedemails[i] +
                    "' class='helper__text--smaller'>" +
                    verifiedemails[i] +
                    "</p></div><div class='col-md-6'><div class='card-body__controls'><p><a href='javascript:void(0);' onclick='updatePrimaryEmail(\"" +
                    verifiedemails[i] +
                    "\")'>" +
                    makemeprimary +
                    "</a> | <a href='javascript:void(0);' onclick='removeEmailmodal(\"" +
                    verifiedemails[i] +
                    "\")'>" +
                    remove +
                    "</a></p></div></div>";
                }
              }
            } else {
              $("#alternate-verified-emails").hide();
            }
          }
        } else {
          $("#alternate-verified-emails").hide();
        }

        if (unverifiedemails.length > 0) {
          for (var j = 0; j < unverifiedemails.length; j++) {
            if (unverifiedemails[j] === businessEmail) {
              document.getElementById(
                "alternate-unverified-email-group"
              ).innerHTML +=
                "<div class='col-md-6'> <p id='" +
                unverifiedemails[j] +
                "' class='helper__text--smaller'>" +
                unverifiedemails[j] +
                "<span class='business-email'> (Business email)</span></p></div><div class='col-md-6'><div class='card-body__controls'><p><a href='javascript:void(0);' onclick='reverification(\"" +
                unverifiedemails[j] +
                "\")' data-email='" +
                unverifiedemails[j] +
                "'>" +
                reverificationve +
                "</a> | <a href='javascript:void(0);' onclick='removeEmailmodal(\"" +
                unverifiedemails[j] +
                "\")'>" +
                remove +
                "</a> </p></div></div>";
            } else {
              document.getElementById(
                "alternate-unverified-email-group"
              ).innerHTML +=
                "<div class='col-md-6'> <p id='" +
                unverifiedemails[j] +
                "' class='helper__text--smaller'>" +
                unverifiedemails[j] +
                "</p></div><div class='col-md-6'><div class='card-body__controls'><p><a href='javascript:void(0);' onclick='reverification(\"" +
                unverifiedemails[j] +
                "\")' data-email='" +
                unverifiedemails[j] +
                "'>" +
                reverificationve +
                "</a> | <a href='javascript:void(0);' onclick='removeEmailmodal(\"" +
                unverifiedemails[j] +
                "\")'>" +
                remove +
                "</a> </p></div></div>";
            }
          }
        } else {
          $("#alternate-unverified-emails").hide();
        }
      } else {
        logOut();
      }
    }
  } else {
    logOut();
  }
}

function addBusinessEmail() {
  var addemail = document.getElementById("add-business-email-field").value;
  if (addemail === sessionStorage.getItem("primaryemailid")) {
    $("#addbusinessemail-validataion-msg").show();
    return;
  }
  if (validateEmailInputType(addemail)) {
    sessionStorage.setItem("businessemail", addemail);
    resObj.data.myDeloitte.businessEmail = addemail;
    var eventParam = {
      "myDeloitte.businessEmail": resObj.data.myDeloitte.businessEmail,
    };
    var params = {
      data: eventParam,
      addLoginEmails: addemail,
      apiKey: SOCIAL_API,
      UID: SOCIAL_PROFILE_UID,
      callback: addBusinessEmailResponse,
    };
    gigya.accounts.setAccountInfo(params);
  }
}


function saveNotificationResponse(response) {
	  if (response.errorCode === 0) {	    
	    sessionStorage.removeItem("response");
	    sessionStorage.setItem("response", JSON.stringify(resObj));
	  } 
}
function addBusinessEmailResponse(response) {
  if (response.errorCode === 0) {
    $("modal-add-business-email").modal("hide");
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(resObj));
    window.location.reload();
  } else {
    $("#addbusinessemail-validataion-msg").show();

  }
}

/* Close Account functions */
function closeAccount() {
  var resObj = sessionStorage.getItem("response");
  resObj = JSON.parse(resObj);
  if (
    typeof resObj.data.mydaas != "undefined" &&
    resObj.data.mydaas.tou !== "undefined"
  ) {
    var parjson = {
      "mydaas.tou": []
    };
    var params = {
      data: parjson,
      apiKey: SOCIAL_API,
      UID: SOCIAL_PROFILE_UID,
      callback: MyDcloseAccount,
    };
    gigya.accounts.setAccountInfo(params);
  } else {
    MyDcloseAccount();
  }
}


function UpdateInitialValues(){

  $(":checkbox").each(function () {
    $(this).data("initialvalue", $(this).is(":checked"));
    
  });
  
  $(":radio").each(function () {
      $(this).data("initialvalue", $(this).is(":checked"));
    
    });
  }
     

/* Close Account functions */
function MyDcloseAccount() {
  var parjson = {
    "myDeloitte.system.accountClosed": true,
  };

  var params = {
    data: parjson,
    apiKey: SOCIAL_API,
    UID: SOCIAL_PROFILE_UID,
    callback: deactivateUser,
  };
  gigya.accounts.setAccountInfo(params);
}

var logOutfromAccountsettingpage = function () {
  gigya.accounts.logout({
    callback: logOutResponseAdminsetting,
  });
};

function deactivateUser(response) {
  if (response.errorCode === 0) {
    logOutfromAccountsettingpage();
  } 
}


function logOutResponseAdminsetting(response) {
  if (response.errorCode === 0) {
    USER_IS_LOGGED = false;
    localStorage.removeItem("loggedIn");
    sessionStorage.clear();
    localStorage.removeItem("remember");
    localStorage.clear();
    localStorage.setItem("userclosedaccount", "true");
    $("#modal-close-account-survey").modal("show");
  } else {

    _satellite.track("logoutError");
  }
}

function closeAccountredirect() {
  var my_account_url = "./registration.html";
  localStorage.clear();
  sessionStorage.clear();
  localStorage.setItem("userclosedaccount", "true");
  window.location.replace(my_account_url);
  return false;
}

function closePopup() {
  $(".mydeloitte-alert").hide();
  $("#header").css("top", "0px");
}

/* Update Primiary Email */
function removeEmailmodal(removeemail) {
  $("#modal-remove-email").modal("show");
  $("#remove-email-value").val(removeemail);
}

/* Update Primiary Email */
function removeBusinessEmailmodal(removeemail) {
  $("#modal-remove-businessemail").modal("show");
  $("#remove-businessemail-value").val(removeemail);
}

function removeBusinessEmail() {
  resObj.data.myDeloitte.businessEmail = "";
  sessionStorage.removeItem("businessemail");
   var eventParam = {
    "myDeloitte.businessEmail": "",
  };
   var params = {
    data: eventParam,
    apiKey: SOCIAL_API,
    UID: SOCIAL_PROFILE_UID,
    callback: removebusinessemailresponse,
  };
  gigya.accounts.setAccountInfo(params);
}

function removebusinessemailresponse(response) {
  if (response.errorCode === 0) {
    window.location.reload();
  } 
}

function removeEmail() {
  var removeemailid = $("#remove-email-value").val();

  var removeemail = {
    removeLoginEmails: removeemailid,
    callback: removeemailresponse,
  };
  gigya.accounts.setAccountInfo(removeemail);
}

function removeemailresponse(response) {
  if (response.errorCode === 0) {
    $("#modal-remove-email").modal("hide");
    if (
      $("#remove-email-value").val() ===
        sessionStorage.getItem("businessemail") ||
      $("#remove-email-value").val() === resObj.data.myDeloitte.businessEmail
    ) {
      removeBusinessEmail();
      if (response.errorCode === 0) {
        sessionStorage.removeItem("response");
        sessionStorage.setItem("response", JSON.stringify(resObj));
        window.location.reload();
      } 
    }
    window.location.reload();
  } 
}

function addEmail() {
  var addemail = document.getElementById("add-email").value;
  if (addemail === sessionStorage.getItem("primaryemailid")) {
    $("#addemail-validataion-msg").show();
    return;
  }
  if (validateEmailInputType(addemail)) {
    var addemailresponse = {
      addLoginEmails: addemail,
      callback: addEmailResponse,
    };
    gigya.accounts.setAccountInfo(addemailresponse);
  }
}

function addEmailResponse(response) {
  if (response.errorCode === 0) {
    $("#modal-add-email").modal("hide");
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(resObj));
    window.location.reload();
  } else {
    $("#addemail-validataion-msg").show();
    
  }
}

function reverification(unverifiedemail) {
  var verificationParams = {
    email: unverifiedemail,
    callback: reverificationresponse,
  };
  gigya.accounts.resendVerificationCode(verificationParams);
}

function reverificationresponse(response) {

    if (response.errorCode === 0 && $(".email-success-msg").length === 0) {
      $(".email-address-section").append(
        "<div class='email-success-msg row pl-2'><span class='icon-myDeloitte-circle icon-check' style='width: 32px; height: 32px;font-size: 18px; border-width: 2px; color: #86bc25; border-color: #86bc25;'></span><p style='margin-left: 5px; margin-top: 5px;'>" +
          reverificationsuccessmail +
          "</p> </div>"
      );
    }
  
}


function updatePrimaryEmail(email) {
  resObj.profile.email = email;
  var emailjson = {
    email: email,
  };
  var paramsemail = {
    profile: emailjson,
    callback: updatePrimaryEmailres,
  };
  gigya.accounts.setAccountInfo(paramsemail);
}

function updatePrimaryEmailres(response) {
  if (typeof response.errorCode !== "undefined" && response.errorCode === 0) {
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(resObj));
    window.location.reload();
  } 
}

function onUpdate(data) {
  if (data.response.errorCode === 0) {
    $("#modal-update-password").modal("hide");
    if ($(".success-msg").length === 0) {
      $(".change-password-section").append(
        "<div class='success-msg row pl-2'><span class='icon-myDeloitte-circle icon-check' style='width: 32px; height: 32px;font-size: 18px; border-width: 2px; color: #86bc25; border-color: #86bc25;'></span><p style='margin-left: 5px; margin-top: 5px;'>" +
          changepwdsuccessmsg +
          "</p> </div>"
      );
    }
  }
}

$(document).ready(function () {
  if (pagetype === "accountsettings") {    
    // if checked - disable all of them
    if ($("input#all-unsubscribe").is(":checked")) {
      $("input[type='checkbox'][name='subs-switch']").prop("checked", false);
      $(".emailSubs").addClass("disabled");
    }
    

    // populate email and disable the fp modal input
    $("#modal-forgot-password").on("show.bs.modal", function () {
      $(this)
        .find("gigya-input-text")
        .val(resObj.profile.email)
        .attr("disabled");
    });
    // populate email and disable the fp modal input
    $("#modal-forgot-password").on("show.bs.modal", function () {
      $("#gigya-forgot-password-screen-container .gigya-input-text").val(
        resObj.profile.email
      );
    });
  }

  $("#add-email").focusout(function () {
    if (!validateEmailInputType(this.value) && $("#add-email").val() !== "") {
      $("#addemail-regex-msg").text(invalidEmail);
    } else {
      $("#addemail-regex-msg").text("");
    }
  });
  $("#add-business-email-field").focusout(function () {
    if (
      !validateEmailInputType(this.value) &&
      $("#add-business-email-field").val() !== ""
    ) {
      $("#addbusinessemail-regex-msg").text(invalidEmail);
    } else {
      $("#addbusinessemail-regex-msg").text("");
    }
  });
});

function UpdateSaveButtonNotification(){
    
    changedValueNotifi=false;

    $(":checkbox").each(function () {
      
        if ($(this).data("initialvalue") !== $(this).is(":checked")) {

            changedValueNotifi=true;
          }
                 
    });
    $(":radio").each(function () {
        if ($(this).data("initialvalue") !== $(this).is(":checked")) {
         
            changedValueNotifi=true;
          }
    });


  if(changedValueNotifi===true){
    $("#savebuttonnotification").prop("disabled",false);
    $("#savebuttonnotification").css("background","#005587");
    $("#savebuttonmail").prop("disabled",false);
    $("#savebuttonmail").css("background","#005587");
    
}else{
    $("#savebuttonnotification").prop("disabled",true);
    $("#savebuttonnotification").css("background","#A7A8AA");
    $("#savebuttonmail").prop("disabled",true);
    $("#savebuttonmail").css("background","#A7A8AA");
   
}

}

function UpdateSaveButtonMail(){
  changedValueMail=false;


//if any change is made then changing value to true
  $(":checkbox").each(function () {
      if ($(this).data("initialvalue") !== $(this).is(":checked")) {
       
          changedValueMail=true;
        }
               
  });
  $(":radio").each(function () {
      if ($(this).data("initialvalue") !== $(this).is(":checked")) {
          changedValueMail=true;
       
      }
  });

  if(changedValueMail===true){
    $("#savebuttonnotification").prop("disabled",false);
    $("#savebuttonnotification").css("background","#005587");
    $("#savebuttonmail").prop("disabled",false);
    $("#savebuttonmail").css("background","#005587");
    
}else{
    $("#savebuttonnotification").prop("disabled",true);
    $("#savebuttonnotification").css("background","#A7A8AA");
    $("#savebuttonmail").prop("disabled",true);
    $("#savebuttonmail").css("background","#A7A8AA");
   
}

}

function UnsubscribeAll(){
  changedValueMail=false;

  if ($("input#all-unsubscribe").is(":checked")) {

    $("input[type='checkbox'][name='subs-switch']").prop("checked", false);
    $(".emailSubs").addClass("disabled");


} else {
    
    $(".emailSubs").removeClass("disabled");

     $(":checkbox").each(function () {   
      //updating all subscription toggles
      if($(this).attr("name")==="subs-switch"){
        $(this).prop("checked", $(this).data("initialvalue"));
      }
             
     });
   
}

//if any change is made then changing value to true
  $(":checkbox").each(function () {
      if ($(this).data("initialvalue") !== $(this).is(":checked")) {
       
          changedValueMail=true;
        }
               
  });
  $(":radio").each(function () {
      if ($(this).data("initialvalue") !== $(this).is(":checked")) {
          changedValueMail=true;
       
      }
  });

  //if any change in the page
  if(changedValueMail===true){
    $("#savebuttonnotification").prop("disabled",false);
    $("#savebuttonnotification").css("background","#005587");
    $("#savebuttonmail").prop("disabled",false);
    $("#savebuttonmail").css("background","#005587");
    
}else{
    $("#savebuttonnotification").prop("disabled",true);
    $("#savebuttonnotification").css("background","#A7A8AA");
    $("#savebuttonmail").prop("disabled",true);
    $("#savebuttonmail").css("background","#A7A8AA");
   
}
}

function InitialSetValue(){

  //initially disabling the buttons    
  $("#savebuttonnotification").css("background","#A7A8AA");
	$("#savebuttonnotification").prop("disabled",true);

  $("#savebuttonmail").css("background","#A7A8AA");
	$("#savebuttonmail").prop("disabled",true);

  //setting initial values of checkbooxes and radioboxes
  $(":checkbox").each(function () {
    $(this).attr("data-initialvalue", $(this).is(":checked"));
   
  });

  $(":radio").each(function () {
      $(this).attr("data-initialvalue", $(this).is(":checked"));

    });
    
}

var calledSave=0;
var isReceiveEmails;
myDeloitteApp.controller("accountsettingsCtrl", [
  "$scope",
  "$http",
  function ($scope) {
    $scope.isEmailNotifi=(emailNotification === "true") 
	  $scope.isPushNotifi=(pushNotification === "true")
    $scope.isEmailPreferences = (OPTIN_EMAIL_NOTIFICATION === "true");
    $scope.isLoaded=false;

    getSessionResponse().then(function(accountSetResp){

    resObj = accountSetResp;
     
    if (
      typeof accountSetResp.data.myDeloitte.consent != "undefined" &&
      typeof accountSetResp.data.myDeloitte.consent.profile != "undefined"
    ) {
      var emailalerts = accountSetResp.data.myDeloitte.consent.profile;
      localStorage.removeItem("emailalerts");
      localStorage.setItem("emailalerts", emailalerts);
    } else {
      localStorage.removeItem("emailalerts");
      localStorage.setItem("emailalerts", false);
    }

    if (
      typeof accountSetResp.data.myDeloitte.consent != "undefined" &&
      typeof accountSetResp.data.myDeloitte.consent.fullUnsubscribe !=
        "undefined"
    ) {
      var unsubscribe = accountSetResp.data.myDeloitte.consent.fullUnsubscribe;
      localStorage.removeItem("unsubscribeall");
      localStorage.setItem("unsubscribeall", unsubscribe);
    } else {
      localStorage.removeItem("unsubscribeall");
      localStorage.setItem("unsubscribeall", false);
    }

    var alertall = localStorage.getItem("emailalerts");
    var boolValue = /true/i.test(alertall);
    $scope.alertAll = boolValue;
    sessionStorage.setItem(
      "subscriptiondata",
      getInterestsAndSubscriptions(accountSetResp, "subscriptions")
    );
    var unsubscribeall = localStorage.getItem("unsubscribeall");
    var unsubscribeallboolean = /true/i.test(unsubscribeall);
    $scope.allUnsubscribe = unsubscribeallboolean;

   
    var siteLocale = myDelLocale.replace(/\//g, "_");
    var subs="/subscriptionsdata";

    $.getJSON({
      async: false,
      global: false,
      url: window.location.href.split(".html")[0]+".deloitte-subscriptionsdata.json",
      data: {
        subscriptionkeys: sessionStorage.getItem("subscriptiondata"),
        site: siteLocale,
      },
    }).then(
      function (data) {
        $scope.data = data;
      },
      function () {
        
      }
    );

    $scope.getSubscriptionIds = function () {
      var subIds = [];
      subChangesMadeOnAccountSettings = false;
      var tempsubscriptionTitle;

      subscribedArticlesArray = [];
      unsubscribedArticlesArray = [];

      prevSubscribedArticles = subscribedArticles;
      prevUnsubscribedArticles = unsubscribedArticles;

      subscribedArticles = "";
      unsubscribedArticles = "";

      for (var key in $scope.data) {
        if($scope.data.hasOwnProperty(key)){
        var subid = $scope.data[key]["subscriptionID"];

        tempsubscriptionTitle = $scope.data[key]["subscriptiontitle"];

        if ($("#" + subid).is(":checked")) {
          subIds.push(subid);
          subscribedArticlesArray.push(tempsubscriptionTitle);
        } else {
          unsubscribedArticlesArray.push(tempsubscriptionTitle);
        }
      }
      }

      subscribedArticles = subscribedArticlesArray.join(",");
      unsubscribedArticles = unsubscribedArticlesArray.join(",");

      var index;

      subscribedArticles = ";";
      unsubscribedArticles = ";";

      for (index = 0; index < subscribedArticlesArray.length; ++index) {
        subscribedArticles =
          subscribedArticles + subscribedArticlesArray[index] + ",;";
      }

      if (subscribedArticles !== ";") {
        subscribedArticles = subscribedArticles.substring(
          0,
          subscribedArticles.lastIndexOf(",;")
        );
      } else {
        subscribedArticles = "";
      }

      for (index = 0; index < unsubscribedArticlesArray.length; ++index) {
        unsubscribedArticles =
          unsubscribedArticles + unsubscribedArticlesArray[index] + ",;";
      }

      if (unsubscribedArticles !== ";") {
        unsubscribedArticles = unsubscribedArticles.substring(
          0,
          unsubscribedArticles.lastIndexOf(",;")
        );
      } else {
        unsubscribedArticles = "";
      }

      if (prevSubscribedArticles !== "" && prevUnsubscribedArticles !== "") {
        if (
          prevSubscribedArticles !== subscribedArticles ||
          prevUnsubscribedArticles !== unsubscribedArticles
        ) {
          subChangesMadeOnAccountSettings = true;
        } else {
          subChangesMadeOnAccountSettings = false;
        }
      } else {
        subChangesMadeOnAccountSettings = true;
      }

      if (unsubscribedArticles === "") {
        subChangesMadeOnAccountSettings = false;
      }

      return subIds;
    };

    $scope.setSubscriptionData = function () {
      var sublength = $scope.getSubscriptionIds().length;
      var subids = $scope.getSubscriptionIds();
    
      var str = JSON.stringify(subids);
      var subktr = str.split(",");


      if (resObj.data.myDeloitte.sites === undefined) {
        resObj.data.myDeloitte.sites = [];
      }

      
    
      if(calledSave===0){
        calledSave=1;
        $scope.saveNotifications();

      }else{
            calledSave=0;
      }
     

      
      if (sublength !== originalSubscriptionDataArray.length) {
        subChangesMadeOnAccountSettings = true;
      } else {
        subChangesMadeOnAccountSettings = false;
      }

      var interestStr = [];
      if (resObj !== undefined && resObj.data.myDeloitte.sites !== undefined) {
        interestStr = getInterestsAndSubscriptions(resObj, "interests");
        var intStr = JSON.stringify(interestStr);
        var intKeyStr = intStr.split(",");
        var subscriptiondata = null;
        if ($("#all-unsubscribe").is(":checked")) {
          subscriptiondata =
            "{" +
            '"myDeloitte.sites": ' +
            '[{"site": ' +
            site +
            ', "interests" : ' +
            intKeyStr +
            ', "subscriptions" : []}],"myDeloitte.consent.fullUnsubscribe": true ,"myDeloitte.consent.fullDate":"' +
            new Date().toISOString() +
            '","myDeloitte.consent.profile":false,"myDeloitte.consent.profileDate":"' +
            new Date().toISOString() +
            '"';
          if (resObj.data.myDeloitte.sites === undefined) {
            resObj.data.myDeloitte.sites = [];
          } else {
            resObj.data.myDeloitte.sites = [
              {
                site: JSON.parse(site),
                interests: JSON.parse(intKeyStr),
                subscriptions: [],
              },
            ];
          }
          if (resObj.data.myDeloitte.consent === undefined) {
            resObj.data.myDeloitte.consent = {};
          } else {
            resObj.data.myDeloitte.consent.profileDate = new Date().toISOString();
            resObj.data.myDeloitte.consent.fullUnsubscribe = true;
            resObj.data.myDeloitte.consent.fullDate = new Date().toISOString();
          }
          isRecievedMails = false;
        } else {
          subscriptiondata =
            "{" +
            '"myDeloitte.sites": ' +
            '[{"site": ' +
            site +
            ', "interests" : ' +
            intKeyStr +
            ', "subscriptions" : ' +
            subktr +
            '}],"myDeloitte.consent.fullUnsubscribe": false,"myDeloitte.consent.fullDate":"' +
            new Date().toISOString() +
            '"';
          if (resObj.data.myDeloitte.sites === undefined) {
            resObj.data.myDeloitte.sites = [];
          } else {
            resObj.data.myDeloitte.sites = [
              {
                site: JSON.parse(site),
                interests: JSON.parse(intKeyStr),
                subscriptions: JSON.parse(subktr),
              },
            ];
          }
          if (resObj.data.myDeloitte.consent === undefined) {
            resObj.data.myDeloitte.consent = {};
          } else {
            resObj.data.myDeloitte.consent.fullUnsubscribe = false;
            resObj.data.myDeloitte.consent.fullDate = new Date().toISOString();
          }
        }

        if (!$("#all-unsubscribe").is(":checked")) {
          if ($("#all-alerts").is(":checked")) {
            isRecievedMails = true;
            subscriptiondata =
              subscriptiondata +
              ',"myDeloitte.consent.profile":true,"myDeloitte.consent.profileDate":"' +
              new Date().toISOString() +
              '"';
          } else {
            isRecievedMails = false;
            subscriptiondata =
              subscriptiondata +
              ',"myDeloitte.consent.profile":false ,"myDeloitte.consent.profileDate":"' +
              new Date().toISOString() +
              '"';
          }
        }

        subscriptiondata = subscriptiondata + "}";
        
        if (resObj.data.myDeloitte.consent === undefined) {
          resObj.data.myDeloitte.consent = {};
        }
        resObj.data.myDeloitte.consent.profile = isRecievedMails;
        var paramssubscriptiondata = {
          data: subscriptiondata,
          callback: setSubscrptiondataresponse,
        };
        if ($('#email-notifi[type="checkbox"]').is(':checked')) {
            if ($('#emails-daily, #emails-weekly, #emails-monthly').is(':checked')) {
                gigya.accounts.setAccountInfo(paramssubscriptiondata);
            }
        } else if ($('#push-notifi[type="checkbox"]').is(':checked')) {
            gigya.accounts.setAccountInfo(paramssubscriptiondata);
        } else {
            gigya.accounts.setAccountInfo(paramssubscriptiondata);
        }
      }
    };

    function setSubscrptiondataresponse(response) {
      if (response.errorCode === 0) {
        sessionStorage.removeItem("subscriptiondata");
        sessionStorage.removeItem("response");
        subscriptionsCount(resObj);
        sessionStorage.setItem("response", JSON.stringify(resObj));
       
        
        //disabling the buttons and updating initial values
        $("#savebuttonmail").prop("disabled",true);
        $("#savebuttonmail").css("background","#A7A8AA");
        changedValueMail=false;
        UpdateInitialValues();
               
      } else {
      
        sessionStorage.removeItem("subscriptiondata");
      }
    }

    

    //checkbox toggle thing
    $("input#all-unsubscribe").on("change", function () {
      if ($(this).is(":checked")) {
        $("input[type='checkbox'][name='subs-switch']").prop("checked", false);
        $(".emailSubs label span").html("Unsubscribed");
        $(".emailSubs").addClass("disabled");
      } else {
        $("input[type='checkbox'][name='subs-switch']").prop("checked", true);
        $(".emailSubs label span").html("Subscribed");
        $(".emailSubs").removeClass("disabled");
      }
      $scope.getSubscriptionIds();
    });
    
    // email and push notification
    if (resObj.data.myDeloitte.consent === undefined) {
        resObj.data.myDeloitte.consent = {};
        resObj.data.myDeloitte.consent.profile = false;
        resObj.data.myDeloitte.consent.webPush = false;
      }
	    $scope.emailNotifiSwitch = (resObj.data.myDeloitte.consent.profile) ?  resObj.data.myDeloitte.consent.profile : false;
	    $scope.pushNotifiSwitch = (resObj.data.myDeloitte.consent.webPush) ? resObj.data.myDeloitte.consent.webPush : false;
	    $scope.emailFrequency = resObj.data.myDeloitte.consent.profileFreq;
	    

      $scope.isLoaded=true;
      $scope.$apply();

      InitialSetValue();


      var goToAnchorTag = function(hash) {
        if ($("" + hash + "").length) {
          $("html, body").animate(
            {
              scrollTop: $("" + hash + "").offset().top - 200,
            },
            1500
          );
        }
      }
  
      // nav tabs focus thing
      $("ul.nav-tabs li a").click(function (e) {
        e.preventDefault();
        $(this).tab("show");
        var hash = window.location.hash;
        goToAnchorTag(hash);
      });
  
      // store the currently selected tab in the hash value
      $("ul.nav-tabs > li > a").on("shown.bs.tab", function (e) {
        var id = $(e.target).attr("href").substr(1);
        window.location.hash = id;
      });
  
      // on load of the page: switch to the currently selected tab
      var hash = window.location.hash;
      $('ul.nav-tabs a[href="' + hash + '"]').tab("show");
      goToAnchorTag(hash);

    
    $scope.saveNotifications= function(){
        // email and push notification
      
      //disabling the buttons and updating initial values
      if($('#email-notifi[type="checkbox"]').is(':checked')){
        if($('#emails-daily, #emails-weekly, #emails-monthly').is(':checked')){
          $("#savebuttonnotification").prop("disabled", true);
          $("#savebuttonnotification").css("background","#A7A8AA");
        }
      } else if($('#push-notifi[type="checkbox"]')){
          $("#savebuttonnotification").prop("disabled", true);
          $("#savebuttonnotification").css("background","#A7A8AA");
      }else {
          $("#savebuttonnotification").prop("disabled", true);
          $("#savebuttonnotification").css("background","#A7A8AA");
      }
      changedValueNotifi=false;
      UpdateInitialValues();
      
		  if(calledSave===0){
          calledSave=1;
			$scope.setSubscriptionData();

      }else{
            calledSave=0;
      }
      
    
        

    	var profileFrequency = $(
    			"input[type='radio'][name='myDeloitte.consent.profileFreq']:checked").val();
    	var emailNotification = $(
    			"input[type='checkbox'][name='email-notifi']:checked").val();
    	var pushNotification = $(
    			"input[type='checkbox'][name='push-notifi']:checked").val();
    	emailNotification = (emailNotification === "on") ? true : false;
    	pushNotification= (pushNotification === "on") ? true : false;
    	if (resObj.data.myDeloitte.consent === undefined) {
    	        resObj.data.myDeloitte.consent = {};
    	}
    	resObj.data.myDeloitte.consent.profile = emailNotification ;
    	resObj.data.myDeloitte.consent.webPush = pushNotification;
    	resObj.data.myDeloitte.consent.profileFreq = (emailNotification == true) ? profileFrequency: '';	
    	if(!(emailNotification && profileFrequency === undefined)){
    		var notifiParam = {
    	    		"myDeloitte.consent.profileFreq" : resObj.data.myDeloitte.consent.profileFreq,
    	    		"myDeloitte.consent.profile" : resObj.data.myDeloitte.consent.profile,
    	    		"myDeloitte.consent.profileDate" : returnProfileConsentDate(emailNotification).replace(/"/g, ""),
    	    		"myDeloitte.consent.webPush" : resObj.data.myDeloitte.consent.webPush,
    	    		"myDeloitte.consent.webPushDate" : returnProfileConsentDate(pushNotification).replace(/"/g, ""),
    	    	};
    	    	var params = {
    	    		data : notifiParam,
    	    		apiKey : SOCIAL_API,
    	    		UID : SOCIAL_PROFILE_UID,
    	    		callback : saveNotificationResponse,
    	    	};
    	    	if ($('#email-notifi[type="checkbox"]').is(':checked')) {
    	    	    if ($('#emails-daily, #emails-weekly, #emails-monthly').is(':checked')) {
    	    	        gigya.accounts.setAccountInfo(params);
    	    	    }
    	    	} else if ($('#push-notifi[type="checkbox"]').is(':checked')) {
    	    	    gigya.accounts.setAccountInfo(params);
    	    	} else {
    	    	    gigya.accounts.setAccountInfo(params);
    	    	}
    	
    	} else {
    		$scope.noficErrorcheck();
    	}
		if(resObj.data.myDeloitte.consent.webPush === true){
            registerNotifications();
        }else{
			optoutNotifications();
        }
    		
    }
/** Hide and show of Email preferences tab for US: 781465**/
$scope.noficErrorcheck=function () {
	var profileFrequency = $(
	"input[type='radio'][name='myDeloitte.consent.profileFreq']:checked").val();
    $scope.isError= resObj.data.myDeloitte.consent.profile && !profileFrequency;
    
}
    
    
  });
  },
]);

/** US_313774 Update Account Settings code impl starts from here **/
function updateAccountSettingsIntSub(cookieValue) {
  
  if (resObj && resObj.data.myDeloitte !== undefined) {
    resObj.data.myDeloitte.prefSite = cookieValue;
    if (
      localStorage.getItem("prevSite") !== null &&
      localStorage.getItem("prevSite") !== undefined &&
      localStorage.getItem("prevSite") !== ""
    ) {
      resObj.data.myDeloitte.prevSite = localStorage.getItem("prevSite");
    } else {
      resObj.data.myDeloitte.prevSite = "global-en";
    }
    resObj.data.myDeloitte.tou.date = new Date().toISOString();
    if (resObj.data.myDeloitte.sites === undefined) {
      resObj.data.myDeloitte.sites = [];
    }
    if (resObj.data.myDeloitte.sites !== undefined) {
      resObj.data.myDeloitte.sites = [{ site: cookieValue }];
    }
  }

    //to clear the promos of last member firm before change
    sessionStorage.removeItem('tagsjson');

  

  var dataParamJson = {
    "myDeloitte.prevSite": resObj.data.myDeloitte.prevSite,
    "myDeloitte.prefSite": resObj.data.myDeloitte.prefSite,
    "myDeloitte.tou.date": resObj.data.myDeloitte.tou.date,
    "myDeloitte.sites": resObj.data.myDeloitte.sites,
  };

  var params = {
    data: dataParamJson,
    apiKey: SOCIAL_API,
    UID: SOCIAL_PROFILE_UID,
    callback: updateAccountSettingsRes,
  };
  gigya.accounts.setAccountInfo(params);
}

function updateAccountSettingsRes(response) {
  if (typeof response.errorCode !== "undefined" && response.errorCode === 0) {
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(resObj));
    window.location = "./profile.html#profile-interest";
  }
}
/** US_313774 Update Account Settings code impl ends here **/

//418099
function validateEmailInputType(email) {
  var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(String(email).toLowerCase());
}

function validateEmailForForgotUser() {
  var emailid = $(
    "#gigya-forgot-password-screen-container .gigya-input-text"
  ).val();
  if (!validateEmailInputType(emailid)) {
    $("#forgotpassword-regex-msg").text(invalidEmail);
  } else {
    $("#forgotpassword-regex-msg").text("");
  }
}

myDeloitteApp.controller("bookmarksCtrl", [
  "$scope",
  "$q",
  "transformService",
  "utilityService",
  function ($scope, $q, transformService, utilityService) {
    $scope.bookmarkIds = "";
    $scope.promosdata = "";
    $scope.requestParams = "";
    $scope.showLoadMoreForNonEvents = 0;
    $scope.showLoadMoreForEvents = 0;
    $scope.bookmarkEventsResults = [];
    var initialNoEventContainerHeight;

    getSessionResponse().then(function (response) {
      $(document).on('OTReady', function(){
        $scope.isFunctionalCategorySelected = cookieComplianceHelperJS.isCookieCategorySelected(3);
        $scope.$apply();
      })
      var counter = 0;
      var upperLimit = 8;
      var temp_bookmarkIds = "";
      var bookmarkDetails = response.data.myDeloitte.bookmarks;
      var pageNumForNonEvents = 1;
      var pageNumForEvents = 1;
      var pageRecords = 8; // keeping count = 8 to fetch 8 results at a time
      $scope.totalBookmarksCount = bookmarkDetails ? bookmarkDetails.length : 0;

      $scope.getdata = function (counter, upperLimit) {
        $scope.makeRequestParams();
        if (!bookmarkDetails || bookmarkDetails.id === " ") {
          $scope.bookmarksCount = 0;
        } else {
          $scope.bookmarksCount = bookmarkDetails.length;
        }
        if ($scope.bookmarksCount === 0) {
          $(".bookmarks-count").hide();
          $(".viewall-bookmarks-link").css("display", "none");
        }
        temp_bookmarkIds = "";
        var lengthCheck = upperLimit + 1;
        if ($scope.bookmarksCount < lengthCheck) {
          $(".loadMoreButton").hide();
          upperLimit = $scope.bookmarksCount;
        }
        for (var i = counter; i < upperLimit; i++) {
          var obj = bookmarkDetails[i];
          if (obj.id !== undefined) {
            temp_bookmarkIds = temp_bookmarkIds + obj.id + "|";
            $scope.bookmarkIds = temp_bookmarkIds;
          }
        }
        if (
          $scope.bookmarkIds !== "" &&
          $scope.bookmarkIds != null &&
          $scope.bookmarkIds !== undefined
        ) {
          $scope.getResults($scope.bookmarkIds);
        } else {
          $(".bookmark-items .no-results").show();
          $(".loadMoreButton").hide();
          $(
            ".bookmark-items__title-text,.bookmark-items .section-header-content__title,.bookmark-items .dashboard-redirect-container"
          ).hide();
          $scope.showEmptyEventArticleContainer = true;
          $scope.$apply($scope.finished);
        }
      };

      $scope.makeRequestParams = function () {
        var temp_bookmarkIds = " ";
        if (bookmarkDetails && bookmarkDetails.length) {
          for (var i = 0; i < bookmarkDetails.length; i++) {
            var obj = bookmarkDetails[i];
            if (obj.id !== undefined) {
              temp_bookmarkIds = temp_bookmarkIds + obj.id + "|";
              $scope.requestParams = temp_bookmarkIds;
            }
          }
        }
      };
 
      $scope.getResults = function (query) {
        $scope.query = query;
        //get interests count
        var interestTopics = localStorage.getItem("profileInterestsForSNP");
        interestTopics = interestTopics.split(',');
        interestTopics = interestTopics.filter(function (entry) {
          return entry.trim() !== "";
        });
        $scope.interestsCount = interestTopics.length;
        if (pagetype !== "dashboard") {
          if (isEventEnabled === "true") {
            $q.all([$scope.getArticles(), $scope.getEvents()]).then(function (
              result
            ) {
              if (result[0] && result[1]) {
              	angular.element("div.skeleton").hide();
                if (
                  $scope.bookmarkResults.length === 0 &&
                  $scope.bookmarkEventsResults.length === 0
                ) {
                  $scope.showEmptyEventArticleContainer = true;
                  $("#redirect-link-events").css("display", "none");
                  $("#redirect-link-articles").css("display", "none");
                  $("#interests-side-link").css("display", "block");
                } else if (
                  $scope.bookmarkEventsResults &&
                  $scope.bookmarkEventsResults.length === 0
                ) {
                  $scope.showEmptyEventContainer = true;
                  $("#redirect-link-events").css("display", "none");
                  $("#interests-side-link").css("display", "block");
                }
              }
            });
          } else {
            $scope.getArticles().then(function () {
              $("#redirect-link-events").css("display", "none");
              $("#interests-side-link").css("display", "block");
              $(".bookmark-items").css("margin-top", "0");
              if ($scope.bookmarkResults.length === 0) {
                $scope.showEmptyEventArticleContainer = true;
              }
              $scope.$apply($scope.finished);
            });
          }
        } else {
          //get all bookmarks details
          $scope.getAllBookmarks();
        }
      };

      $scope.getAllBookmarks = function () {
        transformService
          .getAllBookmarksForDashboard(
            $scope.requestParams
          )
          .then(function (responseData) {
            if (
              responseData &&
              responseData["result-sets"] &&
              responseData["result-sets"].length >= 1
            ) {
              var resultSet = responseData["result-sets"];
              $scope.bookmarkResults = [];
              resultSet.forEach(function (singlePromo) {
                if ($scope.bookmarkResults.length !== 2 && singlePromo["page-type"] !== "flex-eventdetails") {
                    $scope.bookmarkResults.push(singlePromo);
                  
                }
              });
              // filter any event present in whole result set
              resultSet.filter(function (singlePromo) {
                if (
                  singlePromo["page-type"] === "flex-eventdetails" &&
                  $scope.bookmarkResults.length !== 3
                ) {
                  var displayPastLabel =
                    new Date() > new Date(singlePromo["start-date"]);
                  singlePromo.pastEvent = displayPastLabel;
                  $scope.bookmarkResults.push(singlePromo);
                } else {
                  return;
                }
              });
              // check if not event then push non event data to bookmarks Results
              if (
                $scope.bookmarkResults.length !== 3 &&
                resultSet &&
                resultSet.length > 3
              ) {
                $scope.bookmarkResults.push(resultSet[4]);
              }
            }
            $scope.$apply($scope.finished);
          });
      };
      $scope.getArticles = function () {
        return new Promise(function (resolve) {
          transformService
            .getArticlesForSavedItems(
              $scope.requestParams,
              pageNumForNonEvents
            )
            .then(function (responseData) {
              if (
                responseData &&
                responseData["result-sets"] &&
                responseData["result-sets"].length
              ) {
                $scope.articlesCount = parseInt(responseData["total-results"]);
                $scope.showLoadMoreForNonEvents =
                  $scope.articlesCount - pageRecords * pageNumForNonEvents;
                var newData = responseData["result-sets"];
                if (!$scope.promosdata == "") {
                  for (var j = 0; j < newData.length; j++) {
                    $scope.promosdata.push(newData[j]);
                  }
                } else {
                  $scope.promosdata = newData;
                }
                $scope.bookmarkResults = $scope.promosdata;
                $scope.$apply($scope.finished);
              } else {
                $scope.bookmarkResults = [];
              }
              resolve(true);
              if (pageNumForNonEvents > 1) {
                var eventContainerHeight = $("#col-group-2").height()
                  ? $("#col-group-2").height()
                  : $(".myfeed-events--no-feeds").height();
                
                var calculatedHeight = 0;
                if (isEventEnabled === "true") {
                  calculatedHeight =
                    initialNoEventContainerHeight + eventContainerHeight + 250;
                } else {
                  calculatedHeight = initialNoEventContainerHeight + 150;
                }
                window.scroll(0, calculatedHeight);
              }
            });
        });
      };

      $scope.getEvents = function () {
        return new Promise(function (resolve) {
          transformService
            .getEventsForSavedItems(
              $scope.requestParams,
              pageNumForEvents
            )
            .then(function (responseData) {
              if (
                responseData &&
                responseData["result-sets"] &&
                responseData["result-sets"].length >= 1
              ) {
                $scope.eventsCount = parseInt(responseData["total-results"]);
                $scope.showLoadMoreForEvents =
                  $scope.eventsCount - pageRecords * pageNumForEvents;
                var newData = responseData["result-sets"];
                for (var index = 0; index < newData.length; index++) {
                  var displayPastLabel =
                    new Date() > new Date(newData[index]["start-date"]);
                  newData[index].pastEvent = displayPastLabel;
                  $scope.bookmarkEventsResults.push(newData[index]);
                }
                $scope.$apply($scope.finished);
              } else {
                $scope.bookmarkEventsResults = [];
              }
              if (pageNumForEvents > 1) {
                var promosContainerHeight = $(
                  "#bookmarks-container-events"
                ).height();
                window.scrollTo(0, promosContainerHeight - 150);
                //reducing additional 150 px to so that top of the freshly populated promos is populated;
              }
              resolve(true);
            });
        });
      };

      // for shuffling events & articles curated data
      $scope.shuffleArray = function (array) {
        var m = array.length,
          t,
          i;
        // While there remain elements to shuffle
        while (m) {
          // Pick a remaining element
          i = randomValue(m--);
          // And swap it with the current element.
          t = array[m];
          array[m] = array[i];
          array[i] = t;
        }
        return array;
      };

      $scope.renderJson = function () {
        $scope.bookmarkResults = $scope.promosdata;
        $scope.$apply();
        $scope.finished();
      };
      /*Function to trim html tags in descrption*/
      $scope.getDescription = function (promo) {
        return utilityService.getDescription(promo);
      };
      /*Function to get the bookmark date*/
      $scope.getbookmarkDate = function (promo) {
        return utilityService.getbookmarkDate(promo);
      };
      /* Function to bookmark the page*/
      $scope.sendBookmark = function (promoId, $event) {
        utilityService.sendBookmark(promoId, $event);
      };
      /*Function to add the additional class for insights promos*/
      $scope.getPromoClass = function (promo) {
        return utilityService.getPromoClass(promo);
      };
      /*Function to get the promo page url*/
      $scope.getPageURL = function (promoPageURL) {
        return utilityService.getPageURL(promoPageURL);
      };
      /*Function to show the Deloitte Insights text for Deloitte Insights promos*/
      $scope.showText = function () {
        return utilityService.showText();
      };
      /* US 263605: Function to show the Deloitte Insights Logo for Deloitte Insights promos*/
      $scope.showLogo = function () {
        return utilityService.showLogo();
      };
      $scope.getEventPromoClass = function (promo) {
        return utilityService.getEventPromoClass(promo);
      };

      $scope.getStartMonthForEvents = function (promo) {
        return utilityService.getStartMonthForEvents(promo);
      };

      $scope.getStartDateForEvents = function (promo) {
        return utilityService.getStartDateForEvents(promo);
      };

      $scope.getPublishedDateFormatted = function (promo) {
        return utilityService.getPublishedDateFormatted(promo);
      };

      /* US 263605: Function to get the page type to differntiate Deloitte Insights & Dcom promos*/
      $scope.getPageType = function (promo) {
        return utilityService.getPageType(promo);
      };
      /*Function to get the thumbnail*/
      $scope.getThumbnail = function (promo) {
        return utilityService.getThumbnail(promo);
      };
      /*Function to get the thumbnail*/
      $scope.getIEThumbnail = function (promo) {
        return utilityService.getIEThumbnail(promo);
      };
      /*Function to get the mobile rendition of thumbnail*/
      $scope.getMobileThumbnail = function (promo) {
        return utilityService.getMobileThumbnail(promo);
      };
      /*Function to call on clicking Load more*/
      $scope.loadMore = function () {
        if (counter === 0) {
          counter = counter + 8;
        } else {
          counter = counter + 9;
        }
        upperLimit = upperLimit + 9;
        pageNumForNonEvents++;
        $scope.getArticles();
        initialNoEventContainerHeight = $(
          "#bookmarks-container-non-events"
        ).height();
      };
      $scope.loadMoreEvents = function () {
        pageNumForEvents++;
        $scope.getEvents();
      };

      /* Function to call dotdotdot js*/
      $scope.finished = function () {
        angular.element("div.skeleton").hide();
        angular.element(".bookmark-items").show();
        if (window.matchMedia("(max-width: 767px)").matches) {
          return;
        }
        customShave(".dot-ellipsis", 70);
      };
      $scope.getdata(counter, upperLimit);
    });
  },
]);

// Fix the bookmark count on page scroll
function bookmarksCountPosition() {
  var windowWidth = window.innerWidth - 20;
  var bookmarksWidth = $(".bookmarks").innerWidth();
  var bookmarksCountWidth = $(".bookmarks-count").innerWidth() * 2;
  var bookmarksPosition = windowWidth - (bookmarksWidth + bookmarksCountWidth);
  var headerHeight = $(".header").outerHeight(true);
  var sectionHeaderHeight =
    $(".mydeloitte-header").outerHeight(true) +
    $(".section-header-bottom").outerHeight(true);
  if ($(this).scrollTop() > headerHeight + sectionHeaderHeight) {
    $(".bookmarks-count")
      .addClass("bookmarks-count--fix")
      .css("left", bookmarksPosition / 2);
  } else {
    $(".bookmarks-count").removeClass("bookmarks-count--fix").css("left", "");
  }
}
if ($(".bookmarks-page").length) {
  $(window).on("scroll", function () {
    bookmarksCountPosition();
  });
  $(window).resize(function () {
    bookmarksCountPosition();
  });
}

var aModalIsPresent = false;
if (pagetype === "profile") {
  var profileInterestJson = "";
  var profileTabHeight = 58;
  var navigateToPage;
  /* Code to check if event ID exist and invoke the modal for Dbriefs */
  if (
    sessionStorage.getItem("DbriefErrorMessage") !== null &&
    sessionStorage.getItem("DeventId") != null
  ) {
    try {
      _satellite.track("dbriefsLoginError");
    } catch (e) {
      
    }
    $("#dbriefModal").modal("show");
    var DbriefErrorMessageID = sessionStorage.getItem("DbriefErrorMessage");
    $(".event-error-msg").html(DbriefErrorMessageID);
    $(".event-error-msg").attr("id", DbriefErrorMessageID);
  }
  sessionStorage.removeItem("DbriefErrorMessage");
  sessionStorage.removeItem("DeventId");

  myDeloitteApp.controller("profileIterestsCtrl", [
    "$scope",
    function ($scope) {
      $scope.content = [];
      $scope.tab = [];
      getSessionResponse().then(function () {
        $scope.getData = function () {
          var langLocle = myDelLocale;
          langLocle = langLocle.replace(/\//g, "_");
          $.ajax({
            async: false,
            global: false,
            url:window.location.href.split(".html")[0]+".deloitte-interestpage.json",
            data: {
              site: langLocle,
            },
            dataType: "json",
            success: function (data) {
              profileInterestJson = data;
            },
            error: function () {
              
            },
          });
          if (
            typeof profileInterestJson !== "undefined" &&
            profileInterestJson !== ""
          ) {
            profileInterestJson = JSON.stringify(profileInterestJson);
          }
          profileInterestJson = JSON.parse(profileInterestJson);
          $scope.content = profileInterestJson;
          $scope.content = $scope.content.content;
        };
        $scope.getData();
        // apply changes
        $scope.$apply();
      });
    },
  ]);

  var isMicrosoftEdgeOrIE = function () {
    var ua = navigator.userAgent;

    /* MSIE used to detect old browsers and Trident used to newer ones*/
    var is_ie =
      ua.indexOf("MSIE ") > -1 ||
      ua.indexOf("Trident/") > -1 ||
      ua.indexOf("Edge/") > -1 ||
      ua.indexOf("Firefox/") > -1;

    return is_ie;
  };

  var displayError = function (obj, emptyE) {
    $(obj).closest(".form-field").find(".bar").addClass("error-field");
    $(obj)
      .closest(".form-field")
      .append("<p class='error-msg'>" + missingmandfielderror + "</p>");
    if (emptyE === false) {
      emptyE = true;

      var brow = isMicrosoftEdgeOrIE();
      if (brow) {
        var htToScroll =
          $(".profile-controls").height() + $("#header").height();

        $("html,body").animate(
          {
            scrollTop: $(obj).offset().top - htToScroll - 40,
          },
          1000
        );
      } else {
        $(obj).focus();
      }
    }
    if ($(obj)[0] === $("#country-config")[0])
      $(obj)
        .closest(".form-field")
        .find("p.error-msg")
        .css("margin-top", "-25px");
    if ($(obj)[0] === $("#zip")[0])
      $(obj)
        .closest(".form-field")
        .find("p.error-msg")
        .css("margin-top", "-25px");
    return emptyE;
  };
  $.urlParam = function (name) {
    var results = new RegExp("[?&]" + name + "=([^&#]*)").exec(
      window.location.href
    );

    if (results) {
      return results[1];
    }
    return 0;
  };
  var intVal;

  $(document).ready(function () {
    intVal = $.urlParam("aoi");
    if (intVal !== 0) {
      var reqid = $("input[value='" + intVal + "']")
        .closest(".tab-pane")
        .attr("id");
      if (window.matchMedia("(min-width:768px)").matches) {
        $(".nav-tabs--vertical.nav-tabs li:first-child a")
          .removeClass("active")
          .removeClass("show");
        $(".tab-content #panel0").removeClass("active").removeClass("show");
        $(".nav-tabs--vertical.nav-tabs")
          .find("a[href='#" + reqid + "']")
          .addClass("active")
          .addClass("show");
        $("input[value='" + intVal + "']")
          .closest(".tab-pane")
          .addClass("active")
          .addClass("show");
      } else {
        $(".tab-content #panel0 h5 a[href='#collapse-0']").addClass(
          "collapsed"
        );
        $(".tab-content #panel0 #collapse-0").removeClass("show");
        $("input[value='" + intVal + "']")
          .closest(".tab-pane")
          .find("a")
          .removeClass("collapsed");
        $("input[value='" + intVal + "']")
          .closest(".card-body")
          .parent()
          .addClass("show");
      }
    }

    $(".container .row .Primary-button.save-button").on(
      "click",
      function (event) {
        var emptyExists = false;
        $(".form-field .bar").removeClass("error-field");
        $(".form-field p.error-msg").remove();
        $("#profile-email-updates p.error-msg").remove();
        if (!$("#firstName").val())
          emptyExists = displayError($("#firstName"), emptyExists);
        if (!$("#lastName").val())
          emptyExists = displayError($("#lastName"), emptyExists);
        if (!$("#email").val())
          emptyExists = displayError($("#email"), emptyExists);
        if (
          $("#country-config").val() === "none" ||
          $("#country-config").val() === "" ||
          $("#country-config").val() == null
        )
          emptyExists = displayError($("#country-config"), emptyExists);
        if (
          $("#profile-email-updates .form-radio input:radio:checked").length <=
          0
        ){
          $("#profile-email-updates .form-radio").append(
            "<p class='error-msg'>This field is required.</p>"
          );
        }
          validateProfileFrequency();
        if (
          $("#profile-email-updates .form-radio input:radio:checked").val() ===
          "true"
        ) {
          if (!$("#profile-professional-info #company-name").val())
            emptyExists = displayError($("#company-name"), emptyExists);
          if (
            $("#industry-config-for-profile").val() === "none" ||
            $("#industry-config-for-profile").val() === "" ||
            $("#industry-config-for-profile").val() == null
          )
            emptyExists = displayError(
              $("#industry-config-for-profile"),
              emptyExists
            );
          if (!$("#profile-professional-info #job-title").val())
            emptyExists = displayError($("#job-title"), emptyExists);
          if (
            $("#job-function-in-professional").val() === "none" ||
            $("#job-function-in-professional").val() === "" ||
            $("#job-function-in-professional").val() == null
          )
            emptyExists = displayError(
              $("#job-function-in-professional"),
              emptyExists
            );
          // below function is for profile frequency validation for different screens
          validateProfileFrequency();
          if ($(".error-msg").length > 0) {
            event.preventDefault();
            $("body").addClass("modal-open");
            try {
              _satellite.track("profileIncomplete");
            } catch (err) {
              
            }
            $("#modal-email-yes-profile").modal("show");
          }
        }
        if ($(".error-msg").length <= 0) {
          sendAccountDetailsToGigya();
        }
      }
    );

    $(".profile-controls .profile-tabs a").each(function () {
      $(this).css("height", profileTabHeight);
    });
    $('.alumni-check input[type="checkbox"]').on("click", function () {
      if ($(this).is(":checked")) {
        $(".alumni-group").addClass("active");
      } else {
        $(".alumni-group").removeClass("active");
      }
    });
    $('.select-all-interests input[type="checkbox"]').on("click", function () {
      if ($(this).is(":checked")) {
        $(this)
          .closest(".select-all-interests")
          .siblings()
          .each(function () {
            $(this).find("input[type='checkbox']").prop("checked", true);
          });
      } else {
        $(this)
          .closest(".select-all-interests")
          .siblings()
          .each(function () {
            $(this).find("input[type='checkbox']").prop("checked", false);
          });
      }
    });
    $(".card-body input:not(.select-all-checkbox)").on("click", function () {
      if (
        !$(this).is(":checked") &&
        $(this)
          .closest(".card-body")
          .find(".select-all-checkbox")
          .is(":checked")
      ) {
        $(this)
          .closest(".card-body")
          .find(".select-all-checkbox")
          .prop("checked", false);
      }
      var noOfOptions =
        $(this).closest(".card-body").find('input[type="checkbox"]').length - 1;
      var i = noOfOptions;
      $(this)
        .closest(".card-body")
        .find("input:not(.select-all-checkbox)")
        .each(function () {
          if ($(this).is(":checked")) {
            i = i - 1;
          }
        });
      if (i === 0) {
        $(this)
          .closest(".card-body")
          .find(".select-all-checkbox")
          .prop("checked", true);
      }
    });
    $('.profile-controls a[href^="#"]').click(function () {
      var htToScroll =
        $(this.hash).position().top +
        $(".profile-controls").height() +
        $("#header").height();
      $("html,body").animate(
        {
          scrollTop: htToScroll,
        },
        1000
      );
      return false;
    });

    stayOnPage = function () {
      aModalIsPresent = false;
      $("body").removeClass("modal-open");
      $("#modal-unsaved-profile").modal("hide");
      $("#modal-email-yes-profile").modal("hide");
      $("#modal-required-feilds-profile").modal("hide");
    };

    leaveThePage = function () {
      aModalIsPresent = false;
      try {
        if (navigateToPage.indexOf("www") >= 0) {
          window.location.href = navigateToPage;
        } else {
          location.pathname = navigateToPage;
        }
      } catch (err) {
        logOut();
      }
    };

    $("button.close").on("click", function () {
      stayOnPage();
    });

    $(
      "a:not(a[href^='#']):not(a[class='profile__pic']):not(a[id='profile-initials'])"
    ).on("click", function (event) {
      var isChanged = false;
      var emptyExists = false;
      $(".form-field .bar").removeClass("error-field");
      $(".form-field p.error-msg").remove();
      $("#profile-email-updates p.error-msg").remove();
      if (!$("#firstName").val())
        emptyExists = displayError($("#firstName"), emptyExists);
      if (!$("#lastName").val())
        emptyExists = displayError($("#lastName"), emptyExists);
      if (!$("#email").val())
        emptyExists = displayError($("#email"), emptyExists);
      if (
        $("#country-config").val() === "none" ||
        $("#country-config").val() === "" ||
        $("#country-config").val() == null
      )
        emptyExists = displayError($("#country-config"), emptyExists);
      if (
        $("#profile-email-updates .form-radio input:radio:checked").length <= 0
      ) {
        $("#profile-email-updates .form-radio").append(
          "<p class='error-msg'>This field is required.</p>"
        );
        emptyExists = displayError($("#profile-email-updates"), emptyExists);
      }
      if (
        typeof $(this).attr("target") !== "undefined" &&
        $(this).attr("target").indexOf("_blank") >= 0
      ) {
        isChanged = false;
      } else {
        navigateToPage = $(this).attr("href");
        $(':input:not(":checkbox")').each(function () {
          if ($(this).data("initialValue") !== $(this).val()) {
            isChanged = true;
          }
        });
        $(":checkbox").each(function () {
          if ($(this).data("initialValue") !== $(this).is(":checked")) {
            isChanged = true;
          }
        });
        if (
          $("#profile-email-updates .form-radio input:radio:checked").length > 0 &&
          $("#profile-email-updates .form-radio input:radio:checked").val() !== initialRadio
          ) {
            isChanged = true;
          
        }
        var len = 0;
        $(".tab-content .tab-pane").each(function () {
          len = len + $(this).find("div.optin-checked").length;
        });
        if (len > 0) {
          isChanged = true;
        }
      }
      if (!$(this).hasClass("signout_button")) {
        if (emptyExists === true) {
          event.preventDefault();

          $("#modal-required-feilds-profile").modal("show");
          aModalIsPresent = true;
        } else if (isChanged === true) {
          event.preventDefault();
          aModalIsPresent = true;
          $("#modal-unsaved-profile").modal("show");
        }
      }
      if ($(this).hasClass("signout_button") && isChanged === true) {
          event.preventDefault();
          aModalIsPresent = true;
          $("#modal-unsaved-profile").modal("show");
        
      }
    });

    if (matchMedia("(max-width: 767px)").matches) {
      $(".profile-controls a.profile-step").each(function () {
        var ctrlText = $(this).find("span:nth-child(2)").text();
        if (ctrlText.indexOf("5") < 0)
          $(this)
            .find("span:nth-child(2)")
            .text(ctrlText + "/4");
      });
      $(":input:not(':checkbox')").change(function () {
        var changeDone = false;
        if ($(this).data("initialValue") !== $(this).val()) {
          $(this).data("flag", true);
        } else {
          $(this).data("flag", false);
        }
        $(":input").each(function () {
          if ($(this).data("flag") === true) {
            changeDone = true;
          }
        });
        if (changeDone) {
          $(".container .row .Primary-button.save-button").css({
            background: "#0076A8",
            "border-color": "#0076A8",
          });
        } else {
          $(".container .row .Primary-button.save-button").css({
            background: "gray",
            "border-color": "gray",
          });
        }
      });

      $(":checkbox").change(function () {
        var changeDone = false;
        if ($(this).data("initialValue") !== $(this).is(":checked")) {
          $(this).data("flag", true);
        } else {
          $(this).data("flag", false);
        }
        $(":checkbox").each(function () {
          if ($(this).data("flag") === true) {
            changeDone = true;
          }
        });
        if (changeDone) {
          $(".container .row .Primary-button.save-button").css({
            background: "#0076A8",
            "border-color": "#0076A8",
          });
        } else {
          $(".container .row .Primary-button.save-button").css({
            background: "gray",
            "border-color": "gray",
          });
        }
      });
    }

    if (
      window.matchMedia(
        "(min-width: 768px) and (max-width: 1024px) and (orientation: portrait)"
      ).matches
    ) {
      $(".profile-controls").css("height", 83);
      $(".profile-controls .sectionInfo .profile-step").css("height", 81);
      $(".profile-controls .sectionInfo .icon-myDeloitte-circle").css(
        "top",
        60
      );
    }
    if (
      window.matchMedia("(min-width: 768px) and (max-width: 1024px)").matches
    ) {
      $("#profile-about .sectionInfo").css({
        width: "100%",
      });
      $("#profile-professional-info .sectionInfo").css({
        width: "100%",
      });
    }
  });
  $(window).on("scroll", function () {
    if ($("#profile-page").length > 0) {
      var profileAboutSectionTop = $("#profile-about").position().top;
      var profileProfessionalSectionTop = $(
        "#profile-professional-info"
      ).position().top;
      var profileInterestSectionTop = $("#profile-interest").position().top;
      var profileEmailSectionTop = $("#profile-email-updates").position().top;

      var profileAboutSection =
        profileAboutSectionTop + $("#profile-about").outerHeight();
      var profileProfessionalSection =
        profileProfessionalSectionTop +
        $("#profile-professional-info").outerHeight();
      var profileInterestSection =
        profileInterestSectionTop + $("#profile-interest").outerHeight();
      var profileEmailSection =
        profileEmailSectionTop + $("#profile-email-updates").outerHeight();

      var myDHeader = $(".mydeloitte-header").outerHeight(true);
      var headerBottom = $(".profile-page-header__bottom").outerHeight(true);
      var totHeaderHeight = myDHeader + headerBottom;

      var headerHeight = $("#header").outerHeight(true);
      var profileHeaderHeight = $(".mydeloitte-header").outerHeight(true);
      var profileBar = $("#profile-page-header__bottom").outerHeight(true);
      var heightAboveTabs = profileHeaderHeight + profileBar;
      if (matchMedia("(min-width: 768px)").matches) {
        var heightScrolled = $(window).scrollTop();
        if (heightScrolled > heightAboveTabs) {
          $(".profile-controls").css({
            position: "fixed",
            top: headerHeight,
            width: "100%",
            "z-index": "199",
          });
        } else {
          $(".profile-controls").css({
            position: "static",
          });
        }

        if (heightScrolled > profileAboutSection && heightScrolled > 0) {
          $('.profile-controls a[href="#profile-about"]').addClass(
            "tab-active-style"
          );
          if (
            $("#profile-about #firstName").val() !== "" &&
            $("#profile-about #lastName").val() !== "" &&
            $("#profile-about #email").val() !== "" &&
            $("#profile-about #country-config").val() !== ""
          );
        } else {
          $('.profile-controls a[href="#profile-about"]').removeClass(
            "tab-active-style"
          );
        }
        if (heightScrolled > profileProfessionalSection && heightScrolled > 0) {
          $('.profile-controls a[href="#profile-professional-info"]').addClass(
            "tab-active-style"
          );
        
        } else {
          $(
            '.profile-controls a[href="#profile-professional-info"]'
          ).removeClass("tab-active-style");
        }
        if (heightScrolled > profileInterestSection && heightScrolled > 0) {
          $('.profile-controls a[href="#profile-interest"]').addClass(
            "tab-active-style"
          );
        } else {
          $('.profile-controls a[href="#profile-interest"]').removeClass(
            "tab-active-style"
          );
        }
        if (heightScrolled > profileEmailSection && heightScrolled > 0) {
          $('.profile-controls a[href="#profileEmailSection"]').addClass(
            "tab-active-style"
          );
        } else {
          $('.profile-controls a[href="#profileEmailSection"]').removeClass(
            "tab-active-style"
          );
        }

        if (
          $(window).scrollTop() + $(window).height() >=
            $(document).height() - 50 &&
          $(window).scrollTop() > 0
        ) {
          $('.profile-controls a[href="#profile-interest"]').addClass(
            "tab-active-style"
          );
          $('.profile-controls a[href="#profile-email-updates"]').addClass(
            "tab-active-style"
          );
        } else {
          $('.profile-controls a[href="#profile-email-updates"]').removeClass(
            "tab-active-style"
          );
        }
      } else {
        heightScrolled = $(window).scrollTop();
        
        var headerHtMobile = $("#header").outerHeight(true);
        if (heightScrolled > totHeaderHeight) {
          $(".profile-controls").addClass("tab-active-mobile");
          $(
            '.profile-controls a[href="#profile-professional-info"]'
          ).removeClass("tab-active-mobile");
          $('.profile-controls a[href="#profile-about"]').addClass(
            "tab-active-mobile"
          );
          $(".profile-controls").css({
            position: "fixed",
            top: headerHtMobile,
            width: "100%",
            "z-index": "199",
          });
          $(".container .row .Primary-button.save-button").css({
            position: "fixed",
            bottom: 0,
            margin: 0,
            "margin-left": -15,
            width: "100%",
            "z-index": "199",
          });
          if (window.matchMedia("(orientation:landscape)").matches)
            $(".container .row .Primary-button.save-button").css({
              "margin-left": "-5.6em",
            });
        } else {
          $('.profile-controls a[href="#profile-about"]').removeClass(
            "tab-active-mobile"
          );
          $(".profile-controls").removeClass("tab-active-mobile");
          $(".profile-controls").css({
            position: "static",
          });
          $(".container .row .Primary-button.save-button").css({
            position: "static",
          });
        }
        if (heightScrolled > totHeaderHeight + profileProfessionalSectionTop) {
          $('.profile-controls a[href="#profile-about"]').removeClass(
            "tab-active-mobile"
          );
          $('.profile-controls a[href="#profile-interest"]').removeClass(
            "tab-active-mobile"
          );
          $('.profile-controls a[href="#profile-professional-info"]').addClass(
            "tab-active-mobile"
          );
         
        } else {
          $(
            '.profile-controls a[href="#profile-professional-info"]'
          ).removeClass("tab-active-mobile");
        }
        if (heightScrolled > totHeaderHeight + profileInterestSectionTop) {
          $(
            '.profile-controls a[href="#profile-professional-info"]'
          ).removeClass("tab-active-mobile");
          $('.profile-controls a[href="#profile-email-updates"]').removeClass(
            "tab-active-mobile"
          );
          $('.profile-controls a[href="#profile-interest"]').addClass(
            "tab-active-mobile"
          );
         
        } else {
          $('.profile-controls a[href="#profile-interest"]').removeClass(
            "tab-active-mobile"
          );
        }
        if (heightScrolled > totHeaderHeight + profileInterestSection) {
          $('.profile-controls a[href="#profile-interest"]').removeClass(
            "tab-active-mobile"
          );
          $('.profile-controls a[href="#profile-email-updates"]').addClass(
            "tab-active-mobile"
          );
         
          $(".container .row .Primary-button.save-button").css({
            position: "static",
            margin: "2em",
            "margin-right": "0",
            "margin-left": "-15px",
            width: $("#profile-page").outerWidth(),
          });
          if (window.matchMedia("(orientation:landscape)").matches)
            $(".container .row .Primary-button.save-button").css({
              "margin-left": "-5.6em",
              "margin-right": "0px",
              width: "131%",
            });
          $(".container .row .Primary-button.save-button").addClass(
            "continue-button"
          );
        } else {
          $('.profile-controls a[href="#profile-email-updates"]').removeClass(
            "tab-active-mobile"
          );
          $(".container .row .Primary-button.save-button").removeClass(
            "continue-button"
          );
        }
      }
    }
  });
  $(window).load(function () {
    if (intVal != 0) {
      $("html, body").animate(
        {
          scrollTop: $("#profile-interest").offset().top,
        },
        1000
      );
    }
    // The following code snippet is fix for 228775 @mahchinta
    var aoiKeyVal = localStorage.getItem("aoiKey");
    if (aoiKeyVal !== null) {
      $("html, body").animate(
        {
          scrollTop:
            $("#profile-professional-info").offset().top +
            $("#profile-professional-info").height() -
            $("#header").outerHeight(true) -
            $(".profile-controls").outerHeight(true),
        },
        1000
      );
      setFocusToTab();
      if (localStorage.getItem("nocheck") === "true") {
        localStorage.removeItem("aoiKey");
        localStorage.removeItem("nocheck");
      }
    }
  });
}

var initialRadio;
var resObj;
var globalSelectListJson = JSON.parse(
  sessionStorage.getItem("globalSelectListJson")
);
function initialValuesOnForm() {
  $(':input:not(":checkbox")').each(function () {
    $(this).data("initialValue", $(this).val());
  });
  $(":checkbox").each(function () {
    $(this).data("initialValue", $(this).is(":checked"));
  });
  if ($("#profile-email-updates .form-radio input:radio:checked").length > 0) {
    initialRadio = $(
      "#profile-email-updates .form-radio input:radio:checked"
    ).val();
  } else {
    initialRadio = "none";
  }
}
/* Code for display the data of profile in personal & professional details sections starts */
function displayDataProfilePage(MY_PROFILE) {
  resObj = MY_PROFILE;
  if (
    typeof MY_PROFILE.data.myDeloitte.country !== "undefined" &&
    $("#country-config")
  ) {
    $("#country-config").val(MY_PROFILE.data.myDeloitte.country);
  } else {
    if (MY_PROFILE.profile.country !== undefined && $("#country-config")) {
      // This field value will be populated from a method displayDataProfilePage() of genericlist dropdwon servlet
      $("#country-config").val(
        populateCountryNameForSocialLogIn()
      );
    }
  }
  if (typeof MY_PROFILE.profile.firstName !== "undefined" && $("#firstName")) {
    $("#firstName").val(MY_PROFILE.profile.firstName);
  }
  if (typeof MY_PROFILE.profile.lastName !== "undefined" && $("#lastName")) {
    $("#lastName").val(MY_PROFILE.profile.lastName);
  }
  if (typeof MY_PROFILE.profile.email !== "undefined" && $("#email")) {
    $("#email").val(MY_PROFILE.profile.email);
  }
  if (
    typeof MY_PROFILE.data.myDeloitte.businessEmail !== "undefined" &&
    $("#business-email")
  ) {
    $("#business-email").val(MY_PROFILE.data.myDeloitte.businessEmail);
  }
  if (typeof MY_PROFILE.data.myDeloitte.zip !== "undefined" && $("#zip")) {
    $("#zip").val(MY_PROFILE.data.myDeloitte.zip);
  }
  if (
    typeof MY_PROFILE.data.myDeloitte.alumni !== "undefined" &&
    $("#deloitteAlumni")
  ) {
    var isSelected = MY_PROFILE.data.myDeloitte.alumni.selected;
    if (isSelected === true) {
      $("#deloitteAlumni").attr("checked", true);
      $("#alumniRow1").show();
      $("#alumniRow2").show();
      $("#alumniRow3").show();
    }
    if (typeof MY_PROFILE.data.myDeloitte.alumni.function !== "undefined") {
      $("#job-function-in-alumni").val(
        MY_PROFILE.data.myDeloitte.alumni.function
      );
    }
    if (typeof MY_PROFILE.data.myDeloitte.alumni.mf !== "undefined") {
      $("#mf-config-profile").val(MY_PROFILE.data.myDeloitte.alumni.mf);
    }
    if (typeof MY_PROFILE.data.myDeloitte.alumni.year !== "undefined") {
      $("#year-separated").val(MY_PROFILE.data.myDeloitte.alumni.year);
    }
  }
  if (
    typeof MY_PROFILE.data.myDeloitte.industry !== "undefined" &&
    $("#industry-config-for-profile")
  ) {
    $("#industry-config-for-profile").val(MY_PROFILE.data.myDeloitte.industry);
  }
  if (
    typeof MY_PROFILE.data.myDeloitte.company !== "undefined" &&
    $("#company-name")
  ) {
    $("#company-name").val(MY_PROFILE.data.myDeloitte.company);
  }
  if (
    typeof MY_PROFILE.data.myDeloitte.company === "undefined" &&
    $("#company-name")
  ) {
    if (
      typeof MY_PROFILE.profile.work !== "undefined" &&
      typeof MY_PROFILE.profile.work[0].company !== "undefined"
    ) {
      $("#company-name").val(MY_PROFILE.profile.work[0].company);
    }
  }
  if (
    typeof MY_PROFILE.data.myDeloitte.jobTitle !== "undefined" &&
    $("#job-title")
  ) {
    $("#job-title").val(MY_PROFILE.data.myDeloitte.jobTitle);
  }
  if (
    typeof MY_PROFILE.data.myDeloitte.jobTitle === "undefined" &&
    $("#job-title")
  ) {
    if (
      MY_PROFILE.profile.work !== undefined &&
      MY_PROFILE.profile.work[0].title !== undefined
    ) {
      $("#job-title").val(MY_PROFILE.profile.work[0].title);
    }
  }
  if (
    typeof MY_PROFILE.data.myDeloitte.function !== "undefined" &&
    $("#job-function-in-professional")
  ) {
    $("#job-function-in-professional").val(MY_PROFILE.data.myDeloitte.function);
  }
  if (
    typeof MY_PROFILE.data.myDeloitte.level !== "undefined" &&
    $("#current-level-config")
  ) {
    $("#current-level-config").val(MY_PROFILE.data.myDeloitte.level);
  }
  var keyArray = [];
  if (typeof MY_PROFILE.data.myDeloitte.sites !== "undefined") {
    keyArray = getInterestsAndSubscriptions(MY_PROFILE, "interests");
    if (typeof keyArray !== "undefined" && keyArray.length > 0) {
      var keyValue = keyArray;
      $.each($("input[name='profile-interests']"), function () {
        var attrib = $(this).attr("value");
        if (keyValue.length > 0) {
          for (var x = 0; x < keyValue.length; x++) {
            if (keyValue[x] === attrib) {
              $(this).attr("checked", "checked");
            }
          }
        }
      });
    }
  }
  var aoiOptSInKey = localStorage.getItem("aoiKey");
  var aoiOptSInKeyArray = [];
  if (
    typeof aoiOptSInKey !== "undefined" &&
    localStorage.getItem("nocheck") !== "true"
  ) {
    aoiOptSInKeyArray = aoiOptSInKey;
    if (
      typeof aoiOptSInKeyArray !== "undefined" &&
      aoiOptSInKeyArray !== null
    ) {
      var aoiOptsInKeyValue = aoiOptSInKeyArray.split("+");
      $.each($("input[name='profile-interests']"), function () {
        var attribute = $(this).attr("value");
        if (aoiOptsInKeyValue) {
          for (var x = 0; x < aoiOptsInKeyValue.length; x++) {
            if (aoiOptsInKeyValue[x] == attribute) {
              $(this)
                .parents(".checkbox")
                .parent()
                .addClass("optin-checked")
                .addClass("optin-origin");
              $(this).attr("checked", "checked");
            }
          }
        }
      });
    }
  }
  if (typeof MY_PROFILE.data.myDeloitte.consent !== "undefined") {
    if (typeof MY_PROFILE.data.myDeloitte.consent.profile !== "undefined") {
      var isSelectedForEmailUpdates =
        MY_PROFILE.data.myDeloitte.consent.profile;
      if (isSelectedForEmailUpdates === true && $("#emails-yes")) {
        $("#emails-yes").attr("checked", true);
        $("#gated-emails-yes").attr("checked", true);
      } else {
        if ($("#emails-no")) {
          $("#emails-no").attr("checked", true);
          $("#gated-emails-no").attr("checked", true);
        }
      }
      if(pagetype === "profile" || pagetype === "progressiveprofile"){
        toggleProfileFrequencyDisplay();
      }      
    }
    if(MY_PROFILE.data.myDeloitte.consent.profileFreq)
    $("input:radio[name='myDeloitte.consent.profileFreq'][value="+MY_PROFILE.data.myDeloitte.consent.profileFreq+"]").attr('checked',true);
  }
  // moving out since first time user will not have these values
  if(pagetype === "optininterests"){
    toggleGatedProfileFrequencyDisplay();
  }

  initialValuesOnForm();
}
/* Code for display the data of profile in personal & professional details sections ends */
// loads the mf names for profile page fields Country & Memberfirm dropdown options.
function loadMemeberfirms() {
  var countryOption = "";
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  var countryJson =
    globalSelectListJson["myd-generic-list"][
      "country-config-for-personal-info-section"
    ];
  if (countryJson) {
    for (var i = 0; i < countryJson.length; i++) {
      countryOption +=
        "<option value='" +
        countryJson[i]["value"] +
        "'>" +
        countryJson[i]["text"] +
        "</option>";
    }
  }

  $("select[name='countryName']").html(countryOption);
  $("select[name='profile.country']").html(countryOption);
}
/* Loading dropdown values for job function field in profile page starts */
function loadJobFunctions() {
  var functionOptionAsString = "";
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  var jobFunctionJson =
    globalSelectListJson["myd-generic-list"]["job-function-in-profile-page"];
  if (jobFunctionJson) {
    for (var i = 0; i < jobFunctionJson.length; i++) {
      functionOptionAsString +=
        "<option value='" +
        jobFunctionJson[i]["value"] +
        "'>" +
        jobFunctionJson[i]["text"] +
        "</option>";
    }
  }
  $("select[name='job-function-in-professional']").append(
    functionOptionAsString
  );
  $("select[name='data.myDeloitte.function']").append(functionOptionAsString);
  if($("select[name='myDeloitte.function']")[0] && !$("select[name='myDeloitte.function']")[0][0]){
    $("select[name='myDeloitte.function']").append(functionOptionAsString);}
}
/* Loading dropdown values for job function field in profile page ends */
/* Loading dropdown values for year separated field in profile page starts */
function loadYearSeparated() {
  
  var yearOptionAsString = "";
  var min = new Date().getFullYear();
  var max = min;
  min = min - 68;  
  if (max) {
  yearOptionAsString += "<option value=''>Select year</option>";
    for (var i = min; i <= max; i++) {
        yearOptionAsString += "<option value='" + i + "'>" + i + "</option>";
    }
  }
  $("select[name='yearSeparated']").html(yearOptionAsString);
}
/* Loading dropdown values for year separated field in profile page ends */
/* Loading dropdown values for industry field for profile page starts*/
function loadIndustryForProfile() {
  var industryOptionAsString = "";
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  var industryJson =
    globalSelectListJson["myd-generic-list"]["industry-config-for-profile"];
  if (industryJson) {
    for (var i = 0; i < industryJson.length; i++) {
      industryOptionAsString +=
        "<option value='" +
        industryJson[i]["value"] +
        "'>" +
        industryJson[i]["text"] +
        "</option>";
    }
  }
  if($("select[name='industry-config-for-profile']")[0] && !$("select[name='industry-config-for-profile']")[0][0]){
  $("select[name='industry-config-for-profile']").append(
    industryOptionAsString
  );};
  $("select[name='data.myDeloitte.industry']").append(industryOptionAsString);
  $("select[name='myDeloitte.industry']").append(industryOptionAsString);
}
/* Loading dropdown values for industry field for profile page ends*/
/* Loads dropdown values for current job level field in profile page starts*/
function loadCurrentJobLevelForProfile() {
  var currentJobOptionAsString = "";
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  var currentJobLevelJson =
    globalSelectListJson["myd-generic-list"]["current-level-config"];
  if (currentJobLevelJson) {
    for (var i = 0; i < currentJobLevelJson.length; i++) {
      currentJobOptionAsString +=
        "<option value='" +
        currentJobLevelJson[i]["value"] +
        "'>" +
        currentJobLevelJson[i]["text"] +
        "</option>";
    }
  }
  $("select[name='current-level-config']").append(currentJobOptionAsString);
  $("select[name='data.myDeloitte.level']").append(currentJobOptionAsString);
  $("select[name='myDeloitte.level']").append(currentJobOptionAsString);
}
/* Loads dropdown values for current job level field in profile page ends*/
var isReceiveEmails;

/*Saving profile data info in gigya starts*/
function sendAccountDetailsToGigya() {
  var securedlocInfo = getCookie("myD_siteSelector");
  var source = null;
  var profileFrequency = $("input[type='radio'][name='myDeloitte.consent.profileFreq']:checked").val();
  var today = new Date();
  var dd = today.getDate();
  var mm = today.getMonth() + 1; //January is 0!
  var yyyy = today.getFullYear();
  var hour = today.getHours();
  var minu = today.getMinutes();

  if (dd < 10) {
    dd = "0" + dd;
  }
  if (mm < 10) {
    mm = "0" + mm;
  }
  today = yyyy + "-" + mm + "-" + dd + "  " + hour + ":" + minu;
  var dunsnumber = "999999999";
  if (securedlocInfo === "us-en") {
    source = "D&B";
  } else {
    source = "DB";
  }
  if (
    $("#profile-about #firstName").val() !== "" &&
    $("#profile-about #lastName").val() !== "" &&
    $("#profile-about #email").val() !== "" &&
    $("#profile-about #country-config").val() !== "" &&
    $("#profile-about #country-config").val() !== "none" &&
    $("#profile-email-updates .form-radio input:radio:checked").length > 0
  ) {
    var keys = [];
    $.each($("input[name='profile-interests']:checked"), function () {
      keys.push($(this).val().replace(/["']/g, ""));
    });
    var str = JSON.stringify(keys);
    var interestIds = str.split(",");
    if ($("#emails-yes").is(":checked")) {
      isReceiveEmails = true;
    }
    if ($("#emails-no").is(":checked")) {
      isReceiveEmails = false;
    }
    var emailUpdates = "[";

    var emailupdatessub = sessionStorage.getItem("emailupdates");
    if (emailupdatessub != null) {
      var len = emailupdatessub.split(",");
      for (var i = 0; i < len.length; i++) {
        emailUpdates =
          emailUpdates +
          '{"date":"' +
          today +
          '","id":"' +
          len[i] +
          '","selected":"true"},';
      }
      emailUpdates = emailUpdates + "]";
    } else {
      emailUpdates = "[]";
    }

    // Concat subscriptions also to prevent overriden in sites array
    var subscriptionArray = [];

    if (resObj !== undefined && resObj.data.myDeloitte.sites !== undefined) {
      subscriptionArray = getInterestsAndSubscriptions(resObj, "subscriptions");
    }
    var subStr = JSON.stringify(subscriptionArray);
    var subIds = subStr.split(",");
    var sitesJson =
      '"myDeloitte.sites": ' +
      '[{"site": ' +
      site +
      ', "interests" : ' +
      interestIds +
      ', "subscriptions" : ' +
      subIds +
      ',"consents" : ' +
      emailUpdates +
      "}]";

    // Save the profile page input values in localStorage
    if (
      resObj !== null &&
      resObj.data.myDeloitte !== undefined &&
      resObj.profile !== undefined
    ) {
      resObj.profile.firstName = $("#firstName").val();
      resObj.profile.lastName = $("#lastName").val();
      resObj.profile.email = $("#email").val();

      if (resObj.data.myDeloitte.alumni === undefined) {
        resObj.data.myDeloitte.alumni = {};
      }
      if (localStorage.getItem("DUNSNUMBER") != null) {
        dunsnumber = localStorage.getItem("DUNSNUMBER");
        localStorage.removeItem("DUNSNUMBER");
      } else if (
        typeof resObj.data.myDeloitte.companyId != "undefined" &&
        resObj.data.myDeloitte.companyId != null
      ) {
        if (resObj.data.myDeloitte.company === $("#company-name").val()) {
          dunsnumber = resObj.data.myDeloitte.companyId;
        }
      }
      if ($.trim($("#company-name").val()).length === 0) {
        dunsnumber = "";
        resObj.data.myDeloitte.company = $.trim($("#company-name").val());
      } else {
        resObj.data.myDeloitte.company = $("#company-name").val();
      }

      //Alumni details
      resObj.data.myDeloitte.alumni.year =
        $("#year-separated").val() === undefined
          ? ""
          : $("#year-separated").val();
      resObj.data.myDeloitte.alumni.mf =
        $("#mf-config-profile").val() === undefined
          ? ""
          : $("#mf-config-profile").val();
      resObj.data.myDeloitte.alumni.selected = isAlumniSelected;
      resObj.data.myDeloitte.alumni.function =
        $("#job-function-in-alumni").val() === undefined
          ? ""
          : $("#job-function-in-alumni").val();
      //Professional Details
      resObj.data.myDeloitte.country = $("#country-config").val();
      resObj.data.myDeloitte.zip = $("#zip").val();
      resObj.data.myDeloitte.industry =
        $("#industry-config-for-profile").val() === undefined
          ? ""
          : $("#industry-config-for-profile").val();
      resObj.data.myDeloitte.level =
        $("#current-level-config").val() === undefined
          ? ""
          : $("#current-level-config").val();

      resObj.data.myDeloitte.jobTitle =
        $("#job-title").val() === undefined ? "" : $("#job-title").val();
      resObj.data.myDeloitte.function =
        $("#job-function-in-professional").val() === undefined
          ? ""
          : $("#job-function-in-professional").val();
      resObj.data.myDeloitte.companyId = dunsnumber;
      resObj.data.myDeloitte.companySource = source;
      if (resObj.data.myDeloitte.consent === undefined) {
        resObj.data.myDeloitte.consent = {};
      }
      resObj.data.myDeloitte.consent.profileFreq = (isReceiveEmails === true && profileFrequency) ? profileFrequency: '';	
      resObj.data.myDeloitte.consent.profile = isReceiveEmails;
      if (resObj.data.myDeloitte.sites === undefined) {
        resObj.data.myDeloitte.sites = [];
      }
      resObj.data.myDeloitte.sites = [
        {
          site: JSON.parse(site),
          interests: JSON.parse(interestIds),
          subscriptions: JSON.parse(subIds),
        },
      ];
    }
    var profileInfo =
      "{" +
      '"firstName" : "' +
      resObj.profile.firstName +
      '" ,' +
      '"lastName" : "' +
      resObj.profile.lastName +
      '" ,' +
      '"email" : "' +
      resObj.profile.email +
      '" }';

    var rpcDate = returnProfileConsentDate(isReceiveEmails);

    var dataInfo =
      "{" +
      '"myDeloitte.country" : "' +
      resObj.data.myDeloitte.country +
      '" ,' +
      '"myDeloitte.zip" : "' +
      resObj.data.myDeloitte.zip +
      '" ,' +
      '"myDeloitte.alumni.year" : "' +
      resObj.data.myDeloitte.alumni.year +
      '",' +
      '"myDeloitte.alumni.mf" : "' +
      resObj.data.myDeloitte.alumni.mf +
      '",' +
      '"myDeloitte.alumni.selected" : ' +
      resObj.data.myDeloitte.alumni.selected +
      "," +
      '"myDeloitte.industry" : "' +
      resObj.data.myDeloitte.industry +
      '",' +
      '"myDeloitte.function" : "' +
      resObj.data.myDeloitte.function +
      '",' +
      '"myDeloitte.level" : "' +
      resObj.data.myDeloitte.level +
      '",' +
      '"myDeloitte.company" : "' +
      resObj.data.myDeloitte.company +
      '",' +
      '"myDeloitte.jobTitle" : "' +
      resObj.data.myDeloitte.jobTitle +
      '",' +
      '"myDeloitte.companyId" : "' +
      resObj.data.myDeloitte.companyId +
      '",' +
      '"myDeloitte.companySource" : "' +
      resObj.data.myDeloitte.companySource +
      '",' +
      '"myDeloitte.consent.profileDate" : ' +
      rpcDate +
      "," +
      '"myDeloitte.consent.profile" : ' +
      isReceiveEmails +
      "," +
      '"myDeloitte.consent.profileFreq" : ' +
      '"' +resObj.data.myDeloitte.consent.profileFreq + '"'+
      "," +
      sitesJson +
      "," +
      // +	'"myDeloitte.sites.consents":'+ emailUpdates+','
      '"myDeloitte.alumni.function" :"' +
      resObj.data.myDeloitte.alumni.function +
      '" }';
    if (
      isReceiveEmails === true &&
      resObj.data.myDeloitte.consent !== undefined &&
      resObj.data.myDeloitte.consent.fullUnsubscribe !== undefined &&
      resObj.data.myDeloitte.consent.fullUnsubscribe === true
    ) {
      resObj.data.myDeloitte.consent.fullUnsubscribe = false;
      dataInfo =
        "{" +
        '"myDeloitte.country" : "' +
        resObj.data.myDeloitte.country +
        '" ,' +
        '"myDeloitte.zip" : "' +
        resObj.data.myDeloitte.zip +
        '" ,' +
        '"myDeloitte.alumni.year" : "' +
        resObj.data.myDeloitte.alumni.year +
        '",' +
        '"myDeloitte.alumni.mf" : "' +
        resObj.data.myDeloitte.alumni.mf +
        '",' +
        '"myDeloitte.alumni.selected" : ' +
        resObj.data.myDeloitte.alumni.selected +
        "," +
        '"myDeloitte.industry" : "' +
        resObj.data.myDeloitte.industry +
        '",' +
        '"myDeloitte.function" : "' +
        resObj.data.myDeloitte.function +
        '",' +
        '"myDeloitte.level" : "' +
        resObj.data.myDeloitte.level +
        '",' +
        '"myDeloitte.company" : "' +
        resObj.data.myDeloitte.company +
        '",' +
        '"myDeloitte.jobTitle" : "' +
        resObj.data.myDeloitte.jobTitle +
        '",' +
        '"myDeloitte.companyId" : "' +
        resObj.data.myDeloitte.companyId +
        '",' +
        '"myDeloitte.companySource" : "' +
        resObj.data.myDeloitte.companySource +
        '",' +
        '"myDeloitte.consent.profileDate" : ' +
        rpcDate +
        "," +
        '"myDeloitte.consent.fullUnsubscribe" : ' +
        false +
        "," +
        '"myDeloitte.consent.profile" : ' +
        isReceiveEmails +
        "," +
        '"myDeloitte.consent.profileFreq" : ' +
        '"' +resObj.data.myDeloitte.consent.profileFreq + '"'+
        "," +
        sitesJson +
        "," +
        //    +	'"myDeloitte.sites.consents":'+ emailUpdates+','
        '"myDeloitte.alumni.function" :"' +
        resObj.data.myDeloitte.alumni.function +
        '" }';
    }

    var params = {
      profile: profileInfo,
      data: dataInfo
        .replace(/&lt;/g, "")
        .replace(/&gt;/g, "")
        .replace(/&#x2F;/g, "/"),
      apiKey: SOCIAL_API,
      UID: SOCIAL_PROFILE_UID,
      callback: setAccountInfoResponse,
    };
    gigya.accounts.setAccountInfo(params);
    // save back to session storage

    // this will redirects the page from profile to subscription page
  }
}
/* Saving profile data info in gigya ends */
/* Getting account info response from gigya starts */
function setAccountInfoResponse(response) {
  if (typeof response.errorCode !== "undefined" && response.errorCode === 0) {
    sessionStorage.removeItem("response");
    sessionStorage.setItem("response", JSON.stringify(resObj));
    if ($(".error-msg").length <= 0) {
      if (
        localStorage.getItem("aoiKey") !== null ||
        localStorage.getItem("isNewUser") !== "true"
      ) {
        var dashboard_page_URL = "./dashboard.html";
        $(location).attr("href", dashboard_page_URL);
      } else {
        var subscription_page_URL = "./subscriptions.html";
        $(location).attr("href", subscription_page_URL);
      }
      localStorage.removeItem("aoiKey");
      localStorage.removeItem("isNewUser");
    }
  }
}
/* Getting account info response from gigya starts */
/* loading the mf names for profile page location field for Alumnioptions starts*/
function loadLocationsForAlumni() {
  var countryOption = "";
  
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  var countryJson =
    globalSelectListJson["myd-generic-list"]["countries-for-alumni"];
  if (countryJson) {
    for (var i = 0; i < countryJson.length; i++) {
      countryOption +=
        "<option value='" +
        countryJson[i]["value"] +
        "'>" +
        countryJson[i]["text"] +
        "</option>";
    }
  }
  $("select[name='memeberfirmName']").html(countryOption);
}
/* loading the mf names for profile page location field for Alumnioptions ends*/
/* code for to populate country field from social share login starts */
function populateCountryNameForSocialLogIn() {
  
  var isocode = null;
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }

  isocode =
    globalSelectListJson["myd-generic-list"]["admin-page-member-firm-config"];
  return isocode;
}
/* code for to populate country field from social share login ends */
/* Loading business field dropdowns for Alumni starts */
function loadJobFunctionForAlumni() {
  var functionOptionAsString = "";
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  var jobFunctionJson =
    globalSelectListJson["myd-generic-list"]["business-list-for-alumni"];
  if (jobFunctionJson) {
    for (var i = 0; i < jobFunctionJson.length; i++) {
      functionOptionAsString +=
        "<option value='" +
        jobFunctionJson[i]["value"] +
        "'>" +
        jobFunctionJson[i]["text"] +
        "</option>";
    }
  }
  if($("select[name='job-function-in-alumni']")[0] && !$("select[name='job-function-in-alumni']")[0][0]){
  $("select[name='job-function-in-alumni']").append(functionOptionAsString);
  };
}
/* Loading business field dropdowns for Alumni ends */

function goToAnchorTag() {
  var aoiKeyVal = localStorage.getItem("aoiKey");
  var hash = window.location.hash;
  if (hash === "" && aoiKeyVal !== null) {
    hash = "#profile-interest";
  }
  if ($("" + hash + "").length) {
    $("html, body").animate(
      {
        scrollTop: $("" + hash + "").offset().top - 350,
      },
      4000
    );
  }
}
function returnProfileConsentDate(isReceiveEmails) {
  var profileConsent;
  var profileConsentDate;
  if (
    sessionStorage.getItem("response") !== undefined ||
    sessionStorage.getItem("response") != null
  ) {
    var response = JSON.parse(sessionStorage.getItem("response"));
    if (
      response.data.myDeloitte.consent !== undefined &&
      response.data.myDeloitte.consent.profile !== undefined
    ) {
      profileConsent = response.data.myDeloitte.consent.profile;
      profileConsentDate = response.data.myDeloitte.consent.profileDate;
    } else {
      profileConsentDate = new Date().toISOString();
    }

    if (profileConsent !== isReceiveEmails.toString()) {
      var event = new Date();
      profileConsentDate = event.toISOString();
      profileConsentDate = '"' + profileConsentDate + '"';
    } else {
      profileConsentDate = '"' + profileConsentDate + '"';
    }
  }
  return profileConsentDate;
}

$(document).ready(function () {
  if (pagetype === "profile") {
    goToAnchorTag();
  }
});

/* Code to check if event ID exist and invoke the modal for Dbriefs */
if(pagetype !== "registration" && pagetype === "dashboard" && !sessionStorage.getItem("response")){
  location.href="./registration.html";
};

if (
  sessionStorage.getItem("DbriefErrorMessage") !== null &&
  sessionStorage.getItem("DeventId") != null
) {
  try {
    _satellite.track("dbriefsLoginError");
  } catch (e) {
  
  }
  $("#dbriefModal").modal("show");
  var DbriefErrorMessageID = sessionStorage.getItem("DbriefErrorMessage");
  $(".event-error-msg").html(DbriefErrorMessageID);
  $(".event-error-msg").attr("id", DbriefErrorMessageID);
}
sessionStorage.removeItem("DbriefErrorMessage");
sessionStorage.removeItem("notConsented");
sessionStorage.removeItem("DeventId");

if(pagetype === "dashboard"){
  // error handling for dbrief quicklink 
  var dbScriptTag = "\nvar dbresponse = JSON.parse(sessionStorage.getItem(\"response\"));\nvar dbEventId = sessionStorage.getItem(\"dbEventId\");\n\nfunction launchEvent() {\n  var dbriefEventId = sessionStorage.getItem(\"dbEventId\");\n  sessionStorage.setItem(\"eventId\", dbriefEventId);\n  if (dbresponse !== null || dbresponse !== undefined) {\n    makeDbriefCall(dbresponse);\n    var redir = sessionStorage.getItem(\"DbriefSuccessMessage\");\n\n    if (redir != null) {\n      window.location.href = redir + \"&partnerref=secondary\";\n    }\n  } else {\n    gigya.accounts.getAccountInfo({\n      callback: gcallback\n    });\n  }\n}\n\nfunction gcallback(resObj) {\n  if (resObj.errorCode == 0) {\n    makeDbriefCall(resObj);\n    var redir = sessionStorage.getItem(\"DbriefSuccessMessage\");\n\n    if (redir != null) {\n      window.location.href = redir + \"&partnerref=secondary\";\n    }\n  }\n}\n";
  var dbriefConfirmModal = '\n<div class="modal fade mydeloitte-modal" id="dbrief-confirm-modal" style="top: 20%;">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n     <button style="width: 40px;right: 0px;position: absolute;" type="button" class="close" data-dismiss="modal" aria-label="Close">\n          <span aria-hidden="true">&times;</span>\n        </button>\n      <div class="modal-body">\n        <h3 class="modal-body__msg">\n          Please confirm your webcast registration.\n        </h3>\n        <button class="Primary-button remove-popup save-button mb-3" align="center" onClick="launchEvent();">Confirm</button>\n\n        <div id="dbrief-msg">\n  <p style="font-size: 12px;"> \n            If you are facing issues, please clear your browser cache and try again </p>\n          <p style="font-size: 12px;"> \n            Need support? Contact <a href="mailto:usdbriefs@deloitte.com">usdbriefs@deloitte.com</a> </p>\n      </div>\n\n      </div>\n    </div>\n  </div>\n  </div>\n';
  var dbriefFallbackTextContainer = '\n<div id="dbrief-quicklink-container"  style="padding: 10px 15px;position: absolute;top: 0.5%;left: 40%;background: #fff;width: 300px;">\n  <div class="container">\n    <div class="row">\n      <div id="dbrief-msg">\n        <div style="font-size: 1.2em;color: #000;display: block;line-height: 1.2em;margin: 10px 0;">\n          <p style="font-size: 1em; margin-top: 10px"> <strong style="font-size: 1.4em;">Trouble accessing webcasts?</strong><br>\n            Please contact <a href="mailto:usdbriefs@deloitte.com">usdbriefs@deloitte.com</a> </p>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n'; // append script to body

  var scriptContainer = document.createElement("script");
  scriptContainer.text = dbScriptTag;
  document.body.appendChild(scriptContainer);

  if (dbEventId !== null) {
    var dbcontainer = document.createElement("div");
    dbcontainer.innerHTML = dbriefConfirmModal;
    document.body.appendChild(dbcontainer);
    if(!sessionStorage.getItem('modalClose')){
    $(".modal").modal('hide');
    $("#dbrief-confirm-modal").modal("show");
    }
    var dbriefFallbackContainer = document.createElement("div");
    dbriefFallbackContainer.innerHTML = dbriefFallbackTextContainer;
    var ele = document.getElementById("header-section");

    if (window.matchMedia("(max-width: 767px)").matches) {
      ele.appendChild(dbriefFallbackContainer);
    } else {
      document.body.appendChild(dbriefFallbackContainer);
    }
  }

  $("#dbrief-confirm-modal").on("hide.bs.modal", function () {
      sessionStorage.setItem("modalClose", true);
  });
  // error handling code ends here
}

// All helper function below for dashboard
function bookmarkDataUpdate() {
  getSessionResponse().then(function (response) {
    if (
      sessionStorage.getItem("response") !== null &&
      (pagetype === "dashboard" || pagetype === "bookmark") &&
      localStorage.getItem("loggedIn") === "true"
    ) {
      savebookmarkCount(response);
    }
  });
}

function savebookmarkCount(response) {
  if (pagetype === "dashboard") {
    var headerHeight = $("#header").outerHeight(true);
    $(".dashboard-header").css({
      position: "fixed",
      top: headerHeight,
      width: "100%",
      "z-index": "100",
    });
    var dashboardHeadersHeight = $(".dashboard-header").outerHeight(true);
    $(".dashboard-sections").css(
      "margin-top",
      headerHeight + dashboardHeadersHeight
    );
  }
  var bookmark_earlier = JSON.parse(sessionStorage.getItem("response"));
  if (response.errorCode === 0) {
    if (typeof response.data.myDeloitte.bookmarks !== "undefined") {
      sessionStorage.removeItem("response");
      sessionStorage.setItem("response", JSON.stringify(response));
      var bookmark_later = response.data.myDeloitte.bookmarks.length;
      if (bookmark_later !== bookmark_earlier.data.myDeloitte.bookmarks.length) {
        window.location.reload();
      }
    }
    if (pagetype === "dashboard") {
      // to show the CCL view
      if (
        response.data.myDeloitte.accountGroupId != null &&
        response.data.myDeloitte.accountGroupId !== "undefined" &&
        response.data.myDeloitte.accountGroupId !== ""
      ) {
        $(".client-view").show();
        $(".client-view").css(
          "margin-top",
          headerHeight + dashboardHeadersHeight
        );
        $(".dashboard-header").addClass("client-dashboard-header");
        angular
          .element($("#client-dashboard"))
          .scope()
          .ClientDashBoard(response);
      } 
    }
  }
}

function subscriptionsCount(response) {
  sessionStorage.removeItem("subscriptionCount");
  sessionStorage.setItem(
    "subscriptionCount",
    getInterestsAndSubscriptions(response, "subscriptions")
  );
}

myDeloitteApp.filter("trusted", function ($sce) {
  return function (html) {
    return $sce.trustAsHtml(html);
  };
});
myDeloitteApp.controller("dashboardCtrl", [
  "$scope",
  function ($scope) {
    /* Calling evalsession if it is null*/
    $scope.bookmarksCount = 0;
    $scope.subscriptionsCount = 0;
    $scope.interestsCount = 0;

    getSessionResponse().then(function (response) {
      // update interest data from recent session storage update
      populateInterestsAndTags(response);

      var interestTopics = localStorage.getItem("profileInterestsForSNP");
      interestTopics = interestTopics.split(',');
      interestTopics = interestTopics.filter(function (entry) {
        return entry.trim() !== "";
      });
      $scope.interestsCount = interestTopics.length;
      if (
        $scope.interestsCount === "" ||
        $scope.interestsCount === "undefined" ||
        $scope.interestsCount === 0
      ) {
        $scope.interestsCount = 0;
        $(".interested-topics-section").hide();
      }

      var bookmarkDetails = response.data.myDeloitte.bookmarks;
      if (!bookmarkDetails || bookmarkDetails.id === " ") {
        $scope.bookmarksCount = 0;
        bookmarkDetails = "";
      } else {
        $scope.bookmarksCount = bookmarkDetails.length;
      }

      // Making call to fetch updated subscription count
      subscriptionsCount(response);
      var subscriptionsIds = sessionStorage.getItem("subscriptionCount");
      if (!subscriptionsIds || subscriptionsIds === " ") {
        $scope.subscriptionsCount = 0;
      } else {
        subscriptionsIds = subscriptionsIds.split(",");
        $scope.subscriptionsCount = subscriptionsIds.length;
      }
      $scope.$apply();

      //#region hide loader and show page  moved from window load
      angular.element("div.skeleton").hide();
      angular.element(".dashboard-page").show();
      //#endregion hide loader and show page ends here
    });
  },
]);
myDeloitteApp.controller("interestsCtrl", [
  "$scope",
  function ($scope) {
    getSessionResponse().then(function () {
      $scope.getRandom = function (arr, n) {
        var result = new Array(n),
          len = arr.length,
          taken = new Array(len);
        if (n > len)
          throw new RangeError("getRandom: more elements taken than available");
        while (n--) {
          var x = randomValue(len);
          result[n] = arr[x in taken ? taken[x] : x];
          taken[x] = --len in taken ? taken[len] : len;
        }
        return result;
      };
      $scope.dashboardTopicFilter = function (dashboardTopic) {
        localStorage.setItem("dashboardTopic", dashboardTopic);
      };
      $scope.showTopics = function () {
        $scope.interestTopics = JSON.parse(
          sessionStorage.getItem("interestsDetails")
        );
        if ($scope.interestTopics) {
          if ($scope.interestTopics.length > 4) {
            $scope.interestRandomTopics = $scope.getRandom(
              $scope.interestTopics,
              4
            );
          } else {
            $scope.interestRandomTopics = $scope.interestTopics;
          }
        }
      };
      $scope.showTopics();

      var interestTopics = localStorage.getItem("profileInterestsForSNP");
      interestTopics = interestTopics.split(',');
      interestTopics = interestTopics.filter(function (entry) {
        return entry.trim() !== "";
      });
      $scope.interestsCount = interestTopics.length;

      if (
        $scope.interestsCount === "" ||
        $scope.interestsCount === "undefined" ||
        $scope.interestsCount === 0
      ) {
        $scope.interestsCount = 0;
        $(".interested-topics-section").hide();
      }
    });
  },
]);
$(window).on("scroll", function () {
  var heightScrolled = $(window).scrollTop();
  if (heightScrolled > 1) {
    $(".dashboard-page .section-header .section-header-content__icon").css(
      "z-index",
      "0"
    );
  } else {
    $(".dashboard-page .section-header .section-header-content__icon").css(
      "z-index",
      "110"
    );
  }
});

myDeloitteApp.controller("clientviewCtrl", [
  "$scope",
  "utilityService",
  "$http",
  function ($scope, utilityService,$http) {
    $scope.ClientDashBoard = function (response) {
     var clientReq = {
        origin: window.location.origin,
        groupid: response.data.myDeloitte.accountGroupId,
        uid: response.UID,
        signature: response.UIDSignature,
        timestamp: response.signatureTimestamp,
     };
      $.ajax({
        url: clientdashboardURL,
        type: "POST",
        crossDomain: true,
        data: JSON.stringify(clientReq),
         headers: {
            "content-type": "application/json",
            "authorization": "Basic "+window.btoa(clientApiUsername+":"+clientApiPassword)
         },
        success: function (data) {
          $scope.clientInfo = data;
          if (typeof data.lcsp !== "undefined") {
            $scope.clientSocialContacts = data.lcsp.socialcontacts;
          }
          try {
            if (typeof data.pages !== "undefined") {
              $scope.pageIds = data.pages;
              $scope.pageIds = $scope.pageIds.join("|");
              $scope.getResults($scope.pageIds);
            } else {
              $(".skeleton-client-view").hide();
              $scope.renderJson();
            }
            $(".dashboard-sections").css("margin-top", 0);
          } catch (err) {
           
          }
        },
        error: function () {
          console.debug("Response failed: Invalid Account Group ID");
          $(".client-view").hide();
          $(".dashboard-header").removeClass("client-dashboard-header");
        },
      });      
    };

    $scope.getResults = function (query) {
      $scope.query = query;
      let pageId = $scope.query;
      const pageIdArray = pageId.split("|");
      var queryURL = window.search_engine + '/template';
      var data =  {
        "id": "mydeloitte-dashboard-client-view-search-template",
        "params": {
            "page-id": pageIdArray,
            "country-code": window.sc_country,
            "country-lang": window.sc_language,
            "from": 0,
            "size": 4
        }
      };

       $http ({ 
        method: 'post', 
            headers : { 
                "Authorization" : "ApiKey "+ window.search_key,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
              }, 
              url: queryURL, 
              data : data ,
              dataType: 'json'
      }).then(
        function (response) {
          if (response !== undefined && response.data["hits"]["hits"].length) {
            var resultSet = response.data["hits"]["hits"].map((val,index) => { 
              return val["_source"];
          });
            var responseData = resultSet;
            if (!$scope.promosdata == "") {
              var newData = responseData;
              for (var j = 0; j < newData.length; j++) {
                $scope.promosdata.push(newData[j]);
              }
            } else {
              $scope.promosdata = responseData;
          }
        }
        $scope.renderJson();
      });
    };

    // US-574965: adding function to get date for curated events
    // function fun(dataExisting) {
    //   return old formatDateTimeFromTicks;

    // }
    $scope.getStartDateForEvents = function (promo) {
      return utilityService.getStartDateForEvents(promo);
    };

    /* function to get formatted date */
    $scope.getPublishedDateFormatted = function (promo) {
      return utilityService.getPublishedDateFormatted(promo);
    };

    // US-574965: adding function to get date for curated events
    $scope.getStartMonthForEvents = function (promo) {
      return utilityService.getStartMonthForEvents(promo);
    };
    $scope.renderJson = function () {
      $scope.clientRecPages = $scope.promosdata;
      $scope.$applyAsync();
      $(".skeleton-client-view").hide();
      $(".client-view-wrapper").show();
      $scope.finished();
    };
    /*Function to trim html tags in descrption*/
    $scope.getDescription = function (promo) {
      return utilityService.getDescription(promo);
    };
    /*Function to get the bookmark date*/
    $scope.getbookmarkDate = function (promo) {
      return utilityService.getbookmarkDate(promo);
    };
    /* Function to bookmark the page*/
    $scope.sendBookmark = function (promoId, $event) {
      utilityService.sendBookmark(promoId, $event);
    };
    /*Function to add the additional class for insights promos*/
    $scope.getPromoClass = function (promo) {
      return utilityService.getPromoClass(promo);
    };
    /*Function to get the promo page url*/
    $scope.getPageURL = function (promoPageURL) {
      return utilityService.getPageURL(promoPageURL);
    };
    /*Function to show the Deloitte Insights text for Deloitte Insights promos*/
    $scope.showText = function () {
      return utilityService.showText();
    };
    /* US 263605: Function to show the Deloitte Insights Logo for Deloitte Insights promos*/
    $scope.showLogo = function () {
      return utilityService.showLogo();
    };
    /* US 263605: Function to get the page type to differntiate Deloitte Insights & Dcom promos*/
    $scope.getPageType = function (promo) {
      return utilityService.getPageType(promo);
    };
    /*Function to get the thumbnail*/
    $scope.getThumbnail = function (promo) {
      return utilityService.getThumbnail(promo);
    };
    /*Function to get the thumbnail*/
    $scope.getIEThumbnail = function (promo) {
      return utilityService.getIEThumbnail(promo);
    };

    /*Function to check if Primary contact exist*/
    $scope.ifPrimaryContact = function (clientInfo) {
      try {
        if (clientInfo.lcsp.name) {
          return true;
        } else {
          return false;
        }
      } catch (err) {}
    };

    /*Function to check if Annoucement exist*/
    $scope.ifAnnoucement = function (clientInfo) {
      try {
        if (clientInfo.announcement) {
          return true;
        } else {
          return false;
        }
      } catch (err) {}
    };

    /*Function to check if Promos exist*/
    $scope.ifRecoPromos = function (clientRecPages) {
      try {
        if (clientRecPages.length > 0) {
          return true;
        } else {
          return false;
        }
      } catch (err) {

      }
    };

    /* Function to fetch Read Bio */
    $scope.getReadBio = function (clientInfo) {
      try {
        if (clientInfo.bioLabel) return clientInfo.bioLabel;
        else return $(".client-view__readbio a").attr("data-read-bio");
      } catch (err) {}
      return "";
    };

    /* Function to fetch Primary Label */
    $scope.getPrimaryLabel = function (clientInfo) {
      try {
        if (clientInfo.contactLabel) return clientInfo.contactLabel;
        else return $(".client-view__label").attr("data-primary-label");
      } catch (err) {}
      return "";
    };

    /* Function to fetch Reco title */
    $scope.getRecoTitle = function (clientInfo) {
      try {
        if (clientInfo.contentHeader) return clientInfo.contentHeader;
        else return $(".client-view__rec-title").attr("data-rec-title");
      } catch (err) {}
      return "";
    };

    /* Function to fetch Reco sub title */
    $scope.getRecoSubTitle = function (clientInfo) {
      try {
        if (clientInfo.contentSubheader) return clientInfo.contentSubheader;
        else return $(".client-view__rec-subtitle").attr("data-rec-subtitle");
      } catch (err) {}
      return "";
    };
    /*Function to get the mobile rendition of thumbnail*/
    $scope.getMobileThumbnail = function (promo) {
      return utilityService.getMobileThumbnail(promo);
    };
    /* Function to call dotdotdot js*/
    $scope.finished = function () {
      if (window.matchMedia("(max-width: 767px)").matches) {
        return;
      }
      customShave(".dot-ellipsis", 70);
    };
  },
]);

function validateEmail(email) {
    var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(String(email).toLowerCase());
}


$(document).ready(function() {
    $("#unsubscribe-modal-button").on("click", function() {
        if (localStorage.getItem("loggedIn") != null) {
        $(location).attr('href', "./dashboard.html");
        } else {
            $(location).attr('href', "./registration.html?state=signin");
        }

      });

    $("#email").focusout(function() {
        var userEmail = $("#email").val();
        if(userEmail !== "undefined" && userEmail !== ''){
            $("#unsubscribe-button").removeAttr("disabled");
           

            if (!validateEmail(userEmail)) {
                 $("#unsubscribe-button").attr('disabled', 'disabled');
                $(".error-text").text(invalidmail);
            }
            else{
                $(".error-text").text("");
            }
        }
        else
            $("#unsubscribe-button").attr('disabled', 'disabled');
     });
})

$(window).load(function() {
    function getUrlVars() {
        var vars = [],
            hash;
        var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');

        for (var i = 0; i < hashes.length; i++) {
            hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = hash[1];
        }

        return vars;
    }

        var hash = getUrlVars();
        var userEmail = hash['email'];
        userEmail = decodeURIComponent(userEmail);
        userEmail = decodeURIComponent(userEmail);
        if(userEmail === '' || userEmail === "undefined"){
            $(".error-text").text("This field is required");
            $("#unsubscribe-button").attr('disabled', 'disabled');
        }

        if(userEmail !== "undefined" && userEmail !== ''){
            $("#email1").val(userEmail);
            $("#unsubscribe-button").removeAttr("disabled");
            
            if (!validateEmail(userEmail)) {
                $(".error-text").text(invalidmail);
            }

        }
});
myDeloitteApp.controller('unsubscribeCtrl', ['$scope', function($scope) {


    if ($.urlParam("success") === "yes") {
        $scope.success = true;
    } else {
        $scope.success = false;
    }

    if ($.urlParam("sub") == "") {
        $scope.unsub = false;
    } else {
        $scope.unsub = true;
    }
    if (pagetype !== 'undefined' && pagetype === 'unsubscribe') {
           var hash = getUrlVars();
           var userEmail = hash['email'];
           var ssiteval = hash['site'];
           ssiteval=decodeURIComponent(ssiteval).replace("-", "_");
          if(ssiteval === "undefined" || ssiteval == ''){
               ssiteval="us_en";
           }
           var subsiteval= "us-en";
           if(ssiteval!=null && ssiteval !== ""){
           subsiteval=ssiteval.replace("_", "-");
           }
           userEmail = decodeURIComponent(userEmail);
           userEmail = decodeURIComponent(userEmail);

        if(userEmail === "undefined" || userEmail === ''){
            $("#unsubscribe-button").attr('disabled', 'disabled');
        }

        if(userEmail !== "undefined" && userEmail !== ''){
            $("#email1").val(userEmail);
            $scope.email = userEmail;
            callajaxtogetsubscriptiondata(hash['sub']);
        }

    }

    function getUrlVars() {
        var vars = [],
            hash;
        var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');

        for (var i = 0; i < hashes.length; i++) {
            hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = hash[1];
        }

        return vars;
    }

    function callajaxtogetsubscriptiondata(subscriptiondata) {

        if (typeof subscriptiondata != 'undefined') {
            $.getJSON({
                async: false,
                global: false,
                url: window.location.href.split(".html")[0]+".deloitte-subscriptionsdata.json",
                data: {
                    "subscriptionkeys": subscriptiondata,
                    "site":ssiteval
                }
            }).then(function(data) {
                    $scope.data = data;
                },
                function() {
                }
            );
        }
    }
    $scope.getSubscriptionIds = function() {
        subIds = []
        for (var key in $scope.data) {
            subid = $scope.data[key]['subscriptionID']
            if ($("#" + subid).is(":checked")) {
                subIds.push(subid)
            }
        }
        return (subIds.join(','));
    }

    var onSuccess = function(data) {
        var url = window.location.href + "&success=yes";
        if (data.isSuccess) {
            $(location).attr('href', url);
        } else {
            $("#checkbox-validataion-msg").hide();
            $("#unsubscribe-validataion-msg").show();
        }

    }

    var onError = function() {
        $("#checkbox-validataion-msg").hide();
        $("#unsubscribe-validataion-msg").show();
    }

    $scope.callBoomi = function() {
        var subids = $scope.getSubscriptionIds();
        var username = $('#email').val();
        var subscriptiondata = null;
        if ($("#unsubscribeall").is(':checked') | $("#" + subid).is(":checked")) {
            if ($("#unsubscribeall").is(':checked')) {
               subscriptiondata = '{' + '"origin":"' + window.location.origin + '","email":"' + username + '","site": "' + subsiteval + '","consent":{"fullUnsubscribe":true,"fullDate":"' + new Date().toISOString() + '","profile": false,"profileDate": "' + new Date().toISOString() + '"}}'; 

            } else if ($("#" + subid).is(":checked")) {
                subscriptiondata = '{' + '"origin":"' + window.location.origin + '","email":"' + username + '","site": "' + subsiteval + '","subscription":{"id":"' + subids + '","checked": false}}';
            }

            $.ajax({
                type: "POST",
                crossDomain: true,
                data: subscriptiondata,
                url: unsubscribeAPIURL,
                headers: {
  				 "content-type": "application/json",
                 "authorization": "Basic "+window.btoa(clientApiUsername+":"+clientApiPassword)
              },
                success: onSuccess,
                error: onError
            });

        } else {
            $("#unsubscribe-validataion-msg").hide();
            $("#checkbox-validataion-msg").show();
        }

    }
    $scope.callBoomiforprofile = function() {
        var username = $('#email').val();
        var profileemaildata = null;
        if ($("#unsubscribeemailall").is(':checked') | $("#Unsubscribeemail").is(':checked')) {
            if ($("#unsubscribeemailall").is(':checked')) {
                profileemaildata = '{' + '"origin":"' + window.location.origin + '","email":"' + username + '","site": "' + subsiteval + '","consent":{"fullUnsubscribe":true,"fullDate":"' + new Date().toISOString() + '","profile": false,"profileDate": "' + new Date().toISOString() + '"}}';
            } else if ($("#Unsubscribeemail").is(':checked')) {
                profileemaildata = '{' + '"origin":"' + window.location.origin + '","email":"' + username + '","site": "' + subsiteval + '","consent":{"profile": false,"profileDate": "' + new Date().toISOString() + '"}}';
            }
            $.ajax({
                type: "POST",
                crossDomain: true,
                data: profileemaildata,
                url: unsubscribeAPIURL,
                headers: {
  				 "content-type": "application/json",
                 "authorization": "Basic "+window.btoa(clientApiUsername+":"+clientApiPassword)
              },
                success: onSuccess,
                error: onError
            });
        } else {
            $("#unsubscribe-validataion-msg").hide();
            $("#checkbox-validataion-msg").show();
        }
    }
   

    
}]);
//jQuery time
if (pagetype === "progressiveprofile") {
  // setting it to true, remove once target is enabled
  // @variable type: Boolean
  var isProfessionalFieldRequired = true;

  $("body").css("background", "#000");
  $("#company-name").focus(function () {
    if ($(".company-dropdown .error-msg").length) {
      $(".company-dropdown .error-msg").hide();
      $(".company-dropdown .bar").removeClass("error-field");
    }
  });
  var current_fs, next_fs, previous_fs; //fieldsets
  var left, opacity, scale; //fieldset properties which we will animate
  var animating; //flag to prevent quick multi-click glitches
  var resObj;
  var myEmail = document.getElementById("business-replace");
  var response = sessionStorage.getItem("response");
  var JSONObject = JSON.parse(response);
  var email = JSONObject["profile"].email;
  document.getElementById("business-replace").innerHTML = email;

  var nextScreen = function (event) {
    event = event.target.id;
    current_fs = $("#" + event).parent();
    next_fs = $("#" + event)
      .parent()
      .next();

    //activate next step on progressbar using the index of next_fs
    $(".progressive-profile-nav li a")
      .eq($("fieldset").index(next_fs))
      .addClass("active");
    $(".progressive-profile-nav li a")
      .eq($("fieldset").index(next_fs))
      .addClass("previous");

    //show the next fieldset
    next_fs.show();
    //hide the current fieldset with style
    current_fs.hide();
    $("html, body").animate(
      {
        scrollTop: 0,
      },
      "slow"
    );
  };

  var isMicrosoftEdgeOrIE = function () {
    ua = navigator.userAgent;

    /* MSIE used to detect old browsers and Trident used to newer ones*/
    var is_ie =
      ua.indexOf("MSIE ") > -1 ||
      ua.indexOf("Trident/") > -1 ||
      ua.indexOf("Edge/") > -1 ||
      ua.indexOf("Firefox/") > -1;

    return is_ie;
  };

  $(document).on("click", ".previous", function () {
    $(this).parent().nextAll().find("a").removeClass("active");
    $(this).parent().nextAll().find("a").removeClass("previous");
    current_fs = $(this).parent();
    previous_fs = $(this).parent().prev();

    //de-activate current step on progressbar
    $("fieldset").eq($(".progressive-profile-nav li").index(current_fs)).show();
    var other_fs = $("fieldset")
      .eq($(".progressive-profile-nav li").index(current_fs))
      .siblings();
    other_fs.hide();
    $("html, body").animate(
      {
        scrollTop: 0,
      },
      "slow"
    );
  });

  $(".submit").click(function () {
    return false;
  });

  myDeloitteApp.controller("newuserprofileIntController", [
    "$scope",
    "$location",
    function ($scope, $location) {
      $scope.newUserInterestInfo = function () {
        $(".prof-email__link").removeClass("inactiveLink").addClass("active");
        $location.path("/emailupdates");
      };       
      $scope.content = [];
      $scope.tab = [];
      $scope.getData = function () {
        var profileInterestJson;
        var langLocle = myDelLocale;        
        langLocle = langLocle.replace(/\//g, "_"); 
        var url = window.location.href.split(".html")[0];
        if(url.indexOf("mydaas") >0){
		 	url = window.location.href.split(".mydaas")[0];
        }
        $.ajax({
          async: false,
          global: false,
          url: url +".deloitte-interestpage.json",
          data: {
            site: langLocle,
          },
          dataType: "json",
          success: function (data) {
            profileInterestJson = data;
          },
          error: function () {
            
          },
        });
        if (
          typeof profileInterestJson !== "undefined" &&
          profileInterestJson !== ""
        ) {
          profileInterestJson = JSON.stringify(profileInterestJson);
        }
        profileInterestJson = JSON.parse(profileInterestJson);
        $scope.content = profileInterestJson;
        $scope.content = $scope.content.content;
      };
      $scope.getData("us_en");
    },
  ]);

  var checksubs = function () {
    $("#email-updates-btn-finish").show();
    $("#email-updates-btn-continue").hide();
    if (
      $(".profile-email-checkboxes input[name='receiveEmailscheckbox']:checked")
        .length > 0
    ) {
      $("#email-updates-btn-finish").hide();
      $("#email-updates-btn-continue").show();
    }
    $(".profile-email-checkboxes input[type='checkbox']").click(function () {
      if (
        $(
          ".profile-email-checkboxes input[name='receiveEmailscheckbox']:checked"
        ).length > 0
      ) {
        $("#email-updates-btn-finish").hide();
        $("#email-updates-btn-continue").show();
      } else {
        $("#email-updates-btn-finish").show();
        $("#email-updates-btn-continue").hide();
      }
    });
  };
  $('#profile-email-updates input[type="radio"]').click(function () {
    $("#email-updates-btn-finish")
      .removeClass("gray-button")
      .addClass("primary-button");
    if ($(this).attr("id") === "emails-yes") {
      var i = $(".profile-email-checkboxes input[type='checkbox']");
      if (i.length === 0) {
        $(".profile-email-checkboxes").append(
          "<p class='error-msg'>Don't have email marketing solutions</p>"
        );
      }
      var subCheckboxes = $(
        ".profile-email-checkboxes input[name='receiveEmailscheckbox']"
      );
      if (subCheckboxes.length === 0) {
        $("#email-updates-btn-finish").show();
        $("#email-updates-btn-continue").hide();
      } else {
        checksubs();
      }
      $(".email-updates-section").show();
    } else if ($(this).attr("id") === "emails-no") {
      $(".email-updates-section").hide();
      $("#email-updates-btn-continue").hide();
      $("#email-updates-btn-finish").show();
    }
  });
  $('#profile-professional-info input[type="checkbox"]').click(function () {
    if ($(this).attr("id") === "business-email-check") {
      $("#profile-professional-info .business-email-field").toggle();
    }
  });
  var displayError = function (obj, emptyE) {
    $(obj).closest(".form-field").find(".bar").addClass("error-field");
    $(obj)
      .closest(".form-field")
      .append("<p class='error-msg'>" + fieldRequiredError + "</p>");
    if (emptyE === false) {
      emptyE = true;

      var brow = isMicrosoftEdgeOrIE();
      if (!brow) {
        $(obj).focus();
      }
    }
    if ($(obj)[0] === $("#country-config")[0])
      $(obj)
        .closest(".form-field")
        .find("p.error-msg")
        .css("margin-top", "-25px");
    if ($(obj)[0] === $("#zip")[0])
      $(obj)
        .closest(".form-field")
        .find("p.error-msg")
        .css("margin-top", "-25px");
    return emptyE;
  };

  $("#prof-details-btn").on("click", function (event) {
    var emptyExists = false;
    $(".form-field .bar").removeClass("error-field");
    $(".form-field p.error-msg").remove();
    $(".business-email-field .bar").css("border-color", "#999");
    if (
      $(
        '#new-profile-professional-info input[name="myDeloitte.isPrimaryEmail"]:checked'
      ).length <= 0
    ) {
      var regex = /^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-])+\.)+([a-zA-Z0-9]{2,4})+$/;
      if ($("#business-email").val() !== "") {
        if (!regex.test($("#business-email").val())) {
          $(".business-email-field").append(
            "<p class='error-msg email-error'>" + businessEmailError + "</p>"
          );
          $(".business-email-field .bar").css("border-color", "red");
        }
      } else {
        $(".business-email-field").append(
          "<p class='error-msg email-error'>" + businessEmailError + "</p>"
        );
        $(".business-email-field .bar").css("border-color", "red");
      }
    }
    if (
      $('#new-profile-professional-info input[type="checkbox"]:checked')
        .length > 0
    ) {
      $(".business-email-field .bar").css("border-color", "#999");
      $(".email-error").remove();
      $(".email-exists-error").remove();
    }

    $("#profile-email-updates p.error-msg").remove();
    if (
      $("#country-config").val() === "none" ||
      $("#country-config").val() === "" ||
      $("#country-config").val() == null
    )
      emptyExists = displayError($("#country-config"), emptyExists);

    // check for required flag US-590230
    if (isProfessionalFieldRequired) {
      if (!$("#new-profile-professional-info #company-name").val()) {
        emptyExists = displayError($("#company-name"), emptyExists);
      }
      if (
        $(
          "#new-profile-professional-info #industry-config-for-profile"
        ).val() === "none" ||
        $("#industry-config-for-profile").val() === "" ||
        $("#industry-config-for-profile").val() == null
      ) {
        emptyExists = displayError(
          $("#industry-config-for-profile"),
          emptyExists
        );
      }
      if (!$("#new-profile-professional-info #job-title").val()) {
        emptyExists = displayError($("#job-title"), emptyExists);
      }
      if (
        $(
          "#new-profile-professional-info #job-function-in-professional"
        ).val() === "none" ||
        $("#job-function-in-professional").val() === "" ||
        $("#job-function-in-professional").val() == null
      ) {
        emptyExists = displayError(
          $("#job-function-in-professional"),
          emptyExists
        );
      }
    }

    if ($(".error-msg").length <= 0 && $(".email-exists-error").length <= 0) {
      nextScreen(event);
      try {
        _satellite.track("progProfile", {
          screen: "2",
        });
      } catch (e) {}
      if (
        $(
          "#profile-email-updates input[name='receiveEmails'][value='true']"
        ).prop("checked")
      ) {
        $(".email-updates-section").show();
        $("#email-updates-btn-continue").show();
        $("#email-updates-btn-finish").hide();
      }
    }
  });

  $("#business-email-check").on("click", function () {
    $(".business-email-field").toggle();
    $("#business-email").val("");
    $(".business-email-field .bar").css("border-color", "#999");
    $(".email-error").remove();
    $(".email-exists-error").remove();
  });

  $("#interest-details-btn,#interest-details-skip-btn").on("click", function (
    event
  ) {
    nextScreen(event);
    try {
      _satellite.track("progProfile", {
        screen: "3",
      });
    } catch (e) {}
  });

  var sendAccountDetailsToGigyaNR = function () {
    var today = new Date();
    var dd = today.getDate();
    var mm = today.getMonth() + 1; //January is 0!
    var yyyy = today.getFullYear();
    var hour = today.getHours();
    var minu = today.getMinutes();
    var securedlocInfo = getCookie("myD_siteSelector");
    var source = null;
    if (securedlocInfo === "us-en") {
      source = "D&B";
    } else {
      source = "DB";
    }

    if (dd < 10) {
      dd = "0" + dd;
    }
    if (mm < 10) {
      mm = "0" + mm;
    }
    today = yyyy + "-" + mm + "-" + dd + "  " + hour + ":" + minu;

    var dunsnumber = "999999999";

    var keys = [];
    $.each($("input[name='profile-interests']:checked"), function () {
      keys.push($(this).val().replace(/["']/g, ""));
    });
    var str = JSON.stringify(keys);
    var interestIds = str.split(",");
    var isReceiveEmails;
    var profileFrequency = $("input[type='radio'][name='myDeloitte.consent.profileFreq']:checked").val();
    if ($("#emails-yes").is(":checked")) {
      isReceiveEmails = true;
    }
    if ($("#emails-no").is(":checked")) {
      isReceiveEmails = false;
    }

    var emailUpdates = "[";
    var emailupdatesarray = [];
    $.each($("input[name='receiveEmailscheckbox']:checked"), function () {
      emailupdatesarray.push($(this).val());
      sessionStorage.setItem("emailupdates", emailupdatesarray);

      emailUpdates =
        emailUpdates +
        '{"date":"' +
        today +
        '","id":"' +
        $(this).val() +
        '","selected":"true"},';
    });
    emailUpdates = emailUpdates + "]";

    var emaillength = emailupdatesarray.length;
    if (isReceiveEmails === true) {
      if (emaillength == 0) {
        emailUpdates = "[]";
        sessionStorage.removeItem("emailupdates");
      }
    } else {
      emailUpdates = "[]";
      sessionStorage.removeItem("emailupdates");
    }

    var sitesJson =
      '"myDeloitte.sites": ' +
      '[{"site": ' +
      site +
      ', "interests" : ' +
      interestIds +
      ',"consents" : ' +
      emailUpdates +
      "}]";
    // Save the profile page input values in localStorage
    if (
      resObj !== null &&
      resObj.data.myDeloitte !== undefined &&
      resObj.profile !== undefined
    ) {
      if (resObj.data.myDeloitte.alumni === undefined) {
        resObj.data.myDeloitte.alumni = {};
      }
      if (localStorage.getItem("DUNSNUMBER") != null) {
        dunsnumber = localStorage.getItem("DUNSNUMBER");
        localStorage.removeItem("DUNSNUMBER");
      } else if (
        typeof resObj.data.myDeloitte.companyId != "undefined" &&
        resObj.data.myDeloitte.companyId != null && 
        resObj.data.myDeloitte.company === $("#new-profile-professional-info #company-name").val()
        ) {
          dunsnumber = resObj.data.myDeloitte.companyId;
        
      }
      if (
        $.trim($("#new-profile-professional-info #company-name").val())
          .length === 0
      ) {
        dunsnumber = "";
        resObj.data.myDeloitte.company = $.trim(
          $("#new-profile-professional-info #company-name").val()
        );
      } else {
        resObj.data.myDeloitte.company = $(
          "#new-profile-professional-info #company-name"
        ).val();
      }

      //Professional Details
      if ($("#business-email-check:checked").length > 0) {
        resObj.data.myDeloitte.businessEmail = resObj.profile.email;
      } else {
        resObj.data.myDeloitte.businessEmail =
          $("#new-profile-professional-info #business-email").val() ===
          undefined
            ? ""
            : $("#new-profile-professional-info #business-email").val();
      }
      if (resObj.data.myDeloitte.consent !== undefined) {
        resObj.data.myDeloitte.consent.interestDate = new Date().toISOString();
        if ($("#alertsid:checked").length > 0) {
          resObj.data.myDeloitte.consent.interest = true;
        } else {
          resObj.data.myDeloitte.consent.interest = false;
        }
      }
      //Country value and prefSite value for users who closed their accounts earlier
      var allCookie = document.cookie;
      var localeNU;
      var prefSiteNU;
      if (allCookie.indexOf("myD_siteSelector") > 1) {
        var fields = readCookie("myD_siteSelector").split("-");
        localeNU = fields[0];
        prefSiteNU = readCookie("myD_siteSelector");
      } else {
        localeNU = "US";
        prefSiteNU = "us-en";
      }

      //Alumni details - DE-409127
      resObj.data.myDeloitte.alumni.year =
        $("#year-separated").val() === undefined
          ? ""
          : $("#year-separated").val();
      resObj.data.myDeloitte.alumni.mf =
        $("#mf-config-profile").val() === undefined
          ? ""
          : $("#mf-config-profile").val();
      resObj.data.myDeloitte.alumni.selected = isAlumniSelected;
      resObj.data.myDeloitte.alumni.function =
        $("#job-function-in-alumni").val() === undefined
          ? ""
          : $("#job-function-in-alumni").val();

      resObj.data.myDeloitte.industry =
        $(
          "#new-profile-professional-info #industry-config-for-profile"
        ).val() === undefined
          ? ""
          : $(
              "#new-profile-professional-info #industry-config-for-profile"
            ).val();
      resObj.data.myDeloitte.level =
        $("#new-profile-professional-info #current-level-config").val() ===
        undefined
          ? ""
          : $("#new-profile-professional-info #current-level-config").val();

      resObj.data.myDeloitte.jobTitle =
        $("#new-profile-professional-info #job-title").val() === undefined
          ? ""
          : $("#new-profile-professional-info #job-title").val();
      resObj.data.myDeloitte.function =
        $(
          "#new-profile-professional-info #job-function-in-professional"
        ).val() === undefined
          ? ""
          : $(
              "#new-profile-professional-info #job-function-in-professional"
            ).val();
      resObj.data.myDeloitte.companyId = dunsnumber;
      resObj.data.myDeloitte.companySource = source;
      resObj.data.myDeloitte.zip = $("#zip").val();
      resObj.data.myDeloitte.country = localeNU.toUpperCase();
      resObj.data.myDeloitte.prefSite = prefSiteNU;

      if (resObj.data.myDeloitte.consent === undefined) {
        resObj.data.myDeloitte.consent = {};
      }
      resObj.data.myDeloitte.consent.profile = isReceiveEmails;
      resObj.data.myDeloitte.consent.profileFreq = profileFrequency;
      resObj.data.myDeloitte.consent.profileDate = new Date().toISOString();
      if (resObj.data.myDeloitte.sites === undefined) {
        resObj.data.myDeloitte.sites = [];
      }
      resObj.data.myDeloitte.sites = [
        {
          site: JSON.parse(site),
          interests: JSON.parse(interestIds),
        },
      ];
    }
    var profileInfo =
      "{" +
      '"firstName" : "' +
      resObj.profile.firstName +
      '" ,' +
      '"lastName" : "' +
      resObj.profile.lastName +
      '" ,' +
      '"email" : "' +
      resObj.profile.email +
      '" }';

    var dataInfo =
      "{" +
      '"myDeloitte.businessEmail" : "' +
      resObj.data.myDeloitte.businessEmail +
      '" ,' +
      '"myDeloitte.country" : "' +
      resObj.data.myDeloitte.country +
      '" ,' +
      '"myDeloitte.zip" : "' +
      resObj.data.myDeloitte.zip +
      '" ,' +
      '"myDeloitte.prefSite" : "' +
      resObj.data.myDeloitte.prefSite +
      '",' +
      '"myDeloitte.alumni.year" : "' +
      resObj.data.myDeloitte.alumni.year +
      '",' +
      '"myDeloitte.alumni.mf" : "' +
      resObj.data.myDeloitte.alumni.mf +
      '",' +
      '"myDeloitte.alumni.selected" : ' +
      resObj.data.myDeloitte.alumni.selected +
      "," +
      '"myDeloitte.industry" : "' +
      resObj.data.myDeloitte.industry +
      '",' +
      '"myDeloitte.function" : "' +
      resObj.data.myDeloitte.function +
      '",' +
      '"myDeloitte.level" : "' +
      resObj.data.myDeloitte.level +
      '",' +
      '"myDeloitte.company" : "' +
      resObj.data.myDeloitte.company +
      '",' +
      '"myDeloitte.jobTitle" : "' +
      resObj.data.myDeloitte.jobTitle +
      '",' +
      '"myDeloitte.companyId" : "' +
      resObj.data.myDeloitte.companyId +
      '",' +
      '"myDeloitte.companySource" : "' +
      source +
      '",' +
      '"myDeloitte.consent.profile" : ' +
      isReceiveEmails +
      "," +
      '"myDeloitte.consent.profileFreq" : ' +
      '"' +profileFrequency + '"'+     
      "," +
      '"myDeloitte.consent.profileDate" : "' +
      new Date().toISOString() +
      '",' +
      sitesJson +
      "," +
      '"myDeloitte.alumni.function" :"' +
      resObj.data.myDeloitte.alumni.function +
      '" }';
    if (
      isReceiveEmails === true &&
      resObj.data.myDeloitte.consent !== undefined &&
      resObj.data.myDeloitte.consent.fullUnsubscribe !== undefined &&
      resObj.data.myDeloitte.consent.fullUnsubscribe === true
    ) {
      resObj.data.myDeloitte.consent.fullUnsubscribe = false;
      dataInfo =
        "{" +
        '"myDeloitte.businessEmail" : "' +
        resObj.data.myDeloitte.businessEmail +
        '" ,' +
        '"myDeloitte.country" : "' +
        resObj.data.myDeloitte.country +
        '" ,' +
        '"myDeloitte.zip" : "' +
        resObj.data.myDeloitte.zip +
        '" ,' +
        '"myDeloitte.prefSite" : "' +
        resObj.data.myDeloitte.prefSite +
        '",' +
        '"myDeloitte.alumni.year" : "' +
        resObj.data.myDeloitte.alumni.year +
        '",' +
        '"myDeloitte.alumni.mf" : "' +
        resObj.data.myDeloitte.alumni.mf +
        '",' +
        '"myDeloitte.alumni.selected" : ' +
        resObj.data.myDeloitte.alumni.selected +
        "," +
        '"myDeloitte.industry" : "' +
        resObj.data.myDeloitte.industry +
        '",' +
        '"myDeloitte.function" : "' +
        resObj.data.myDeloitte.function +
        '",' +
        '"myDeloitte.level" : "' +
        resObj.data.myDeloitte.level +
        '",' +
        '"myDeloitte.company" : "' +
        resObj.data.myDeloitte.company +
        '",' +
        '"myDeloitte.jobTitle" : "' +
        resObj.data.myDeloitte.jobTitle +
        '",' +
        '"myDeloitte.companyId" : "' +
        resObj.data.myDeloitte.companyId +
        '",' +
        '"myDeloitte.companySource" : "' +
        source +
        '",' +
        '"myDeloitte.consent.fullUnsubscribe" : ' +
        false +
        "," +
        '"myDeloitte.consent.profile" : ' +
        isReceiveEmails +        
        "," +
        '"myDeloitte.consent.profileFreq" : ' +
        '"' +profileFrequency + '"'+ 
        "," +
        '"myDeloitte.consent.profileDate" : "' +
        new Date().toISOString() +
        '",' +
        sitesJson +
        "," +
        '"myDeloitte.alumni.function" :"' +
        resObj.data.myDeloitte.alumni.function +
        '" }';
    }
    var businessemail = resObj.data.myDeloitte.businessEmail;

    var params = {
      profile: profileInfo,
      data: dataInfo
        .replace(/&lt;/g, "")
        .replace(/&gt;/g, "")
        .replace(/&#x2F;/g, "/"),
      addLoginEmails: businessemail,
      apiKey: SOCIAL_API,
      UID: SOCIAL_PROFILE_UID,
      callback: setAccountInfoResponsePR,
    };
    
    gigya.accounts.setAccountInfo(params);
    // save back to session storage
    // this will redirects the page from profile to subscription page
  };

  $("#email-updates-btn-continue").on("click", function (event) {
    
    $(".form-field .bar").removeClass("error-field");
    $(".form-field p.error-msg").remove();
    $("#profile-email-updates p.error-msg").remove();
    if (
      $("#profile-email-updates .form-radio input:radio:checked").length <= 0
    ) {
      $("#profile-email-updates .form-radio").append(
        "<p class='error-msg'>" + optionRequiredError + "</p>"
      );
    }
    if (
      $("#profile-email-updates .form-radio input:radio:checked").val() ===
      "true"
    ) {
      localStorage.setItem("email-updates", "true");
    }
    var i = $(".profile-email-checkboxes input[type='checkbox']");
    if (i.length > 0) {
      if (
        $(".profile-email-checkboxes input[type='checkbox']:checked").length <=
        0
      ) {
        
        $(".email-updates-text").after(
          "<p class='error-msg'>" + consentRequiredError + "</p>"
        );
      } else {
        $(".email-updates-section p.error-msg").remove();
      }
    }
    validateProfileFrequency();
    /*Logic to show only selected subscriptions under email updates*/
    $(".profile-email-checkboxes input:checkbox").each(function () {
      $(
        "#newuser-subscriptions-accordion #sub-" + $(this).attr("id") + ""
      ).hide();
      if ($(this).is(":checked")) {
        showSelectedSub =
          "#newuser-subscriptions-accordion #sub-" + $(this).attr("id") + "";
        $(showSelectedSub).show();
      }
    });
    if ($(".error-msg").length <= 0) {
      sendAccountDetailsToGigyaNR();
      nextScreen(event);
    }
  });



  $("#email-updates-btn-finish").on("click", function () {
    
    $(".form-field .bar").removeClass("error-field");
    $(".form-field p.error-msg").remove();
    $("#profile-email-updates p.error-msg").remove();
    if (
      $("#profile-email-updates .form-radio input:radio:checked").length <= 0
    ) {
      $("#profile-email-updates .form-radio").append(
        "<p class='error-msg'>" + optionRequiredError + "</p>"
      );
    }
    if (
      $("#profile-email-updates .form-radio input:radio:checked").val() ===
      "false"
    ) {
      localStorage.setItem("email-updates", "false");
    }
    if (
      $("#profile-email-updates .form-radio input:radio:checked").val() ===
      "true"
    ) {
      var i = $(".profile-email-checkboxes input[type='checkbox']");
      if (i.length > 0) {
        if (
          $(".profile-email-checkboxes input[type='checkbox']:checked")
            .length <= 0
        ) {
          
          $(".email-updates-text").after(
            "<p class='error-msg'>" + consentRequiredError + "</p>"
          );
        } else {
          $(".email-updates-section p.error-msg").remove();
        }
      }
    }
    // below function is for profile frequency validation for different screens
    validateProfileFrequency();
    if ($(".error-msg").length <= 0) {
      $(".progressive-profile-navbar,.progressive-profile-form").hide();
      $(".profile-complete-screen").show();
      $("html, body").animate(
        {
          scrollTop: 0,
        },
        "slow"
      );
      sendAccountDetailsToGigyaNR();
    }
  });

  $("#save-new-profile-page").on("click", function () {
   
    $(".progressive-profile-navbar,.progressive-profile-form").hide();
    $(".profile-complete-screen").show();
    $("html, body").animate(
      {
        scrollTop: 0,
      },
      "slow"
    );
    sendSubscriptionsToGigyaPR();
  });

  $(document).ready(function () {

    toggleProfileFrequencyDisplay();

    $('#profile-interest input[type="checkbox"]').change(function () {
      $("#interest-details-skip-btn").hide();
      $("#interest-details-btn").show();
    });
    $('#newuser-subscriptions-accordion input[type="checkbox"]').change(
      function () {
        $("#save-new-profile-page")
          .removeClass("gray-button")
          .addClass("primary-button");
      }
    );
    if (matchMedia("(max-width: 767px)").matches) {
      $(window).scroll(function () {
        if ($(this).scrollTop() > $(".header").outerHeight()) {
          //use `this`, not `document`
          $(".progressive-profile-navbar").css({
            position: "fixed",
            top: "0",
          });
          var progressbarHeight = $(
            ".progressive-profile-navbar"
          ).outerHeight();
          $(".progressive-profile-form").css("margin-top", progressbarHeight);
        } else {
          $(".progressive-profile-navbar").css({
            position: "relative",
          });
          $(".progressive-profile-form").css("margin-top", "0");
        }
        if (
          $(window).scrollTop() + $(window).height() >
          $(document).height() - $(".footer").height()
        ) {
          $(".primary-button").css({
            position: "relative",
            "border-radius": "3px",
          });
        } else {
          $(".primary-button").css({
            position: "fixed",
            "border-radius": "0",
          });
        }
      });
    }
    $("a.newuser-confirmation__button").click(function () {
      sessionStorage.removeItem("response");
      sessionStorage.setItem("response", JSON.stringify(resObj));
      /**This if->condition will redirects the mydaas user from progressive profile to consumer app home page **/
      if (
        sessionStorage.getItem("isMyDaaSFlow") === "true" &&
        ((mydaas_postback_url && typeof mydaas_postback_url !== "undefined") ||
          sessionStorage.getItem("mydaas_postback_url"))
      ) {
        post(mydaas_postback_url, resObj);
      } else {
        var dashboard_page_URL = "./dashboard.html";
        $(location).attr("href", dashboard_page_URL);
        //Calling this function to update the subscriptions count in Dashboard page
        subscriptionsCount(resObj);
      }
    });
  });
  //DE 352503 - avoiding enter button click on zip code field
  $(".zipcode-field").on("keyup keypress", function (e) {
    var keyCode = e.keyCode || e.which;
    if (keyCode === 13) {
      e.preventDefault();
      return false;
    }
  });
}

var width;
(function (window) {
  {
    var unknown = "-";

    // screen
    var screenSize = "";
    if (screen.width) {
      width = screen.width ? screen.width : "";
    }

    // browser
    var nVer = navigator.appVersion;
    var nAgt = navigator.userAgent;
    var browser = navigator.appName;
    var version = "" + parseFloat(navigator.appVersion);
    var majorVersion = "";
    var nameOffset, verOffset, ix;

    // Opera
    if ((verOffset = nAgt.indexOf("Opera")) !== -1) {
      browser = "Opera";
      version = nAgt.substring(verOffset + 6);
      if ((verOffset = nAgt.indexOf("Version")) !== -1) {
        version = nAgt.substring(verOffset + 8);
      }
    }
    // Opera Next
    if ((verOffset = nAgt.indexOf("OPR")) !== -1) {
      browser = "Opera";
      version = nAgt.substring(verOffset + 4);
    }
    // Edge
    else if ((verOffset = nAgt.indexOf("Edge")) !== -1) {
      browser = "Microsoft Edge";
      version = nAgt.substring(verOffset + 5);
    }
    // MSIE
    else if ((verOffset = nAgt.indexOf("MSIE")) !== -1) {
      browser = "Microsoft Internet Explorer";
      version = nAgt.substring(verOffset + 5);
    }
    // Chrome
    else if ((verOffset = nAgt.indexOf("Chrome")) !== -1) {
      browser = "Chrome";
      version = nAgt.substring(verOffset + 7);
    }
    // Safari
    else if ((verOffset = nAgt.indexOf("Safari")) !== -1) {
      browser = "Safari";
      version = nAgt.substring(verOffset + 7);
      if ((verOffset = nAgt.indexOf("Version")) !== -1) {
        version = nAgt.substring(verOffset + 8);
      }
    }
    // Firefox
    else if ((verOffset = nAgt.indexOf("Firefox")) !== -1) {
      browser = "Firefox";
      version = nAgt.substring(verOffset + 8);
    }
    // MSIE 11+
    else if (nAgt.indexOf("Trident/") !== -1) {
      browser = "Microsoft Internet Explorer";
      version = nAgt.substring(nAgt.indexOf("rv:") + 3);
    }
    // Other browsers
    else if (
      (nameOffset = nAgt.lastIndexOf(" ") + 1) <
      (verOffset = nAgt.lastIndexOf("/"))
    ) {
      browser = nAgt.substring(nameOffset, verOffset);
      version = nAgt.substring(verOffset + 1);
      if (browser.toLowerCase() === browser.toUpperCase()) {
        browser = navigator.appName;
      }
    }
    // trim the version string
    if ((ix = version.indexOf(";")) !== -1) version = version.substring(0, ix);
    if ((ix = version.indexOf(" ")) !== -1) version = version.substring(0, ix);
    if ((ix = version.indexOf(")")) !== -1) version = version.substring(0, ix);

    majorVersion = parseInt("" + version, 10);
    if (isNaN(majorVersion)) {
      version = "" + parseFloat(navigator.appVersion);
      majorVersion = parseInt(navigator.appVersion, 10);
    }

    // mobile version
    var mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer);

    // cookie
    var cookieEnabled = navigator.cookieEnabled ? true : false;

    if (typeof navigator.cookieEnabled === "undefined" && !cookieEnabled) {
      document.cookie = "testcookie";
      cookieEnabled =
        document.cookie.indexOf("testcookie") !== -1 ? true : false;
    }

    // system
    var os = unknown;
    var clientStrings = [
      { s: "Windows 10", r: /(Windows 10.0|Windows NT 10.0)/ },
      { s: "Windows 8.1", r: /(Windows 8.1|Windows NT 6.3)/ },
      { s: "Windows 8", r: /(Windows 8|Windows NT 6.2)/ },
      { s: "Windows 7", r: /(Windows 7|Windows NT 6.1)/ },
      { s: "Windows Vista", r: /Windows NT 6.0/ },
      { s: "Windows Server 2003", r: /Windows NT 5.2/ },
      { s: "Windows XP", r: /(Windows NT 5.1|Windows XP)/ },
      { s: "Windows 2000", r: /(Windows NT 5.0|Windows 2000)/ },
      { s: "Windows ME", r: /(Win 9x 4.90|Windows ME)/ },
      { s: "Windows 98", r: /(Windows 98|Win98)/ },
      { s: "Windows 95", r: /(Windows 95|Win95|Windows_95)/ },
      { s: "Windows NT 4.0", r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/ },
      { s: "Windows CE", r: /Windows CE/ },
      { s: "Windows 3.11", r: /Win16/ },
      { s: "Android", r: /Android/ },
      { s: "Open BSD", r: /OpenBSD/ },
      { s: "Sun OS", r: /SunOS/ },
      { s: "Linux", r: /(Linux|X11)/ },
      { s: "iOS", r: /(iPhone|iPad|iPod)/ },
      { s: "Mac OS X", r: /Mac OS X/ },
      { s: "Mac OS", r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ },
      { s: "QNX", r: /QNX/ },
      { s: "UNIX", r: /UNIX/ },
      { s: "BeOS", r: /BeOS/ },
      { s: "OS/2", r: /OS\/2/ },
      {
        s: "Search Bot",
        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/,
      },
    ];
    for (var id in clientStrings) {
      if (clientStrings.hasOwnProperty(id)) {
        var cs = clientStrings[id];
        if (cs.r.test(nAgt)) {
          os = cs.s;
          break;
        }
      }
    }

    var osVersion = unknown;

    if (/Windows/.test(os)) {
      osVersion = /Windows (.*)/.exec(os)[1];
      os = "Windows";
    }

    switch (os) {
      case "Mac OS X":
        osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1];
        break;

      case "Android":
        osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1];
        break;

      case "iOS":
        osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
        osVersion =
          osVersion[1] + "." + osVersion[2] + "." + (osVersion[3] | 0);
        break;
      default:
    }

    // flash (you'll need to include swfobject)
    /* script src="//ajax.googleapis.com/ajax/libs/swfobject/2.2/swfobject.js" */
    var flashVersion = "no check";
    if (typeof swfobject !== "undefined") {
      var fv = swfobject.getFlashPlayerVersion();
      if (fv.major > 0) {
        flashVersion = fv.major + "." + fv.minor + " r" + fv.release;
      } else {
        flashVersion = unknown;
      }
    }
  }

  window.jscd = {
    screen: screenSize,
    browser: browser,
    browserVersion: version,
    browserMajorVersion: majorVersion,
    mobile: mobile,
    os: os,
    osVersion: osVersion,
    cookies: cookieEnabled,
    flashVersion: flashVersion,
  };
})(this);
var OsDetails = jscd.os + " " + jscd.osVersion;
var browserDetails =
  jscd.browser +
  " " +
  jscd.browserMajorVersion +
  " (" +
  jscd.browserVersion +
  ")";
var deviceDetails = "";
if (width > 1024) {
  deviceDetails = "Desktop";
} else if (width < 768) {
  deviceDetails = "Mobile";
} else if (width >= 768 && width < 1024) {
  deviceDetails = "Tablet";
}
// Code for Prepopulating values in fields when user is Logged In and Ajax call

var firstName, lastName, email, uid, companyName, jobTitle, country;

$(document).ready(function () {
  var loggedIn = localStorage.getItem("userLoggedInIs");
  var res = JSON.parse(sessionStorage.getItem("response"));
  loadMemeberfirmsval();
  if (wcmMode !== "EDIT") {
    $("#mydticketing form").attr("action", "/misc/contactus.html");
  }

  if (loggedIn === "true" && loggedIn != null) {
    if (res !== null) {
      if (
        typeof res.profile.firstName !== "undefined" ||
        typeof res.profile.firstName != null
      ) {
        firstName = JSON.parse(sessionStorage.getItem("response")).profile
          .firstName;
        $("#mydticketing input[name=FirstName]").val(firstName);
      }

      if (
        typeof res.profile.lastName !== "undefined" ||
        typeof res.profile.lastName != null
      ) {
        lastName = JSON.parse(sessionStorage.getItem("response")).profile
          .lastName;
        $("#mydticketing input[name=LastName]").val(lastName);
      }

      if (
        typeof res.profile.email !== "undefined" ||
        typeof res.profile.email != null
      ) {
        email = JSON.parse(sessionStorage.getItem("response")).profile.email;
        $("#mydticketing input[name=Email]").val(email);
      }

      if (typeof res.UID !== "undefined" || typeof res.UID != null) {
        uid = res.UID;
      }

      if (
        typeof res.data.myDeloitte.company !== "undefined" ||
        typeof res.data.myDeloitte.company != null
      ) {
        companyName = res.data.myDeloitte.company;
        $("#mydticketing input[name=Company]").val(companyName);
      }

      if (
        typeof res.data.myDeloitte.jobTitle !== "undefined" ||
        typeof res.data.myDeloitte.jobTitle != null
      ) {
        jobTitle = res.data.myDeloitte.jobTitle;
        $("#mydticketing input[name=JobTitle]").val(jobTitle);
      }

      if (
        typeof res.data.myDeloitte.country !== "undefined" ||
        typeof res.data.myDeloitte.country != null
      ) {
        country = res.data.myDeloitte.country;
        $("#mydticketing select[name=Country]").val(country);
      }
    }
  } else {
    var contactusCountrySel = sessionStorage.getItem("contactusCountry");
    if (
      contactusCountrySel !== "undefined" &&
      contactusCountrySel != null &&
      contactusCountrySel !== ""
    ) {
      country = contactusCountrySel;
      $("#mydticketing select[name=Country]").val(contactusCountrySel);
    }
  }

  // Submitting the form.
  $(".form_button_submit").on("click", function (e) {
    $(".myD-wrapper .contactus-form").css("opacity", "0.5");
    // $(".LoadingImage").show();
    var issueType = $("#mydticketing select[name=Issue]").val();
    var desc = $("#mydticketing textarea[name=Description]").val();
    firstName = $("#mydticketing input[name=FirstName]").val();
    lastName = $("#mydticketing input[name=LastName]").val();
    email = $("#mydticketing input[name=Email]").val();
    companyName = $("#mydticketing input[name=Company]").val();
    jobTitle = $("#mydticketing input[name=JobTitle]").val();
    var phone = $("#mydticketing input[name=Phone]").val();
    var callerId = email;
    country = $("#mydticketing select[name=Country]").val();
    // We are setting slected country to session Storage for us to show teh selected country value if user already selected the country value and is not logged IN
    sessionStorage.setItem("contactusCountry", country);
    var deviceType = deviceDetails;
    var browser = browserDetails;
    var operatingSys = OsDetails;
    var tou = $("#mydticketing input[name=TOU]").is(":checked");
    var formURL =
      window.location.pathname.substring(
        0,
        window.location.pathname.lastIndexOf(".html")
      ) + ".deloitte-mydeloittecontactusform.json";
    var formData =
      "site=us/en&issue=" +
      issueType +
      "&description=" +
      desc +
      "&caller_id=" +
      callerId +
      "&firstName=" +
      firstName +
      "&lastName=" +
      lastName +
      "&companyName=" +
      companyName +
      "&jobTitle=" +
      jobTitle +
      "&phone=" +
      phone +
      "&UID=" +
      uid +
      "&country=" +
      country +
      "&deviceType=" +
      deviceType +
      "&browser=" +
      browser +
      "&operatingSystem=" +
      operatingSys +
      "&tou=" +
      tou;
    if (
      issueType !== "" &&
      !isNaN(phone) &&
      email.indexOf("@") > -1 &&
      desc !== "" &&
      firstName !== "" &&
      lastName !== "" &&
      callerId != "" &&
      deviceType !== "" &&
      browser !== "" &&
      operatingSys !== "" &&
      country != "" &&
      tou !== false &&
      tou !== "false"
    ) {
      $.ajax({
        url: formURL,
        type: "GET",
        async: "false",
        data: formData,
        success: function () {
          $(".myD-wrapper .contactus-form").css("opacity", "1");
          $("#mydticketing").hide();
          $(".myDThanks-msg").show();
          _satellite.track("myDReportedIssues");
        },
        error: function () {},
      });
      e.preventDefault();
    }
  });
});

/* Code for loading the mf names for contact us  page Country dropdown options.*/
function loadMemeberfirmsval() {
  var countryOption = "";
  var globalSelectListJson = JSON.parse(
    sessionStorage.getItem("globalSelectListJson")
  );
  if (globalSelectListJson == null) {
    loadMyDeloitteGlobalSelectList();
    globalSelectListJson = JSON.parse(
      sessionStorage.getItem("globalSelectListJson")
    );
  }
  var countryJson =
    globalSelectListJson["myd-generic-list"][
      "country-config-for-personal-info-section"
    ];
  if (countryJson) {
    for (var i = 1; i < countryJson.length; i++) {
      countryOption +=
        "<option value='" +
        countryJson[i]["value"] +
        "'>" +
        countryJson[i]["text"] +
        "</option>";
    }
  }

  $("#mydticketing select[name=Country]").append(countryOption);
}

// XSS prevention
$(".contactus-form input,.contactus-form textarea").on(
  "keydown focusout",
  function () {
    $(this).val(encodeContactUsXss($(this).val()));
  }
);

function encodeContactUsXss(s) {
  return s
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/#/g, "hash")
    .replace(/\//, "slash")
    .replace(/%/g, "percentile");
}

//code to set uVal, deviceDetails, browserDetails and OperatingSystem values to cookie
let setCookiesForMyDAEM = (cookieName, cookieValue) => {
  const checkName = cookieName + "=";
  const isCookie =  (document.cookie.split(';').some((item) => item.trim().startsWith(checkName)));
  if(!isCookie && cookieValue) {
    document.cookie = cookieName + "=" + cookieValue + ";path=/";
  }
}

$(window).load(function () {
  var res = JSON.parse(sessionStorage.getItem("response"));
  var formsIframe = $("iframe#aemFormFrame").contents();
  formsIframe.find("button.submit").click(function () {
    setCookiesForMyDAEM("deviceType", deviceDetails);
    setCookiesForMyDAEM("browser", browserDetails);
    setCookiesForMyDAEM("operatingSys", OsDetails);
    if(res && res.UID) {
      setCookiesForMyDAEM("uVal",res.UID);
    }
  });
});

/* Code for loading the mf names for contact us  page Country dropdown options.*/
$(window).load(function () {
    var countryOption = "";
	var globalSelectListJson = JSON.parse(sessionStorage.getItem("globalSelectListJson"));

	if(globalSelectListJson == null){
		loadMyDeloitteGlobalSelectList();
		globalSelectListJson = JSON.parse(sessionStorage.getItem("globalSelectListJson"));
	}
	var countryJson = globalSelectListJson["myd-generic-list"]["country-config-for-personal-info-section"];

	if (countryJson) {

		for (var i = 1; i < countryJson.length; i++) {
			countryOption += "<option value='" + countryJson[i]['value'] + "'>"
					+ countryJson[i]['text'] + "</option>";
            
		}
	}
  	var formsIframe = $("iframe#aemFormFrame").contents();  
	formsIframe.find(".guidedropdownlist.guidefield .guideFieldNode.guideDropDownList.country select").append(countryOption);
// Code for Prepopulating values in fields when user is Logged Into MyDcontactusAEM form
    if(formsIframe.length == 1) {
  var aemFormsInterval = setInterval(function() {
   var loggedIn = localStorage.getItem("userLoggedInIs");
   var res = JSON.parse(sessionStorage.getItem("response"));
   if(formsIframe.find("form#guideContainerForm").length == 1) {
    clearInterval(aemFormsInterval);
   }
   if (loggedIn === "true" && loggedIn != null) {
    if (res !== null) {
     if (
     typeof res.profile.firstName !== "undefined" ||
     typeof res.profile.firstName != null
     ) {
      firstName = JSON.parse(sessionStorage.getItem("response")).profile
      .firstName;
      formsIframe.find("input[aria-label='First name*']").val(firstName);
     }
    
     if (
     typeof res.profile.lastName !== "undefined" ||
     typeof res.profile.lastName != null
     ) {
      lastName = JSON.parse(sessionStorage.getItem("response")).profile
      .lastName;
      formsIframe.find("input[aria-label='Last name*']").val(lastName);
     }
    
     if (
     typeof res.profile.email !== "undefined" ||
     typeof res.profile.email != null
     ) {
      email = JSON.parse(sessionStorage.getItem("response")).profile.email;
      formsIframe.find("input[aria-label='Email*']").val(email);
     }
    
     if (typeof res.UID !== "undefined" || typeof res.UID != null) {
     uid = res.UID;
     }
    
     if (
     typeof res.data.myDeloitte.company !== "undefined" ||
     typeof res.data.myDeloitte.company != null
     ) {
      companyName = res.data.myDeloitte.company;
      formsIframe.find("input[aria-label='Company name']").val(companyName);
     }
    
     if (
     typeof res.data.myDeloitte.jobTitle !== "undefined" ||
     typeof res.data.myDeloitte.jobTitle != null
     ) {
      jobTitle = res.data.myDeloitte.jobTitle;
      formsIframe.find("input[aria-label='Job title']").val(jobTitle);
     }
    
     if (
     typeof res.data.myDeloitte.country !== "undefined" ||
     typeof res.data.myDeloitte.country != null
     ) {
      country = res.data.myDeloitte.country;
      formsIframe.find("select[aria-label='Country*']").val(country);
     }
    }
   }
  }, 200);
 }
});

$(window).load(function () {
  // Moving the content of the page below the header
  var header_height = $("header").height();
  $(".customform-header-section").css("margin-top", header_height);
  // All the forms are inside iframes, so applying the styles via JS to match as per deloitte branding, these are common for all the forms
  var formsIframe = $("iframe#aemFormFrame").contents();
  formsIframe.find(".guideFieldButtonWidget button").hover(
    function () {
      $(this).css("backgroundColor", "#009adb");
      $(this).css("border-color", "#009adb");
      $(this).css("transition", "all .3s linear");
    },
    function () {
      $(this).css("backgroundColor", "#0076a8");
      $(this).css("border-color", "#0076a8");
      $(this).css("transition", "all 0s linear");
    }
  );
  formsIframe
    .find(".guideContainerNode .step.mobileLayout")
    .css("display", "none");
  formsIframe.find(".guideseparator").css("display", "none");
  formsIframe
    .find(".guidetextbox .guideFieldNode.guideTextBox.page")
    .css("display", "none");
  formsIframe
    .find(
      ".guideFieldLabel label, .guideWidgetLabel.right label, .guideWidgetLabel.left label, .afTncContentArea, button:not(.af-icon-button), .guidetextdraw.guidefield"
    )
    .css({
      color: "black",
      "font-size": "12px",
      "font-family": "'Open Sans',Verdana,Helvetica,sans-serif",
      "line-height": "1.72em",
    });

  formsIframe.find(".guideFieldButtonWidget button.submit").css({
    "background-color": "#0076a8",
    "font-size": "0.74em",
    padding: "0.44em 2.1em",
    "margin-left": "10px",
    "border-bottom-left-radius": "2px",
    "border-bottom-right-radius": "2px",
    "border-top-left-radius": "2px",
    "border-top-right-radius": "2px",
    "font-family": "'Open Sans',Verdana,Helvetica,sans-serif",
    "border-color": "rgb(0, 118, 168) !important",
    color: "#fff",
    "font-weight": "700",
    border: "0px",
  });

  formsIframe.find("#guideContainerForm .guideContainerWrapperNode").css({
    "background-color": "#fff",
  });
  formsIframe.find(".guideTextDraw.guideStaticText, .dropDownList select").css({
    color: "black",
    "font-family": "'Open Sans',Verdana,Helvetica,sans-serif",
  });
  formsIframe.find(".afFormTitle .guideformtitle").css({
    width: "100%",
    display: "block",
    "margin-left": "0",
    "margin-top": "20px",
    "font-size": "1.43em",
    "border-bottom": "1px solid #86bc25",
    "padding-bottom": "5px",
  });
  formsIframe.find(".afTermsAndConditions .afTncContentArea").css({
    "font-size": "14.4px",
    border: "none",
    "padding-left": "3px",
  });
  formsIframe
    .find(".afTermsAndConditions .afTncContentArea .guide-tnc-content")
    .css({
      "font-size": "14.4px",
    });
  formsIframe
    .find(".afTermsAndConditions .guide-tnc-checkbox .guideWidgetLabel")
    .css({
      "padding-top": "4px",
    });
  formsIframe.find(".afTermsAndConditions .guide-tnc-checkbox label").css({
    "font-size": "14.4px",
  });
  formsIframe.find(".guidetermsandconditions .afTermsAndConditions").css({
    "padding-left": "0",
  });
  formsIframe.find(".guideFieldWidget textarea").css({
    "font-family": "Arial",
  });
  formsIframe.find(".guide-tnc-checkboxwidget input").css({
    border: "1px solid rgb(208,208,206)",
    "margin-top": "-5px",
    "margin-left": "5px",
  });
  formsIframe.find("label").css("font-weight", "bold");
  formsIframe.find("#guideContainerForm .container").css({
    padding: "0 !important",
    width: "100%",
  });
  formsIframe.find(".guidetextbox.guidefield").css({
    "margin-top": "5px",
  });
  formsIframe.find(".guideTextBox").css({
    padding: "0 !important",
    margin: "0",
  });

  formsIframe
    .find(
      ".guideFieldWidget.dropDownList select, .guideFieldWidget.textField input"
    )
    .css({
      height: "36px",
      width: "340px",
      padding: "5px",
      "border-radius": 0,
      "font-size": "12px",
    });
  formsIframe.find(".guideFieldWidget.textField.multiline textarea").css({
    height: "60px",
    width: "340px",
    "border-radius": 0,
    "font-size": "12px",
    padding: "5px",
  });
  formsIframe
    .find(
      ".guideFieldWidget.dropDownList select:focus-within, .guideFieldWidget.textField:focus-within, .guideFieldWidget.textField input:focus-within"
    )
    .css({
      outline: "none !important",
    });
  formsIframe.find(".guideFieldWidget.textField.multiline:focus-within ").css({
    outline: "none !important",
  });
  formsIframe.find("#guideContainerForm #guideContainer-rootPanel-guidecaptcha___guide-item").css({
		"display": "none",
	});
  formsIframe.find("button.submit").click(function () {
    setTimeout(function () {
      formsIframe.find("div#loadingPage.guideLoading").css({
        opacity: 0.5,
      });
    }, 10);

    //To hide the portion above the thank you message.
    var checkTyMessage = setInterval(function() {
      if(formsIframe.find(".aemformcontainer div.tyMessage").length == 1) {
        $("div#mydticketing  h2:first-child, div#mydticketing  h2 ~ p, div#mydticketing p ~ ul").css({
          "display": "none",
        });
        clearInterval(checkTyMessage);
      }
    }, 100);
  });
});

myDeloitteApp.controller('site-selector', ['$scope', '$http', function($scope){
    var countryJsonData = {};
    var locale = "en_GLOBAL";

    var siteInfo = getCookie("myD_siteSelector");
    if(siteInfo && siteInfo.indexOf('-') > -1){
        locale = siteInfo.split('-');
        locale = locale[1] + '_' + locale[0].toUpperCase();
    }

    if(siteInfo.indexOf("insights") > -1){
        locale = siteInfo.split('-');
        locale = locale[2] + '_' + locale[1].toUpperCase();
    }
     // US-518839: function to remove countries not mentioned in URL
     $scope.selectCountryAsPerURL = function(countries) {
        var url = $.urlParam('site');
        var resultantCountries = [];
        var urlSiteValue = url !== 0 ? url.split('=') : url;
        if (countries && countries.length && urlSiteValue!==0) {    
            countries.filter(function(country) {
            var countryLang = country.myDLocale.split('-');
            var urlSiteValueLang=urlSiteValue[0].split('-');
                    if ( countryLang[1] === urlSiteValueLang[1] ) {
                        resultantCountries.push(country);
                    }  
                });
                    $scope.countries = resultantCountries;
            } else{
                 $scope.countries = countries;
            }
    }

    $scope.loadCountryNames = function(){
        /* Attempt to fetch JSON from local cache */
        if (Modernizr.localstorage && localStorage.getItem(locale) !== null && localStorage.getItem(locale) !== "undefined") {
            var currentTimestamp = Math.round(new Date().getTime()) / 10000;
            var storedTimestamp = 0;
            var localJSON = {};
            var tempLocalJSON = JSON.parse(localStorage.getItem(locale));

            //validate the local JSON
            if (typeof tempLocalJSON.createdAt !== "undefined" && tempLocalJSON.createdAt > 0 && typeof tempLocalJSON.countries !== "undefined" && tempLocalJSON.countries.length > 0) {
                localJSON = tempLocalJSON;
                storedTimestamp = localJSON.createdAt / 10000;
            }
            if ((currentTimestamp - storedTimestamp) <= 86400) {
                countryJsonData = localJSON;
                $scope.myDSitesPublish = countryJsonData.count[0].myDSitesPublish;
                $scope.countries = countryJsonData.countries.filter(function(country){return country.myDeloitte});
            }
              // US-518839: removing countries not mentioned in URL
                if (mydaas_action) {
                    $scope.selectCountryAsPerURL($scope.countries);

              // BUG-576871: hiding "Available in X locations and X languages" text at the bottom of the drop down on registration page. - Vinay G
                    $(".site-selector__container__site-info").hide();
                    $(".site-selector__container location-container .open").css('height','26.3em');
                    $(".site-selector__container__list").css('height','100%');
                }
        }

        //If do not have a valid JSON (from cache) make a JSON request
        if ("undefined" === typeof countryJsonData.countries || countryJsonData.countries.length <= 0) {
            var cacheBustDate  = new Date();
            var jsUrl = '/content/dam/Deloitte/resources/sitesel/' + locale + '.js?x=' + cacheBustDate.getTime();
            $.ajax({
                url: jsUrl,
                dataType: "json",
                success: function(responseJson) {
                    $scope.processJson(responseJson);
                }
            });
        }
    }

    $scope.processJson = function(data){
        if ("undefined" !== typeof data.countries && data.countries.length > 0) {
            var nowTime = new Date();
            countryJsonData = data;
            countryJsonData.aemMode = wcmMode;
            countryJsonData.createdAt = nowTime.getTime();
            if (Modernizr.localstorage) {
                localStorage.setItem(locale, JSON.stringify(countryJsonData));
            }
            $scope.myDSitesPublish = countryJsonData.count[0].myDSitesPublish;
            $scope.countries = data.countries.filter(function(country){return country.myDeloitte});
            
             // US-518839: removing countries not mentioned in URL
             if (mydaas_action) {
                 $scope.selectCountryAsPerURL($scope.countries);

            // BUG-576871: hiding "Available in X locations and X languages" text at the bottom of the drop down on registration page. - Vinay G
                 $(".site-selector__container__site-info").hide();
                 $(".site-selector__container location-container .open").css('height','26.3em');
                 $(".site-selector__container__list").css('height','100%');
             }
             $scope.$apply();
        }
    }

    // init loadCountryNames
    $scope.loadCountryNames();

}]);
/* Function to process the json and call renderControl Function */

/* Siteselector UI manipulations*/
function selectSiteSelector(e) {
    e.preventDefault();
    var siteselectorNode = '';
    if(pagetype === 'registration' && $("#modal-site-confirm-language").hasClass('show')){
            siteselectorNode = '#modal-site-confirm-language';
        
    }
    $(siteselectorNode + ' #site-options').removeClass("visibility-hidden");
    if ($(siteselectorNode + ' .location-container').hasClass("open")) {
        $(siteselectorNode + ' .location-container').slideUp(200).removeClass("open");
        $(siteselectorNode + " .location-container input.gsc-input").val("");
        $(siteselectorNode + ' .location-link.no-click-close').removeClass("site-autodrop");
        $(siteselectorNode + ' .siteselector').removeClass("site-autodrop");
        $(siteselectorNode + ' a.location-link').removeClass("active");
        $(siteselectorNode + " .location-link").attr('aria-expanded', false);

    } else {
        $(siteselectorNode + ' .location-link.no-click-close').addClass("site-autodrop");
       
        $(siteselectorNode + " .location-link").attr('aria-expanded', true);
        $(siteselectorNode + ' a.location-link').addClass("active");
        $(siteselectorNode + ' .location-container').delay(0).slideDown().addClass("open");
    }
}

/* invoke site selector when clicking on location selector link */
$(".site-language,.site-language-dropdown .icon-chevron-down").on("click", selectSiteSelector);

/*Accessibilty code*/
$('#site-selector ul.channel-site li a').on("focus", function() {
    $(this).parent().css('background-color', '#f9f9f9');
});

$('#site-selector ul.channel-site li a').on("focusout", function() {
    $(this).parent().css('background-color', '#ffffff');
});

$("#site-selector ul.channel-site li a:last").on("focusout", function() {
    $('.siteselector').removeClass("site-autodrop");
    $('.modal-backdrop').addClass("visibility-hidden");
    $('#location').removeClass("site-autodrop");
    $('.location-link.no-click-close').removeClass("site-autodrop");
    $(".location-container").slideUp().removeClass("open");
    $('a.location-link').removeClass("active");

});

var modalContainer = $(document.createElement('div')).addClass('modal-backdrop').addClass('fade').addClass('in').addClass('visibility-hidden');
$("nav.navigation").append(modalContainer);
if ((matchMedia('(max-width: 767px)').matches) && (matchMedia('(min-width: 260px)').matches)) {
    $("nav.navigation div.modal-backdrop").remove();
}

/* Funtion to toggle siteselector dropdown*/
$(document).bind("keyup", null, function(e) {
    if (e.which === 27 && $(".location-container").hasClass("open")) {
            $('.siteselector').removeClass("site-autodrop");
            $('.modal-backdrop').addClass("visibility-hidden");
            $('#location').removeClass("site-autodrop");
            $('.location-link.no-click-close').removeClass("site-autodrop");
            $(".location-container").slideUp().removeClass("open");
            $('a.location-link').removeClass("active");
            $(".location-container input.gsc-input").val("");
            setTimeout(function() {
                $(".location-container input.gsc-input").focus();
            }, 100);
        }
    
});
myDeloitteApp.factory('transformService', [
    '$http', function ($http) {

        // To be included in header
        var AuthorizationKey = {
            "Authorization": "ApiKey "+ window.search_key,
            "Content-Type": "application/json"
        }

        //Elastic URL for searching in search templates
        var elasticURL = window.search_engine + '/template';
        var savedItemsElasticURL = window.meta_engine + '/template';

        

        // Function for formating the elastic response
        var formatElasticData = function (result, type) {
            var ResultArray = result.hits.hits;
            var UpdatedResultArray = []

            if (ResultArray) {
                $.each(ResultArray, function (index) {
                    UpdatedResultArray.push(ResultArray[index]._source);
                })

                var responseData = {};
                responseData["total-results"] = result.hits.total.value;
                responseData["result-sets"] = [];

                if (type === "dynamic-promos"){
                    var articles = {
                        "mydeloitte_articles": UpdatedResultArray
                    };
                    responseData["result-sets"].push(articles);
                    return(responseData);
                }
                else if(type === "saved-promos"){
                    responseData["result-sets"] = UpdatedResultArray;
                    return(responseData);
                }
            }
        }


        var getArticlesFromElastic = function ( count, query, excluded_promo, pageNum, isMyFeed) {

            if (!isMyFeed) {
                return new Promise(function (resolve) {

                    // Elastic call for Dashboard article promos
                    $.ajax({
                        "url": elasticURL,
                        "method": "POST",
                        "timeout": 0,
                        "headers": AuthorizationKey,
                        "data": JSON.stringify(
                            {
                                "id": "mydeloitte-dashboard-articles-search-template",
                                "params": {
                                    "page-id": excluded_promo,
                                    "tags": query,
                                    "country-code": window.sc_country,
                                    "country-lang": window.sc_language,
                                    "from": count*(pageNum-1),
                                    "size": count
                                }
                            }
                        ),
                        success: function (result) {
                            resolve(formatElasticData(result, "dynamic-promos"));

                        },
                        error: function (error) {
                            console.log(error);
                        }
                    });
                });
            } 
            else {

                return new Promise(function (resolve) {

                    //Elastic call for Content feed promos
                    $.ajax({
                        "url": elasticURL,
                        "method": "POST",
                        "timeout": 0,
                        "headers": AuthorizationKey,
                        "data": JSON.stringify(
                            {
                                "id": "mydeloitte-content-feed-search-template",
                                "params": {
                                    "tags": query,
                                    "country-code": window.sc_country,
                                    "country-lang": window.sc_language,
                                    "from": count*(pageNum-1),
                                    "size": count
                                }
                            }
                        ),
                        success: function (result) {
                            resolve(formatElasticData(result, "dynamic-promos"));

                        },
                        error: function (error) {
                            console.log(error);
                        }
                    });
                });
            }
        }

        var getEventsFromElastic = function ( count, query, excluded_promo, pageNum) {

            return new Promise(function (resolve) {

                //Elastic call for Dashboard event promos
                $.ajax({
                    "url": elasticURL,
                    "method": "POST",
                    "timeout": 0,
                    "headers": AuthorizationKey,
                    "data": JSON.stringify(
                        {
                            "id": "mydeloitte-dashboard-events-search-template",
                            "params": {
                                "page-id": excluded_promo,
                                "country-code": window.sc_country,
                                "country-lang": window.sc_language,
                                "tags": query,
                                "page-type": "flex-eventdetails",
                                "from": count*(pageNum-1),
                                "size": count
                            }
                        }
                    ),
                    success: function (result) {
                        resolve(formatElasticData(result, "dynamic-promos"));
                    },
                    error: function (error) {
                        console.log(error);

                    }
                });
            });
        }

    var getArticlesForSavedItems = function (query, pageNum) {
        // keeping count = 8 to fetch 8 results at a time
        const pageIdList = query.trim().split("|");
        return new Promise(function (resolve) {
            $.ajax({
                url: savedItemsElasticURL, 
                "method": "POST",
                "timeout": 0,
                "headers": AuthorizationKey,
                "data": JSON.stringify(
                  {
                      "id": "mydeloitte-saved-items-non-events-search-template",
                      "params": {
                        "page-id-list": pageIdList,
                        "from": 8*(pageNum-1),
                        "size": 8
                      }
                  }
                ),
                dataType: 'json',
                success: function (result) {
                    resolve(formatElasticData(result, "saved-promos"));
                },
                error: function (error) {
                    console.log(error);
      
                }
            });
        });
    }
    
    var getEventsForSavedItems = function (query, pageNum) {
          // keeping count = 8 to fetch 8 results at a time
          const pageIdList = query.trim().split("|");
          return new Promise(function (resolve) {
              $.ajax({
                  url: savedItemsElasticURL, 
                  "method": "POST",
                  "timeout": 0,
                  "headers": AuthorizationKey,
                  "data": JSON.stringify(
                    {
                        "id": "mydeloitte-saved-items-events-search-template",
                        "params": {
                            "pagetype": "flex-eventdetails",
                            "page-id-list": pageIdList,
                            "from": 8*(pageNum-1),
                            "size": 8
                        }
                    }
                  ),
                  dataType: 'json',
                  success: function (result) {
                    resolve(formatElasticData(result, "saved-promos"));
                  },
                  error: function (error) {
                      console.log(error);
        
                  }
              });
          });
    }
    
    var getAllBookmarksForDashboard = function (query) {
        const pageIdList = query.trim().split("|");
        return new Promise(function (resolve) {
            $.ajax({
                url: savedItemsElasticURL, 
                "method": "POST",
                "timeout": 0,
                "headers": AuthorizationKey,
                "data": JSON.stringify(
                  {
                      "id": "mydeloitte-dashboard-saved-items-search-template",
                      "params": {
                          "page-id-list": pageIdList,
                          "from": 0,
                          "size": 8
                      }
                  }
                ),
                dataType: 'json',
                success: function (result) {
                    resolve(formatElasticData(result, "saved-promos"));
                },
                error: function (error) {
                    console.log(error);
      
                }
            });
        });
    }

    var getCuratedPromosForDashboard = function (pageIdList) {
        
        return new Promise(function (resolve) {
            $.ajax({
                "url": elasticURL,
                "method": "POST",
                "timeout": 0,
                "headers": AuthorizationKey,
                "data": JSON.stringify(
                  {
                    "id":"mydeloitte-dashboard-curated-promos-search-template",
                    "params": {
                      "page-id": pageIdList,
                      "country-code": window.sc_country,
                      "country-lang": window.sc_language,
                    }
                  }
                ),
                success: function (result) {

                    resolve(formatElasticData(result, "saved-promos"));
      
                },
                error: function (error) {
                    console.log(error);
      
                }
            });
        });
    }

        return {
            getArticlesFromElastic: getArticlesFromElastic,
            getEventsFromElastic: getEventsFromElastic,
            getArticlesForSavedItems: getArticlesForSavedItems,
            getEventsForSavedItems: getEventsForSavedItems,
            getAllBookmarksForDashboard: getAllBookmarksForDashboard,
            getCuratedPromosForDashboard: getCuratedPromosForDashboard
        };
    }
]);

myDeloitteApp.factory("utilityService", [
  "$http",
  function () {
    var getAllEventDates = function (promo) {
      try {
        var eventdate = {};
        var startDateObj = new Date(promo["start-date"]);
        var endDateObj = new Date(promo["end-date"]);
        eventdate.stdate = (startDateObj.getUTCDate() < 10 ? '0' : '') + startDateObj.getUTCDate();
        eventdate.enddate = (endDateObj.getUTCDate() < 10 ? '0' : '') + endDateObj.getUTCDate();
        eventdate.stday = startDateObj.toLocaleString("default", {
          weekday: "short",
        });
        var sttime = startDateObj
          .toLocaleString("en-US", {
            hour: "numeric",
            minute: "numeric",
            hour12: true,
            timeZone: "UTC",
          })
          .toLocaleLowerCase();
        if (sttime.includes("am")) {
          eventdate.sttime = sttime.replace("am", "a.m.");
        }
        if (sttime.includes("pm")) {
          eventdate.sttime = sttime.replace("pm", "p.m.");
        }
        eventdate.stmonth = startDateObj.toLocaleString("default", {
          month: "short",
        });
        eventdate.endmonth = endDateObj.toLocaleString("default", {
          month: "short",
        });
        eventdate.styear = startDateObj.getFullYear();
        eventdate.endyear = endDateObj.getFullYear();
        return eventdate;
      } catch (err) {}
    };
    // US-574965: adding function to get date for curated events
    var getStartDateForEvents = function (promo) {
      try {
        var eventdate = getAllEventDates(promo);
        var eventtype = promo["event-type"].trim();
        if (eventdate.stdate !== "" && eventdate.stdate != "undefined") {
          if (eventtype === "Virtual" || eventtype === "virtual") {
            return eventdate.stdate;
          }
          if (eventtype === "Live" || eventtype === "live") {
            if (eventdate.stdate !== eventdate.enddate) {
              return eventdate.stdate + " - " + eventdate.enddate;
            } else if (
              eventdate.stdate === eventdate.enddate &&
              eventdate.stmonth !== eventdate.endmonth
            ) {
              return eventdate.stdate + " - " + eventdate.enddate;
            } else {
              return eventdate.stdate;
            }
          }
        }
      } catch (err) {}
    };
    // US-574965: adding function to get date for curated events
    var getStartMonthForEvents = function (promo) {
      try {
        var eventdate = getAllEventDates(promo);
        var eventtype = promo["event-type"].trim();

        if (eventdate.stmonth !== "" && eventdate.stmonth != "undefined") {
          if (eventtype === "Virtual" || eventtype === "virtual") {
            return eventdate.stmonth + ".";
          }

          if (eventtype === "Live" || eventtype === "live") {
            if (eventdate.stmonth !== eventdate.endmonth) {
              return eventdate.stmonth + ". " + eventdate.endmonth + ".";
            } else {
              return eventdate.stmonth + ".";
            }
          }
        }
      } catch (err) {}
    };
    /*Function to get start-date formatted*/
    var getPublishedDateFormatted = function (promo) {
      try {
        var eventdate = getAllEventDates(promo);
        var eventtype = promo["event-type"].trim();
        var timeZone =
          typeof promo["time-zone"] != "undefined" ? promo["time-zone"] : "";
        var city = typeof promo["city"] != "undefined" ? promo["city"] : "";
        var state = typeof promo["state"] != "undefined" ? promo["state"] : "";
        var country =
          typeof promo["event-country"] != "undefined"
            ? promo["event-country"]
            : "";
        var publishedDateFormatted;

        if (!isNaN(eventdate.stdate)) {
          var displayStartDate =
            eventdate.stdate + " " + eventdate.stmonth + ". ";
          var displayEndDate =
            eventdate.enddate +
            " " +
            eventdate.endmonth +
            ". " +
            eventdate.endyear;
          if (eventtype === "Virtual" || eventtype === "virtual") {
            publishedDateFormatted =
              eventdate.stday +
              ". | " +
              displayStartDate +
              eventdate.styear +
              " | " +
              eventdate.sttime +
              " " +
              timeZone;
            return publishedDateFormatted;
          }
          if (eventtype === "Live" || eventtype === "live") {
            const cityCountryvalue =
              city && country ? " | " + city + ", " + country : "";
            if (
              eventdate.stdate !== eventdate.enddate ||
              eventdate.stmonth !== eventdate.endmonth
            ) {
              if (eventdate.styear !== eventdate.endyear) {
                return (
                  displayStartDate +
                  eventdate.styear +
                  " - " +
                  displayEndDate +
                  cityCountryvalue
                );
              } else {
                return (
                  displayStartDate + " - " + displayEndDate + cityCountryvalue
                );
              }
            } else if (eventdate.stdate === eventdate.enddate) {
              if (eventdate.styear === eventdate.endyear) {
                return (
                  displayStartDate + " " + eventdate.styear + cityCountryvalue
                );
              } else {
                return (
                  displayStartDate +
                  " " +
                  eventdate.styear +
                  " - " +
                  displayEndDate +
                  cityCountryvalue
                );
              }
            }
          }
        }
      } catch (err) {}
    };

    /*Function to trim html tags in descrption*/
    var getDescription = function (promo) {
      try {
        if (promo.description.indexOf("<p>") >= 0) {
          var formatedDesc = promo.description.replace(/(<([^>]+)>)/gi, "");
          return formatedDesc;
        }
        return promo.description;
      } catch (err) {}
      return "";
    };
    /*Function to get the bookmark date*/
    var getbookmarkDate = function (promo) {
      var pageId = promo["page-id"];
      var bookmarkDetails = JSON.parse(sessionStorage.getItem("bookmarks"));
      for (var keys in bookmarkDetails) {
        if (bookmarkDetails[keys].id === pageId) {
          var bookmarkDate = bookmarkDetails[keys].date;
          var monthNames = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
          ];
          bookmarkDate = new Date(bookmarkDate);
          bookmarkDate =
            bookmarkDate.getDate() +
            " " +
            monthNames[bookmarkDate.getMonth()] +
            " " +
            bookmarkDate.getFullYear();
        }
      }
      return bookmarkDate;
    };
    /*Function to get the promo page url*/
    var getPageURL = function (promoPageURL) {
      try {
        var pageType = promoPageURL["page-type"];
        if (pageType !== "") {
          var pageURL = promoPageURL.url;
          pageURL = externalizerLink + pageURL.substring(1) + "?mdc=Feed_Click";
          return pageURL;
        }
      } catch (err) {
        return "";
      }
    };
    /*Function to show the Deloitte Insights text for Deloitte Insights promos*/
    var showText = function () {
      try {
        if (matchMedia("(min-width: 767px)").matches) {
          return false;
        } else {
          return true;
        }
      } catch (err) {}
    };
    /* US 263605: Function to show the Deloitte Insights Logo for Deloitte Insights promos*/
    var showLogo = function () {
      try {
        if (matchMedia("(min-width: 767px)").matches) {
          return true;
        } else {
          return false;
        }
      } catch (err) {}
    };
    /* US 263605: Function to get the page type to differntiate Deloitte Insights & Dcom promos*/
    var getPageType = function (promo) {
      try {
        var pageType = promo["page-type"];
        if (
          pageType !== "" &&
          (pageType === "di-legacy-articles" ||
            pageType === "legacy-multimedia" ||
            pageType === "flex-articlemultimedia")
        ) {
          return true;
        }
      } catch (err) {}
      return "";
    };
    /*Function to get the thumbnail*/
    var getThumbnail = function (promo) {
      try {
        var pageType = promo["page-type"];
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf("MSIE ");
        if (
          promo.thumbnail !== "" &&
          matchMedia("(min-width: 767px)").matches &&
          msie === -1 &&
          !navigator.userAgent.match(/Trident.*rv\:11\./)
        ) {
          if (pageType !== "" && pageType === "dcom-legacy-articles") {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.web.250.250.mobile.jpeg"
            );
          }
          if (
            pageType !== "" &&
            (pageType === "di-legacy-articles" ||
              pageType === "legacy-multimedia" ||
              pageType === "flex-articlemultimedia")
          ) {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.web.480.300.jpeg"
            );
          }
          if (pageType !== "" && pageType === "flex-blogpost") {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.web.436.228.jpeg"
            );
          }
          if (pageType !== "" && pageType === "flex-eventdetails") {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.thumbnail.319.319.png"
            );
          }
        } else {
          return false;
        }
      } catch (err) {}
    };
    /*Function to get the IE thumbnail*/
    var getIEThumbnail = function (promo) {
      try {
        var pageType = promo["page-type"];
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf("MSIE ");
        if (
          (promo.thumbnail !== "" &&
            matchMedia("(min-width: 767px)").matches &&
            msie > 0) ||
          !!navigator.userAgent.match(/Trident.*rv\:11\./)
        ) {
          if (pageType !== "" && pageType === "dcom-legacy-articles") {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.web.250.250.mobile.jpeg"
            );
          }
          if (
            pageType !== "" &&
            (pageType === "di-legacy-articles" ||
              pageType === "legacy-multimedia" ||
              pageType === "flex-articlemultimedia")
          ) {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.web.480.300.jpeg"
            );
          }
          if (pageType !== "" && pageType === "flex-blogpost") {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.web.436.228.jpeg"
            );
          }
          if (pageType !== "" && pageType === "flex-eventdetails") {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.thumbnail.319.319.png"
            );
          }
        } else {
          return false;
        }
      } catch (err) {}
    };
    // return a string only if the page type matches indexing event articles
    var getEventPromoClass = function (promo) {
      try {
        var pageType = promo["page-type"];
        if (pageType === "flex-eventdetails") {
          return "event-promo--standard";
        }
      } catch (err) {}
      return "";
    };
    /*Function to get the thumbnail*/
    var getMobileThumbnail = function (promo) {
      try {
        var pageType = promo["page-type"];
        if (promo.thumbnail !== "") {
          if (pageType !== "" && pageType === "dcom-legacy-articles") {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.web.250.250.mobile.jpeg"
            );
          }
          if (
            pageType !== "" &&
            (pageType === "di-legacy-articles" ||
              pageType === "legacy-multimedia" ||
              pageType === "flex-articlemultimedia")
          ) {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.web.480.300.jpeg"
            );
          }
          if (pageType !== "" && pageType === "flex-blogpost") {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.web.436.228.jpeg"
            );
          }
          if (pageType !== "" && pageType === "flex-eventdetails") {
            return (
              externalizerLink.slice(0, -1) +
              promo.thumbnail +
              "/jcr:content/renditions/cq5dam.thumbnail.319.319.png"
            );
          }
        } else {
          return false;
        }
      } catch (err) {}
    };
    /*Function to add the additional class for insights promos*/
    var getPromoClass = function (promo) {
      try {
        var pageType = promo["page-type"];
        if (
          pageType !== "" &&
          (pageType === "di-legacy-articles" ||
            pageType === "legacy-multimedia" ||
            pageType === "flex-articlemultimedia")
        ) {
          return "promo-insights";
        }
      } catch (err) {}
      return "";
    };

    /*Function to get month names */
    var getMonthNames = function () {
      return [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ];
    };

    /*Function to  send the bookmark date*/
    var sendBookmark = function (promoId, $event) {
      sendBookmarkToGigya(promoId);
      angular
        .element($event.currentTarget)
        .removeClass("add")
        .addClass("delete");
      var siblingElement = angular.element($event.currentTarget).siblings();
      siblingElement.removeClass("delete").addClass("add");

      var currentDate = new Date();
      var monthNames = getMonthNames();
      currentDate =
        currentDate.getDate() +
        " " +
        monthNames[currentDate.getMonth()] +
        " " +
        currentDate.getFullYear();
      siblingElement
        .children(".bookmarkDate-section")
        .text(bookmarkedI18N + " " + currentDate + "");
    };

    var utilityServiceFunctions = {
      getStartDateForEvents: getStartDateForEvents,
      getStartMonthForEvents: getStartMonthForEvents,
      getPublishedDateFormatted: getPublishedDateFormatted,
      getDescription: getDescription,
      getbookmarkDate: getbookmarkDate,
      getPageURL: getPageURL,
      showText: showText,
      showLogo: showLogo,
      getPageType: getPageType,
      getThumbnail: getThumbnail,
      getIEThumbnail: getIEThumbnail,
      getEventPromoClass: getEventPromoClass,
      getMobileThumbnail: getMobileThumbnail,
      getPromoClass: getPromoClass,
      sendBookmark: sendBookmark,
      getMonthNames: getMonthNames,
    };
    return utilityServiceFunctions;
  },
]);

// Stay on page modal show functionality
if (pagetype === "accountsettings") {
  var response = JSON.parse(sessionStorage.getItem("response"));

  if (response && response.loginProvider !== "site") {
    $("#change-password").hide();
  }

  // Stay on page modal show functionality
  var navigateToPage,aModalIsPresent;
  var stayOnPage = function () {
    aModalIsPresent = false;
    $("#modal-unsaved-alert").modal("hide");
  };
  var leaveThePage = function () {
    aModalIsPresent = false;
    try {
      if (navigateToPage.indexOf("www") >= 0) {
        window.location.href = navigateToPage;
      } else {
        location.pathname = navigateToPage;
      }
    } catch (err) {
      logOut();
    }
  };

  //populate all values on load
  $(document).ready(function () {
    $(":checkbox").each(function () {
      $(this).attr("data-initialvalue", $(this).is(":checked"));
    });
  });


  $(
    "a:not(a[href^='#']):not(a[class='profile__pic']):not(a[id='profile-initials'])"
  ).on("click", function (event) {
    if (
      !(typeof $(this).attr("target") != "undefined" &&
      $(this).attr("target").indexOf("_blank") >= 0 )
    ) {
      navigateToPage = $(this).attr("href");
    }
    
    if(changedValueMail===true || changedValueNotifi===true){
      event.preventDefault();
      aModalIsPresent = true;
      
      $("#modal-unsaved-alert").modal("show");
    }
  
  });



}

$(document).ready(function () {
  var siteValue = $.urlParam("site");
  var siteCookie = getCookie("myD_siteSelector");
  if (siteValue.length > 0 && siteValue.indexOf("insights") > -1) {
   
      siteValue = siteValue.replace("insights-", "");
    
  }
  if (siteValue) {
    siteValue = siteValue.replace("_", "-");
	/*Setting the myD_siteSelector cookie value to 1 year from the date of acceptence instead of 2099*/
	var expireDate = new Date();
	expireDate.setFullYear(expireDate.getFullYear() + 1); 
	var expires = "expires=" + expireDate.toUTCString();
    document.cookie =
      "myD_siteSelector=" +
      siteValue +
      "; expires= " + expires; "path=/; secure";
  }
  if (pagetype === "profile" || pagetype === "dashboard") {
    if ($("#ERR006").length) {
      $("#webcast-title").html(systemoverloadedmsg);
      $("#dbriefModal-body__msg").html(retryclickokmsg);
      $("#retry-button").parent().removeClass("d-none");
      $("#stay-on-page-button")
        .parent()
        .removeClass("col-md-12")
        .addClass("col-md-6");
    }
    // for profile page - registration dbrief flow
    else if ($("#ERR005").length && pagetype === "profile") {
      $("#dbriefModal #stay-on-page-button")
        .parent()
        .removeClass("col-md-6")
        .addClass("col-md-12");
    }
  }

  if (pagetype === "profile") {
    $('input[name="profile-interests"]').on("change", function () {
      $.each($('input[name="profile-interests"]'), function () {
        if (
          $(this).prop("checked") === false &&
          $(this).parents(".checkbox").parent().hasClass("optin-origin")
        ) {
          $(this).parents(".checkbox").parent().removeClass("optin-checked");
        } else if (
          $(this).prop("checked") === true &&
          $(this).parents(".checkbox").parent().hasClass("optin-origin")
        ) {
          $(this).parents(".checkbox").parent().addClass("optin-checked");
        }
      });
    });
  }

  if (pagetype === "subscription") {
    $('input[name="subscription-topics"]').on("change", function () {
      $.each($('input[name="subscription-topics"]'), function () {
        if (
          $(this).prop("checked") === false &&
          $(this)
            .parents(".checkbox.subscriptions")
            .parent()
            .hasClass("optin-origin")
        ) {
          $(this)
            .parents(".checkbox.subscriptions")
            .parent()
            .removeClass("optin-checked");
        } else if (
          $(this).prop("checked") === true &&
          $(this)
            .parents(".checkbox.subscriptions")
            .parent()
            .hasClass("optin-origin")
        ) {
          $(this)
            .parents(".checkbox.subscriptions")
            .parent()
            .addClass("optin-checked");
        }
      });
    });
  }

  /* Company dropdown code yo */

  var inp = document.getElementById("company-name");

  $("#company-name").keyup(function () {
    var val = $("#company-name").val();
    if (val.length > 2) {

        // Demandbase API for fetching company info
        $.ajax({
          url:
            "https://autocomplete.demandbase.com/autocomplete?callback=jQuery17104587620186874908_1556874374446&version=v1.7.2&sequence=22&term=" +
            val +
            "&key=M65mmM3vaL3giOy4cNEWnOAuvqHh83eUMjTyVFvM&records=10",
          dataType: "jsonp",
          success: function (data) {
            populateDOM(data.picks);
          },
        });

    } else {
      $(".dropdown-menu").remove();
    }
  });

  function populateDOM(arr) {
    var a, b;
    a = document.createElement("ul");
    a.setAttribute("id", this.id + "autocomplete-list");
    a.setAttribute("class", "dropdown-menu");
    for (var i = 0; i < arr.length; i++) {
      /*create a DIV element for each matching element:*/
      b = document.createElement("li");

        b.innerHTML +=
          "<a><span class='company-name'>" +
          arr[i].marketing_alias +
          "</span><br><span>" +
          arr[i].city +
          ", " +
          arr[i].country_name +
          "</span><span style='display: none;'>" +
          arr[i].demandbase_sid +
          "</span></a>";

      a.appendChild(b);

      b.addEventListener("click", function () {
        /*insert the value for the autocomplete text field:*/
        inp.value = $(this).find("span:first-child").text();

        /*close the list of autocompleted values,
                    (or any other open lists of autocompleted values:*/
        closeAllLists();
      });
      /*insert a input field that will hold the current array item's value: */
      $(".dropdown-menu").remove();
      var textBox = $(".company-dropdown");
      textBox.append(a);
    }

    var currentFocus;
    /*execute a function presses a key on the keyboard:*/
    inp.addEventListener("keydown", function (e) {
      var x = document.getElementById(this.id + "autocomplete-list");
      if (x) x = x.getElementsByTagName("ul");
      if (e.keyCode === 40) {
        /*If the arrow DOWN key is pressed,
                    increase the currentFocus variable:*/
        currentFocus++;
        /*and and make the current item more visible:*/
        addActive(x);
      } else if (e.keyCode === 38) {
        //up
        /*If the arrow UP key is pressed,
                    decrease the currentFocus variable:*/
        currentFocus--;
        /*and and make the current item more visible:*/
        addActive(x);
      } else if (e.keyCode === 13) {
        /*If the ENTER key is pressed, prevent the form from being submitted,*/
        e.preventDefault();
        if (currentFocus > -1 && x) {
          /*and simulate a click on the "active" item:*/
           x[currentFocus].click();
        }
      }
    });

    function addActive(x) {
      /*a function to classify an item as "active":*/
      if (!x) return false;
      /*start by removing the "active" class on all items:*/
      removeActive(x);
      if (currentFocus >= x.length) currentFocus = 0;
      if (currentFocus < 0) currentFocus = x.length - 1;
      /*add class "autocomplete-active":*/
      x[currentFocus].classList.add("dropdown-menu-active");
    }

    function removeActive(x) {
      /*a function to remove the "active" class from all autocomplete items:*/
      for (var i = 0; i < x.length; i++) {
        x[i].classList.remove("dropdown-menu-active");
      }
    }

    function closeAllLists(elmnt) {
      /*close all autocomplete lists in the document,
                except the one passed as an argument:*/
      var x = document.getElementsByClassName("dropdown-menu");
      for (var i = 0; i < x.length; i++) {
        if (elmnt !== x[i] && elmnt !== inp) {
          x[i].parentNode.removeChild(x[i]);
        }
      }
    }
    /*execute a function when someone clicks in the document:*/
    document.addEventListener("click", function (e) {
      closeAllLists(e.target);
    });
  }

  /*Function to initialize popover*/
  //VA: Move to main.js
  $(function () {
    $('[data-toggle="popover"]').popover();
  });
});
// On page load checking local & session variables to remove persistent session
// DE:246668 persistent session issue fix - calling logout function if sessioncookies is not available
$(window).load(function () {
  var keepMeLoginStatus = localStorage.getItem("keepMeLogin");
  var requestorSource = $.urlParam("newUser");
  if (
    !keepMeLoginStatus &&
    wcmMode === "DISABLED" &&
    !$(".email-unsubscribe").length &&
    !$(".myD-gatedFlow-container").length &&
    pagetype !== "registration" &&
    pagetype !== "genericerror" &&
    user_status !== null &&
    requestorSource !== "true"
  ) {
    var cookiename = getCookie("userLoggedInIs");
    if (cookiename !== "true") {
      logOut();
    }
  }

  // Set Language selector dropdown value on page load
  var siteInfo = getCookie("myD_siteSelector");
  if (siteInfo) {
    localStorage.setItem("prevSite", siteInfo);
    var langInfo = $(
      "#site-selector ul li a[data-lang=" + siteInfo + "] span"
    ).html();
    $(
      ".myD-registration-headline .site-language, .accounts-settings .site-language"
    ).html(langInfo);
    if (siteInfo === "global-en") {
      $("#country-check").removeAttr("checked");
      $(".country-dropdown").show();
    }
  }

  var bookmarkDetails = JSON.parse(sessionStorage.getItem("bookmarks"));
  var ALLOWED_PAGETYPES = ["dashboard", "bookmark", "feed"];
  var OFFLINE_URL;
  if ("serviceWorker" in navigator) {
    // cache the updated offline page first
    OFFLINE_URL = "/Offlinepage.html";
    removeArticleFromCache(OFFLINE_URL);
    saveArticleToCache(OFFLINE_URL);
    // todo: add standalone condition
    if (
      getCookie("pwaAccessCode") !== "" &&
      bookmarkDetails &&
      bookmarkDetails.length
    ) {
      if (ALLOWED_PAGETYPES.indexOf(pagetype) > -1) {
        try {
          // get all bookmark list for pwa offline
          var bookmarkDataQuery = bookmarkDetails
            .map(function (data) {
              return data.id;
            })
            .join("|");
          getFullResults(bookmarkDataQuery);
        } catch (e) {
          
        }
      }
    }
  }

  // US - 559620 Offline trigger
  if (getCookie("pwaAccessCode") !== "") {
    var getTrimURL = function(articleURL) {
      // return url wihtout analytics parameter and domain
      articleURL = new URL(articleURL);
      return articleURL.pathname;
    }
    // only if its PWA
    try {
      // capture click and save the article to cache
      $(".icon-bookmark-o").on("click", function () {
        var el = $(this).parents(".promo__bookmark-details").siblings("a");
        var article = {
          title: $(el).find("h2.promo-details__headline").text(),
          articleURL: "/cached" + getTrimURL($(el).attr("href")),
        };
        // save to cache
        saveArticleToCache(article.articleURL).then(
          saveArticleURLToLocalStorage({
            title: article.title,
            url: article.articleURL,
          })
        );
      });

      // capture click and remove the article from cache
      $(".icon-bookmark").on("click", function () {
        var el = $(this).parents(".promo__bookmark-details").siblings("a");
        var article = {
          title: $(el).find("h2.promo-details__headline").text(),
          articleURL: "/cached" + getTrimURL($(el).attr("href")),
        };
        // remove from cache
        removeArticleFromCache(article.articleURL).then(
          removeArticleFromLocalStorage({
            title: article.title,
            url: article.articleURL,
          })
        );
      });
    } catch (e) {
      
    }
  }
});

/** US 251477: Use hover styles for the current page (green border bottom) **/

if (sc_currentPageName.indexOf(pagetype) > -1) {
  $(".header-links").each(function () {
    var targetListItem = $(this).find("a").attr("href");
    if (targetListItem.indexOf(pagetype) > -1)
      $(this).find("a").addClass("active");
  });
}

//function getCookie
function getCookie(cname) {
  var name = cname + "=";
  var ca = document.cookie.split(";");
  for (var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) === " ") c = c.substring(1);
    if (c.indexOf(name) !== -1) return c.substring(name.length, c.length);
  }
  return "";
}

//Highlights the tab for optin URL's
function setFocusToTab() {
  var firstId;
  var showTabId;
  // profile page - aoi
  if (pagetype === "profile") {
    firstId = localStorage.getItem("aoiKey").split("+")[0];
    showTabId = $("input[type='checkbox'][value='" + firstId + "'")
      .closest(".card.tab-pane")
      .attr("id");
    $("ul.nav-tabs a[href='#" + showTabId + "']").tab("show");
  }
  // subscriptions page - sub
  if (pagetype === "subscription") {
    firstId = localStorage.getItem("subKey").split("+")[0];
    showTabId = $("input[type='checkbox'][value='" + firstId + "'")
      .closest(".card.tab-pane")
      .attr("id");
    $("ul.nav-tabs a[href='#" + showTabId + "']").tab("show");
  }
}
$(".site-language,.site-language-dropdown .icon-chevron-down").on(
  "click",
  selectSite
);
function selectSite(e) {
  e.preventDefault();
  $(".site-language-dropdown").toggleClass("open");
}

// site selector set cookie functionality
function setSiteLanguage(cookieValue) {
  var langInfo = $(
    "#site-selector ul li a[data-lang=" + cookieValue + "] span"
  ).html();
  var datalangcookie = cookieValue.split("-");
  var locale = datalangcookie[0];
  var language = datalangcookie[1];
  var url =
    "https://www2.deloitte.com/" +
    locale +
    "/" +
    language +
    "/" +
    "footerlinks1/terms-of-use.html";

  $(".accounts-settings .site-language").html(langInfo);

  $("#country-update").html(langInfo);
  
  if (pagetype === "registration" && $("#modal-site-confirm-language").hasClass("show")) {
      $("#modal-site-confirm-language").modal("hide");
    }
  
  $("#modal-site-language").modal("show");
  if (pagetype === "accountsettings") {
    $("#modal-site-language .countryHelper__desc a").attr("href", url);
  }
  $("#confirmSiteLanguage").on("click", function () {
    if (pagetype === "accountsettings") {
      updateAccountSettingsIntSub(cookieValue);
	  try{
      // remove OT Cookies that were set
      removeOTCookies();
      }catch(err){
         
      }
    }
    if (mydaas_action !== "" && pagetype === "registration") {
          var urlParams = new URLSearchParams(window.location.search);
          var site =  urlParams.get('site');
          var flow =  urlParams.get('flow');
          var state = urlParams.get('state');
            if(site != cookieValue){
              site=cookieValue;
            }
            if(site != null && flow != null && state !=null){
              window.location.href = window.location.href.split('?')[0]+'?site='+site+'&flow='+flow+'&state='+state
              return false;
            }
            else if(site != null && flow != null && state == null){
			  window.location.href = window.location.href.split('?')[0]+'?site='+site+'&flow='+flow
              return false;
            }
            else if(site != null && flow == null && state == null){
			  window.location.href = window.location.href.split('?')[0]+'?site='+site
              return false;
            }
            else{
              window.location.href = window.location.href.split('?')[0]
              return false;
         }
	  }
    setSiteSelector(cookieValue);
  });
}

// Account settings site selector change
$(".confirm-AccSiteLanguage").on("click", function () {
  window.location.href = "./profile.html#profile-interest";
});

// Code to load country on landing page
loadMemeberfirms();

/* function for Email special characters validation */
function validateEmailInput(_input) {
  // Regex to check the special characters in Email
  var Regex = /["(),:;<>[\]\{\}~\\]/;
  if ($(_input).hasClass("valid-email-text")) {
    if (
      Regex.test($(_input).val()) &&
      !$(".myD-register-form .gigya-error-msg.gigya-error-msg-active").length
    ) {
      $(_input).siblings(".valid-inputs-Email").show();
    } else {
      $(_input).siblings(".valid-inputs-Email").hide();
    }
  }
}

// function to get all bookmark results for PWA
function getFullResults(query) {
  var queryURL =
    snpAccountURLBookmarks +
    "?do=json_query&count=50&sp_x_1=sc-pagename&sp_q_exact_1=" +
    query +
    "";
  $.getJSON(queryURL, function (data) {
    var bookmarkDataResponse = data["result-sets"];
    localStorage.removeItem("cachedArticles");
    try {
      saveArticlesToCache(bookmarkDataResponse);
    } catch (e) {

    }
  });
}
